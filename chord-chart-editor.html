<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Chart Editor</title>
    <meta name="app-version" content="v2.1.0">
    <!-- PWA Manifest (disabled for file:// protocol - only works on web server) -->
    <!-- <link rel="manifest" href="./manifest.json"> -->
    <meta name="theme-color" content="#d84315">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Band Manager">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23d84315' stroke-width='2'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>">
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/layout.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Custom Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-light);
        }

        ::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }

        /* Firefox Scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Background watermark - Guitar */
        body::before {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.15'%3E%3Ccircle cx='12' cy='17' r='4.5'/%3E%3Cline x1='12' y1='12.5' x2='12' y2='2'/%3E%3Cline x1='9' y1='5' x2='15' y2='5'/%3E%3Cline x1='9' y1='8' x2='15' y2='8'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s ease;
        }

        /* Background watermark - Drum (hidden by default) */
        body::after {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' fill='none' stroke='%23ffffff' stroke-width='1.5' opacity='0.15'%3E%3Ccircle cx='23' cy='17' r='4.5'/%3E%3Cline x1='16' y1='21.5' x2='16' y2='2'/%3E%3Cline x1='11' y1='5' x2='21' y2='5'/%3E%3Cline x1='18' y1='8' x2='28' y2='8'/%3E%3Cline x1='21' y1='10' x2='26' y2='10'/%3E%3Cline x1='7' y1='12.5' x2='18' y2='12.5'/%3E%3Cline x1='30' y1='12.5' x2='30' y2='2'/%3E%3Cline x1='25' y1='5' x2='35' y2='5'/%3E%3Cline x1='27' y1='8' x2='33' y2='8'/%3E%3Cline x1='26' y1='14' x2='31' y2='14'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show drum watermark when active */
        body.drum-watermark::before {
            opacity: 0;
        }

        body.drum-watermark::after {
            opacity: 1;
        }

        /* BlackDoubt watermark overlay (hidden by default) */
        .blackdoubt-watermark-overlay {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.12'%3E%3Cpath d='M 20 3 L 37 20 L 20 37 L 3 20 Z' stroke='%23ffffff' fill='none' stroke-width='1.5'/%3E%3Ccircle cx='20' cy='20' r='13' stroke='%23ffffff' fill='none' stroke-width='1.5'/%3E%3Ctext x='20' y='20' font-size='20' font-family='serif' text-anchor='middle' dominant-baseline='central' fill='%23ffffff' stroke='none'%3E%F0%9D%94%85%3C/text%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show BlackDoubt watermark when active */
        body.blackdoubt-watermark::before,
        body.blackdoubt-watermark::after {
            opacity: 0;
        }

        body.blackdoubt-watermark .blackdoubt-watermark-overlay {
            opacity: 1;
        }

        /* Header */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .header {
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary-color);
            flex-shrink: 0;
            position: relative;
            z-index: 9998;
            box-shadow: 0 2px 10px var(--primary-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: visible;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            color: var(--primary-light);
            text-shadow: 0 0 20px var(--primary-glow);
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            flex-shrink: 0;
        }

        .header h1 svg {
            width: 20px;
            height: 20px;
        }

        .header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .nav-links {
            display: flex;
            gap: 10px;
        }

        .nav-link {
            padding: 6px 12px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            color: var(--primary-light);
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 13px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            display: inline-flex;
            align-items: center;
        }

        .nav-link:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
            color: var(--primary-lighter);
            box-shadow: 0 0 10px var(--primary-glow);
            transform: translateY(-2px);
        }

        .theme-selector {
            padding: 6px 8px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            color: var(--primary-light);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
            min-width: 70px;
            max-width: 90px;
        }

        .theme-selector:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
        }

        .btn {
            padding: 6px 12px;
            border: 2px solid var(--primary-light);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        .btn-primary {
            background: var(--primary-dark);
            color: var(--primary-light);
        }

        .btn-primary:hover {
            background: var(--primary-darker);
            color: var(--primary-lighter);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2a2d33;
            color: #c1c7d0;
        }

        .btn-secondary:hover {
            background: #3a3e47;
            color: #e5e9f0;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #5c1d0a;
            color: #ff6b3d;
            border: 2px solid #ff6b3d;
        }

        .btn-danger:hover {
            background: #7a2710;
            color: #ffa580;
            transform: translateY(-2px);
        }

        .btn-danger:disabled {
            background: #2a1d1a;
            color: #664d3d;
            border-color: #664d3d;
            cursor: not-allowed;
            transform: none;
        }

        /* Main Layout */
        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        /* Left Sidebar - Component Palette */
        .left-sidebar {
            width: 140px;
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-right: 2px solid var(--primary-border);
            padding: 15px 8px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 2px 0 10px var(--primary-glow);
        }

        .palette-title {
            color: var(--primary-light);
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
        }

        .component-item {
            padding: 8px;
            margin-bottom: 5px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            border-radius: 8px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s;
            -webkit-user-select: none;
            user-select: none;
            font-weight: 600;
            font-size: 13px;
            color: var(--primary-light);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .component-item:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
            color: var(--primary-lighter);
            transform: translateX(5px);
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .component-item:active {
            cursor: grabbing;
        }

        /* Center - Drop Zone */
        .center-pane {
            flex: 1;
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .song-info {
            background: rgba(26, 26, 26, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--primary-border);
            margin-bottom: 20px;
            box-shadow: 0 2px 10px var(--primary-glow);
        }

        .song-info-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .song-info-title {
            flex: 1;
            min-width: 0;
        }

        .show-time-btn {
            background: var(--primary-bg);
            border: 2px solid var(--primary-color);
            color: var(--primary-light);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
            font-weight: bold;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .show-time-btn:hover {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 4px 15px var(--primary-glow);
            transform: translateY(-2px);
        }

        .show-time-btn svg {
            width: 16px;
            height: 16px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
        }

        .song-info h2 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
            margin-bottom: 5px;
        }

        .song-info .artist {
            color: var(--text-secondary);
            font-size: 16px;
            margin-bottom: 10px;
        }

        .song-info .meta {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: var(--text-tertiary);
        }

        .drop-zone {
            min-height: 400px;
            border: 2px dashed var(--primary-border);
            border-radius: 8px;
            padding: 20px;
        }

        .drop-zone.drag-over {
            border-color: var(--primary-light);
            background: var(--primary-bg);
            box-shadow: 0 0 20px var(--primary-glow);
        }

        .drop-zone-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-tertiary);
        }

        .drop-zone-empty svg {
            width: 64px;
            height: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
            stroke: var(--primary-color);
        }

        /* Component Tiles */
        .component-tile {
            background: rgba(26, 26, 26, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px var(--primary-glow);
            transition: all 0.3s;
        }

        .component-tile:hover {
            border-color: var(--primary-light);
            box-shadow: 0 6px 20px var(--primary-glow);
            transform: translateY(-2px);
        }

        .component-tile.dragging {
            opacity: 0.5;
        }

        .component-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--primary-border);
        }

        .component-title {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
            font-weight: bold;
            font-size: 16px;
            flex: 1;
        }

        .component-actions {
            display: flex;
            gap: 5px;
        }

        .icon-btn {
            background: var(--primary-bg);
            border: 2px solid var(--primary-border);
            color: var(--primary-light);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .icon-btn:hover {
            color: var(--primary-lighter);
            background: var(--primary-darker);
            border-color: var(--primary-light);
            transform: scale(1.1);
        }

        .drag-handle {
            cursor: grab;
            padding: 4px 8px;
            margin-right: 10px;
            color: var(--primary-light);
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            background: var(--primary-bg);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            -webkit-user-select: none;
            user-select: none;
        }

        .drag-handle:hover {
            background: var(--primary-darker);
            border-color: var(--primary-light);
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Custom Range Slider (Theme-matched) */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        /* Slider Track */
        input[type="range"]::-webkit-slider-track {
            background: rgba(0, 0, 0, 0.5);
            height: 6px;
            border-radius: 3px;
            border: 1px solid var(--primary-border);
        }

        input[type="range"]::-moz-range-track {
            background: rgba(0, 0, 0, 0.5);
            height: 6px;
            border-radius: 3px;
            border: 1px solid var(--primary-border);
        }

        /* Slider Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            border: 2px solid var(--primary-light);
            margin-top: -6px;
            box-shadow: 0 0 8px var(--primary-glow);
            transition: all 0.3s;
        }

        input[type="range"]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            border: 2px solid var(--primary-light);
            box-shadow: 0 0 8px var(--primary-glow);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.15);
            box-shadow: 0 0 12px var(--primary-glow);
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.15);
            box-shadow: 0 0 12px var(--primary-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            background: var(--primary-lighter);
        }

        input[type="range"]::-moz-range-thumb:active {
            background: var(--primary-lighter);
        }

        /* Custom Checkbox (Theme-matched) */
        input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        input[type="checkbox"]:hover {
            border-color: var(--primary-light);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        input[type="checkbox"]:checked {
            background: var(--primary-color);
            border-color: var(--primary-light);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        /* Autoscroll Controls (Inside Modal, Scrolls with content) */
        #printModal .autoscroll-controls {
            position: sticky;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 1000;
            display: none;
            justify-content: flex-end;
            align-items: flex-end;
            gap: 15px;
            pointer-events: none;
            padding-right: 30px;
            /* Take no space - orbs overlay content */
            background: transparent;
            border: none;
            margin: 0;
            height: 0;
            overflow: visible;
        }

        #printModal.show .autoscroll-controls.show {
            display: flex;
        }

        .autoscroll-controls > * {
            pointer-events: auto;
        }

        /* Speed Adjustment Orbs */
        .speed-orb {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(26, 26, 26, 0.95);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            border: 2px solid var(--primary-border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
        }

        .speed-orb:hover {
            border-color: var(--primary-light);
            color: var(--primary-light);
            transform: scale(1.15);
            box-shadow: 0 6px 25px var(--primary-glow);
        }

        .speed-orb:active {
            transform: scale(0.95);
        }

        /* Combined Play/Speed Display Orb */
        .autoscroll-play-btn {
            width: 75px;
            height: 75px;
            border-radius: 50%;
            background: rgba(26, 26, 26, 0.95);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            border: 3px solid var(--primary-color);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            transition: all 0.3s;
            box-shadow: 0 6px 30px var(--primary-glow);
            position: relative;
        }

        .autoscroll-play-btn:hover {
            transform: scale(1.1);
            border-color: var(--primary-light);
            box-shadow: 0 8px 40px var(--primary-glow);
        }

        .autoscroll-play-btn:active {
            transform: scale(0.95);
        }

        .autoscroll-play-btn.playing {
            background: var(--primary-color);
            border-color: var(--primary-light);
        }

        .autoscroll-play-btn svg {
            width: 22px;
            height: 22px;
            fill: var(--primary-light);
            flex-shrink: 0;
        }

        .autoscroll-play-btn.playing svg {
            fill: white;
        }

        .speed-display-text {
            font-size: 12px;
            font-weight: bold;
            color: var(--primary-light);
            margin-top: -2px;
        }

        .autoscroll-play-btn.playing .speed-display-text {
            color: white;
        }

        /* Modal body to allow sticky positioning */
        #printModal .modal-body {
            position: relative;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .component-textarea {
            width: 100%;
            min-height: 100px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            padding: 10px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }

        .component-textarea:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        /* Grid Editor Styles */
        .grid-editor {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
        }

        .grid-editor-table {
            border-collapse: separate;
            border-spacing: 0;
            font-family: 'Courier New', monospace;
            min-width: 100%;
        }

        .grid-controls {
            margin-bottom: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .grid-controls .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-width: 36px;
            padding: 8px 12px;
        }
        
        .grid-controls .btn svg {
            flex-shrink: 0;
        }
        
        .grid-controls .btn-text {
            display: inline;
        }
        
        @media (max-width: 768px) {
            .grid-controls {
                gap: 6px;
            }
            
            .grid-controls .btn {
                padding: 8px;
                min-width: 40px;
                font-size: 0;
            }
            
            .grid-controls .btn svg {
                width: 18px;
                height: 18px;
            }
            
            .grid-controls .btn-text {
                display: none;
            }
        }

        .grid-indicator-cell {
            background: rgba(0, 0, 0, 0.5);
            border-right: 2px solid var(--primary-border);
            padding: 6px;
            vertical-align: middle;
            text-align: center;
            width: 40px;
            min-width: 40px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .grid-indicator-cell:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .grid-row-selected .grid-indicator-cell {
            background: rgba(33, 150, 243, 0.4);
        }

        .row-indicator {
            font-size: 14px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            min-width: 24px;
            text-align: center;
        }

        .row-indicator-generic {
            background: rgba(100, 100, 100, 0.3);
            color: #aaa;
            border: 1px solid #666;
        }

        .row-indicator-chord {
            background: rgba(33, 150, 243, 0.3);
            border: 1px solid var(--primary-color);
            color: var(--primary-light);
        }

        .row-indicator-lyric {
            background: rgba(0, 200, 100, 0.3);
            border: 1px solid #00c864;
            color: #00ff80;
        }

        .grid-content-cell {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(100, 100, 100, 0.5);
            padding: 0;
            width: 20px;
            height: 24px;
        }

        /* Grid cell inputs - CRITICAL: Override all theme styles */
        .grid-cell-input {
            width: 100%;
            height: 100%;
            background: transparent !important;
            border: none !important;
            color: #ffffff !important;
            font-family: 'Courier New', monospace !important;
            font-size: 14px !important;
            font-weight: bold !important;
            text-align: center !important;
            padding: 4px 2px !important;
            outline: none;
            line-height: normal !important;
            -webkit-text-fill-color: #ffffff !important;
            -moz-text-fill-color: #ffffff !important;
            text-fill-color: #ffffff !important;
            text-shadow: 0 0 1px rgba(255, 255, 255, 0.8) !important;
            /* Ensure no background clip interferes */
            -webkit-background-clip: border-box !important;
            background-clip: border-box !important;
            /* Reset any gradient effects */
            background-image: none !important;
        }

        .grid-cell-input:focus {
            background: rgba(255, 255, 255, 0.1) !important;
            outline: 2px solid var(--primary-color) !important;
            outline-offset: -2px;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.5) !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
        }

        .grid-cell-input:hover {
            background: rgba(255, 255, 255, 0.05) !important;
        }

        .grid-cell-input::placeholder {
            color: rgba(255, 255, 255, 0.3) !important;
            opacity: 1 !important;
            -webkit-text-fill-color: rgba(255, 255, 255, 0.3) !important;
        }
        
        /* Make sure grid inputs are not affected by theme gradients */
        [data-theme="synthwave"] .grid-cell-input,
        [data-theme="prism"] .grid-cell-input {
            background: transparent !important;
            background-image: none !important;
            -webkit-background-clip: border-box !important;
            -webkit-text-fill-color: #ffffff !important;
            color: #ffffff !important;
        }

        /* Multi-cell selection styling */
        .grid-content-cell.selected {
            background: rgba(33, 150, 243, 0.4) !important;
            border: 2px solid var(--primary-color) !important;
        }

        .grid-content-cell.selected .grid-cell-input {
            background: rgba(33, 150, 243, 0.2) !important;
        }

        .grid-row-selected {
            background: rgba(33, 150, 243, 0.15);
        }

        .grid-editor-table td {
            border: 1px solid var(--primary-border);
            padding: 0;
            text-align: center;
            vertical-align: middle;
            min-width: 24px;
            max-width: 24px;
            height: 30px;
        }

        .grid-editor-table tr:first-child td {
            background: rgba(0, 0, 0, 0.5);
        }

        /* Grid cells are now uniform - old chord/lyric specific styles removed */

        .chord-format-hint {
            margin-top: 5px;
            font-size: 12px;
            color: var(--text-tertiary);
        }

        /* Right Sidebar - Settings */
        .right-sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-left: 2px solid var(--primary-border);
            padding: 20px 10px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: -2px 0 10px var(--primary-glow);
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
        }

        .right-sidebar.collapsed {
            width: 40px;
            padding: 20px 5px;
            overflow: hidden;
        }

        .right-sidebar.collapsed .settings-section {
            display: none;
        }

        .collapse-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--primary-bg);
            border: 2px solid var(--primary-border);
            color: var(--primary-light);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
            z-index: 10;
        }

        .right-sidebar.collapsed .collapse-toggle {
            right: 5px;
        }

        .collapse-toggle:hover {
            color: var(--primary-lighter);
            background: var(--primary-darker);
            border-color: var(--primary-light);
            transform: scale(1.1);
        }

        .collapsed-label {
            display: none;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            color: var(--primary-light);
            font-weight: bold;
            font-size: 14px;
            margin-top: 60px;
            text-align: center;
        }

        .right-sidebar.collapsed .collapsed-label {
            display: block;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-title {
            color: var(--primary-light);
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .setting-item input[type="radio"] {
            margin-right: 5px;
        }

        .setting-item select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            color: var(--text-primary);
            border-radius: 4px;
        }

        /* Print Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 90px 20px 20px 20px;
        }

        .modal-content {
            background: rgba(26, 26, 26, 0.95);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            padding: 0;
            border-radius: 8px;
            max-width: 1200px;
            width: 90%;
            max-height: calc(100vh - 110px);
            overflow: hidden;
            border: 2px solid var(--primary-border);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 2px solid var(--primary-border);
            position: sticky;
            top: 0;
            background: rgba(26, 26, 26, 0.98);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            z-index: 100;
            flex-shrink: 0;
        }

        .modal-header h2 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .close {
            color: var(--text-tertiary);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close:hover {
            color: var(--primary-light);
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
        }

        .print-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            padding: 8px 10px;
            background: var(--primary-bg);
            border-radius: 8px;
            border: 2px solid var(--primary-border);
        }
        
        .print-controls .btn {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .print-controls .setting-item {
            font-size: 12px;
        }

        .print-preview {
            background: white;
            color: black;
            padding: 30px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .performance-view {
            background: rgba(26, 26, 26, 0.95);
            color: var(--text-primary);
            padding: 30px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            border: 2px solid var(--primary-border);
        }

        .view-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--primary-border);
            padding-bottom: 6px;
        }

        .tab-button {
            padding: 6px 12px;
            background: var(--primary-bg);
            border: 1px solid var(--primary-border);
            color: var(--primary-light);
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 13px;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
            border-bottom-color: transparent;
            border-width: 1px;
        }

        .tab-button:hover:not(.active) {
            background: var(--primary-darker);
            border-color: var(--primary-light);
        }

        .print-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid black;
            padding-bottom: 10px;
        }

        .performance-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        .print-header h1,
        .performance-header h1 {
            font-size: 20px;
            margin-bottom: 3px;
        }

        .print-header h1 {
            color: #000;
        }

        .performance-header h1 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .print-header h2,
        .performance-header h2 {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .print-header h2 {
            color: #555;
        }

        .performance-header h2 {
            color: var(--text-secondary);
        }

        .print-lyrics,
        .performance-lyrics {
            line-height: 1.8;
            padding-left: 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            flex: 1;
        }

        .print-lyrics {
            line-height: 1.8;
            padding-left: 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            flex: 1;
        }

        .chord-line {
            font-weight: bold;
            font-size: 1em;
            white-space: pre-wrap;
        }

        .lyric-line {
            font-size: 1em;
            white-space: pre-wrap;
        }

        .print-preview .chord-line {
            color: #d84315;
        }

        .performance-container .chord-line {
            color: rgba(255, 255, 255, 0.4);
            opacity: 0.7;
        }

        .performance-view .lyric-line {
            color: var(--text-primary);
        }

        .print-preview .lyric-line {
            color: #000;
        }

        .performance-view .lyric-line {
            color: var(--text-primary);
        }

        .print-component h3,
        .performance-component {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .performance-component h3 {
            font-size: 1.1em;
            margin: 0;
            padding-right: 20px;
            font-weight: bold;
            min-width: 120px;
            flex-shrink: 0;
        }

        .print-component {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .print-component h3 {
            font-size: 1.1em;
            margin: 0;
            padding-right: 20px;
            font-weight: bold;
            min-width: 120px;
            flex-shrink: 0;
            color: #333;
        }

        .performance-component h3 {
            color: var(--primary-light);
            text-shadow: 0 0 5px var(--primary-glow);
        }

        .print-header h1,
        .performance-header h1 {
            font-size: 1.5em;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .print-header h1 {
            color: #000;
        }

        .performance-header h1 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .print-header h2,
        .performance-header h2 {
            font-size: 1.2em;
            margin-bottom: 8px;
        }

        .print-header h2 {
            color: #555;
        }

        .performance-header h2 {
            color: var(--text-secondary);
        }

        .print-meta,
        .performance-meta {
            display: flex;
            justify-content: center;
            gap: 15px;
            font-size: 0.95em;
            flex-wrap: wrap;
        }

        .performance-meta {
            color: var(--text-tertiary);
        }

        /* Print Styles */
        @media print {
            body * {
                visibility: hidden;
            }
            #printPreview, #printPreview * {
                visibility: visible;
            }
            #printPreview {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 0.5in;
            }
            #performanceView {
                display: none !important;
            }
            .modal, .print-controls {
                display: none !important;
            }
        }

        /* Auto-save Indicator */
        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 2px solid var(--primary-light);
        }

        .save-indicator.show {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .header h1 {
                font-size: 18px;
            }
            .song-selector {
                max-width: 300px;
            }
        }

        @media (max-width: 1024px) {
            .left-sidebar, .right-sidebar {
                width: 180px;
            }
            .header {
                padding: 8px 12px;
            }
            .header h1 {
                font-size: 16px;
            }
            .header h1 svg {
                width: 18px;
                height: 18px;
            }
            .song-selector {
                max-width: 250px;
            }
            .btn, .nav-link {
                padding: 5px 10px;
                font-size: 12px;
            }
        }

        @media (max-width: 768px) {
            .main-layout {
                flex-direction: column;
            }
            .left-sidebar, .right-sidebar {
                width: 100%;
                max-height: 200px;
            }
            .header {
                padding: 6px 10px;
            }
            .header h1 {
                font-size: 14px;
            }
            .song-selector label {
                display: none;
            }
            .song-selector {
                min-width: 150px;
                max-width: 200px;
            }
            .btn, .nav-link {
                padding: 4px 8px;
                font-size: 11px;
            }
        }

        /* Component Selector Modal Styles */
        .component-selector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            padding: 10px 0;
        }

        .component-selector-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 16px 12px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            color: var(--primary-light);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
            min-height: 80px;
        }

        .component-selector-btn:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
            color: var(--primary-lighter);
            transform: translateY(-2px);
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .component-selector-btn svg {
            width: 24px;
            height: 24px;
        }

        /* Mobile Add Component Button */
        .mobile-add-component-btn {
            display: none; /* Hidden on desktop */
            width: 100%;
            padding: 20px;
            margin-top: 15px;
            background: var(--primary-dark);
            border: 2px dashed var(--primary-light);
            color: var(--primary-light);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s;
            text-align: center;
        }

        .mobile-add-component-btn:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
            color: var(--primary-lighter);
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .mobile-add-component-btn svg {
            width: 24px;
            height: 24px;
            vertical-align: middle;
            margin-right: 8px;
        }

        /* Show add button on mobile */
        @media (max-width: 768px) {
            .mobile-add-component-btn {
                display: block;
            }

            /* Simplify component selector for mobile */
            .component-selector-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .component-selector-btn {
                min-height: 70px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <!-- BlackDoubt Watermark Overlay -->
    <div class="blackdoubt-watermark-overlay"></div>
    
    <!-- Header -->
    <div class="header">
        <h1>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18V5l12-2v13"/>
                <circle cx="6" cy="18" r="3"/>
                <circle cx="18" cy="16" r="3"/>
            </svg>
            Chord Chart Editor
        </h1>
        
        <div class="header-controls" style="margin-left: auto;">
            <div class="nav-links">
                <a href="song-manager.html" class="nav-link">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                    </svg>
                    Songs
                </a>
                <a href="setlist-manager.html" class="nav-link">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <line x1="8" y1="6" x2="21" y2="6"/>
                        <line x1="8" y1="12" x2="21" y2="12"/>
                        <line x1="8" y1="18" x2="21" y2="18"/>
                        <line x1="3" y1="6" x2="3.01" y2="6"/>
                        <line x1="3" y1="12" x2="3.01" y2="12"/>
                        <line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                    Setlists
                </a>
                <a href="show-time.html" class="nav-link">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Show Time
                </a>
                <a href="storage-wizard.html" class="nav-link">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Storage Wizard
                </a>
            </div>
            <label for="themeSelector" class="visually-hidden">Select theme color</label>
            <select id="themeSelector" name="themeSelector" class="theme-selector" title="Choose theme color" aria-label="Theme color selector" onchange="changeTheme(this.value)">
                    <option value="grey">Grey</option>
                    <option value="red">Red</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                    <option value="purple">Purple</option>
                    <option value="cyan">Cyan</option>
                    <option value="teal">Teal</option>
                    <option value="copper">Copper</option>
                    <option value="amber">Amber</option>
                    <option value="pink">Pink</option>
                    <option value="sunrise">Sunrise</option>
                    <option value="sunset">Sunset</option>
                    <option value="synthwave">Synth Wave</option>
                    <option value="prism">Dark Prism</option>
                </select>
                <button class="btn btn-primary" onclick="togglePrintModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                        <polyline points="6 9 6 2 18 2 18 9"/>
                        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                        <rect x="6" y="14" width="12" height="8"/>
                    </svg>
                    View/Print
                </button>
        </div>
        
        <!-- Mobile Menu Button (Hamburger) - Rightmost position -->
        <button class="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="Open menu">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>
    </div>
    
    <!-- Song Selector Row - Below header like song-manager search bar -->
    <div class="song-selector-row" style="background: rgba(0, 0, 0, 0.1); backdrop-filter: blur(5px); border-bottom: 1px solid var(--primary-border); padding: 10px 15px; display: flex; align-items: center; gap: 10px; position: sticky; top: var(--header-height, 60px); z-index: 999;">
        <label for="songSearch" style="color: var(--text-primary); font-weight: 500; font-size: 14px; flex-shrink: 0;">Song:</label>
        <div style="position: relative; flex: 1; max-width: 500px; z-index: 9999;">
            <input 
                type="text" 
                id="songSearch"
                name="songSearch"
                title="Search for a song by artist or title"
                placeholder="Type to search songs..."
                autocomplete="off"
                autocorrect="off"
                autocapitalize="off"
                spellcheck="false"
                value=""
                aria-label="Search songs by artist or title"
                style="width: 100%; padding: 8px 12px; background: var(--card-bg); color: var(--text-primary); border: 1px solid var(--primary-border); border-radius: 4px; font-size: 14px;"
                oninput="filterSongs()"
                onfocus="showSongList()"
            />
            <div id="songList" class="song-list-dropdown" role="listbox" aria-label="Song search results" style="display: none; position: absolute; top: 100%; left: 0; right: 0; max-height: 400px; overflow-y: auto; background: var(--card-bg); border: 1px solid var(--primary-border); border-radius: 4px; margin-top: 4px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
            </div>
        </div>
    </div>

    <!-- Mobile Command Menu (Full Screen Overlay) -->
    <div class="mobile-menu-overlay" id="mobileMenu">
        <div class="mobile-menu-header">
            <span class="mobile-menu-title">Menu</span>
            <button class="mobile-menu-close" onclick="toggleMobileMenu()" aria-label="Close menu"></button>
        </div>
        <div class="mobile-menu-content">
            <!-- Navigation Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Navigate</div>
                <a href="song-manager.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="19" y1="12" x2="5" y2="12"/>
                        <polyline points="12 19 5 12 12 5"/>
                    </svg>
                    Songs
                </a>
                <a href="setlist-manager.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="8" y1="6" x2="21" y2="6"/>
                        <line x1="8" y1="12" x2="21" y2="12"/>
                        <line x1="8" y1="18" x2="21" y2="18"/>
                        <line x1="3" y1="6" x2="3.01" y2="6"/>
                        <line x1="3" y1="12" x2="3.01" y2="12"/>
                        <line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                    Setlists
                </a>
                <a href="show-time.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Show Time
                </a>
                <a href="storage-wizard.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Storage Wizard
                </a>
            </div>

            <!-- Actions Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Actions</div>
                <button class="btn btn-primary" onclick="togglePrintModal(); toggleMobileMenu();" style="width: 100%;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 6 2 18 2 18 9"/>
                        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                        <rect x="6" y="14" width="12" height="8"/>
                    </svg>
                    View/Print
                </button>
                <button class="btn btn-secondary" onclick="saveChart(); toggleMobileMenu();" style="width: 100%;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Chart
                </button>
            </div>

            <!-- Theme Section (Last) -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Theme</div>
                <select id="mobileThemeSelector" class="theme-selector" onchange="changeTheme(this.value)">
                    <option value="grey">Grey</option>
                    <option value="red">Red</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                    <option value="purple">Purple</option>
                    <option value="cyan">Cyan</option>
                    <option value="teal">Teal</option>
                    <option value="copper">Copper</option>
                    <option value="amber">Amber</option>
                    <option value="pink">Pink</option>
                    <option value="sunrise">Sunrise</option>
                    <option value="sunset">Sunset</option>
                    <option value="synthwave">Synth Wave</option>
                    <option value="prism">Dark Prism</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
        <!-- Left Sidebar - Component Palette -->
        <div class="left-sidebar">
            <div class="palette-title">Drag Components</div>
            <div class="component-item" draggable="true" data-type="Intro">Intro</div>
            <div class="component-item" draggable="true" data-type="Verse">Verse</div>
            <div class="component-item" draggable="true" data-type="Chorus">Chorus</div>
            <div class="component-item" draggable="true" data-type="Pre-Chorus">Pre-Chorus</div>
            <div class="component-item" draggable="true" data-type="Bridge">Bridge</div>
            <div class="component-item" draggable="true" data-type="Solo">Solo</div>
            <div class="component-item" draggable="true" data-type="Interlude">Interlude</div>
            <div class="component-item" draggable="true" data-type="Outro">Outro</div>
            <div class="component-item" draggable="true" data-type="Tag/Coda">Tag/Coda</div>
        </div>

        <!-- Center Pane - Drop Zone -->
        <div class="center-pane">
            <div class="song-info" id="songInfo">
                <div class="song-info-header">
                    <div class="song-info-title">
                        <h2 id="songTitle">Loading...</h2>
                        <div class="artist" id="songArtist"></div>
                        <div class="meta">
                            <span id="songKey"></span>
                            <span id="songTuning"></span>
                            <span id="songDuration"></span>
                        </div>
                    </div>
                    <button class="show-time-btn" onclick="openInShowTime()" title="Open in Show Time performance viewer">
                        <svg viewBox="0 0 24 24">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                        Show Time
                    </button>
                </div>
            </div>

            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-empty" id="emptyMessage">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14M5 12h14"/>
                    </svg>
                    <p>Drag components here to build your chord chart</p>
                    <p style="font-size: 12px; margin-top: 10px;">Components will auto-number as you add them</p>
                </div>
                <div id="componentsContainer"></div>
            </div>
        </div>

        <!-- Right Sidebar - Settings -->
        <div class="right-sidebar" id="rightSidebar">
            <button class="collapse-toggle" onclick="toggleRightPanel()" title="Toggle panel">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="15 18 9 12 15 6"/>
                </svg>
            </button>
            <div class="collapsed-label">Help & Actions</div>
            
            <div class="settings-section">
                <div class="settings-title">Chord Format Help</div>
                <div class="setting-item">
                    <p style="font-size: 12px; color: var(--text-tertiary); line-height: 1.6;">
                        <strong style="color: var(--primary-light);">Inline:</strong><br>
                        Amazing [G]grace how [C]sweet the [G]sound<br><br>
                        <strong style="color: var(--primary-light);">Separate Lines:</strong><br>
                        G&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G<br>
                        Amazing grace how sweet the sound
                    </p>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Quick Actions</div>
                <button class="btn btn-secondary" onclick="saveChart()" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Now
                </button>
                <button class="btn btn-secondary" onclick="exportChart()" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Export
                </button>
                <button class="btn btn-danger" onclick="clearChart()" style="width: 100%;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Clear Chart
                </button>
            </div>

            <div class="settings-section">
                <div class="settings-title">Tips</div>
                <p style="font-size: 11px; color: var(--text-tertiary); line-height: 1.5;">
                     Charts auto-save as you edit<br>
                     Drag components to reorder<br>
                     Numbering updates automatically<br>
                     Use brackets [C] for inline chords<br>
                     Print view formats for performance
                </p>
            </div>
        </div>
    </div>

    <!-- Print Modal -->
    <div id="printModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Performance View</h2>
                <span class="close" onclick="closePrintModal()">&times;</span>
            </div>

            <div class="modal-body">
                <div class="view-tabs">
                    <button class="tab-button active" onclick="switchViewTab('performance')">Performance View</button>
                    <button class="tab-button" onclick="switchViewTab('print')">Print Preview</button>
            </div>

            <div class="print-controls">
                    <!-- Font Size Control -->
                    <div class="setting-item" style="display: flex; align-items: center; gap: 8px;">
                        <label for="fontSize" style="margin: 0; font-size: 12px; min-width: 65px;">Font Size:</label>
                        <input type="range" id="fontSize" name="fontSize" min="10" max="20" value="14" title="Adjust font size for printing" aria-label="Font size slider" onchange="updatePrintPreview()" style="flex: 1;">
                        <span id="fontSizeValue" style="min-width: 32px; font-size: 12px;">14px</span>
                </div>
                    
                    <!-- Scale to Fit & Save Speed Row -->
                    <div style="display: flex; gap: 8px;">
                        <label for="scaleToFit" style="display: flex; align-items: center; gap: 5px; margin: 0; cursor: pointer; font-size: 12px; flex: 1;">
                        <input type="checkbox" id="scaleToFit" name="scaleToFit" title="Scale chart to fit one page" onchange="updatePrintPreview()">
                            Scale to fit
                    </label>
                        <button id="saveSpeedBtn" class="btn btn-secondary" onclick="savePreferredSpeed()" style="display: flex; align-items: center; gap: 6px; padding: 4px 10px; font-size: 12px;" title="Save current autoscroll speed for this song">
                            <svg id="saveSpeedIcon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                    </svg>
                            <span id="saveSpeedText">Save Speed</span>
                </button>
                    </div>
            </div>

                <div id="performanceView" class="performance-view">
                    <!-- Performance content will be generated here -->
                </div>

                <div id="printPreview" class="print-preview" style="display: none;">
                <!-- Print content will be generated here -->
                </div>
            </div>

            <!-- Autoscroll Controls (Centered, scrolls with content) -->
            <div class="autoscroll-controls" id="autoscrollControls">
                <!-- Slow button -->
                <button class="speed-orb" onclick="adjustSpeed(-0.1)" title="Slower ()"></button>
                
                <!-- Combined Play/Speed Display -->
                <button class="autoscroll-play-btn" id="autoscrollPlayBtn" onclick="toggleAutoscroll()" title="Play/Stop (Space)">
                    <svg viewBox="0 0 24 24">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    <span class="speed-display-text" id="speedValue">1.0x</span>
                </button>
                
                <!-- Fast button -->
                <button class="speed-orb" onclick="adjustSpeed(0.1)" title="Faster ()">+</button>
            </div>
        </div>
    </div>

    <!-- Auto-save Indicator -->
    <div class="save-indicator" id="saveIndicator"> Saved</div>

    <!-- Component Selection Modal (Mobile) -->
    <div id="componentSelectorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add Component</h2>
                <span class="close" onclick="closeComponentSelector()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="component-selector-grid">
                    <button class="component-selector-btn" onclick="selectComponentType('Intro')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        Intro
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Verse')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                        </svg>
                        Verse
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Chorus')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        Chorus
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Pre-Chorus')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                        </svg>
                        Pre-Chorus
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Bridge')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3v18h18"/>
                            <path d="M18.7 8l-5.1 5.2-2.8-2.7L7 14.3"/>
                        </svg>
                        Bridge
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Solo')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="17" r="4.5"/>
                            <line x1="12" y1="12.5" x2="12" y2="2"/>
                            <line x1="9" y1="5" x2="15" y2="5"/>
                            <line x1="9" y1="8" x2="15" y2="8"/>
                        </svg>
                        Solo
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Interlude')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        Interlude
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Outro')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                        Outro
                    </button>
                    <button class="component-selector-btn" onclick="selectComponentType('Tag/Coda')">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                        </svg>
                        Tag/Coda
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // STORAGE UTILITIES (Inline for compatibility)
        // ============================================================================
        
        const STORAGE_KEYS = {
            SONGS: 'songDatabase',
            SONGS_LEGACY: 'bandSongs',
            THEME: 'bandOrganizerTheme'
        };

        const Storage = {
            get(key, defaultValue = null) {
                try {
                    const item = localStorage.getItem(key);
                    if (item === null) return defaultValue;
                    
                    // Try to parse as JSON
                    try {
                        return JSON.parse(item);
                    } catch (parseError) {
                        // If parse fails, return the raw string (for legacy data)
                        return item;
                    }
                } catch (error) {
                    console.error(`Error reading from localStorage (${key}):`, error);
                    return defaultValue;
                }
            },
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (error) {
                    console.error(`Error writing to localStorage (${key}):`, error);
                    return false;
                }
            }
        };

        // ============================================================================
        // CHORD CHART UTILITIES
        // ============================================================================
        
        const COMPONENT_TYPES = {
            INTRO: 'Intro',
            VERSE: 'Verse',
            CHORUS: 'Chorus',
            PRE_CHORUS: 'Pre-Chorus',
            BRIDGE: 'Bridge',
            SOLO: 'Solo',
            INTERLUDE: 'Interlude',
            OUTRO: 'Outro',
            TAG: 'Tag/Coda'
        };

        const ChordChartManager = {
            parseChords(text) {
                const chords = [];
                const regex = /\[([^\]]+)\]/g;
                let match;
                
                while ((match = regex.exec(text)) !== null) {
                    chords.push({
                        chord: match[1],
                        position: match.index,
                        length: match[0].length
                    });
                }
                
                return chords;
            },

            extractLyrics(text) {
                return text.replace(/\[([^\]]+)\]/g, '');
            },

            inlineToChordLine(text) {
                const chords = this.parseChords(text);
                const lyrics = this.extractLyrics(text);
                
                if (chords.length === 0) {
                    return { chords: '', lyrics: lyrics };
                }
                
                let chordLine = '';
                let lastPos = 0;
                
                chords.forEach(chord => {
                    const lyricsPos = chord.position - (chordLine.length);
                    const spaces = Math.max(0, lyricsPos - lastPos);
                    chordLine += ' '.repeat(spaces) + chord.chord;
                    lastPos = lyricsPos + chord.chord.length;
                });
                
                return {
                    chords: chordLine,
                    lyrics: lyrics
                };
            },

            autoNumber(components) {
                const counts = {};
                
                components.forEach(comp => {
                    counts[comp.type] = (counts[comp.type] || 0) + 1;
                });
                
                const currentCounts = {};
                
                return components.map(comp => {
                    const type = comp.type;
                    const totalOfType = counts[type];
                    
                    currentCounts[type] = (currentCounts[type] || 0) + 1;
                    const number = currentCounts[type];
                    
                    const displayName = totalOfType > 1 
                        ? `${type} ${number}` 
                        : type;
                    
                    return {
                        ...comp,
                        displayName,
                        number: totalOfType > 1 ? number : null
                    };
                });
            },

            generatePrintView(chart, song, options = {}) {
                const { fontSize = 14, scaleToFit = false } = options;
                
                const scaleStyle = scaleToFit ? 'transform: scale(0.85); transform-origin: top left;' : '';
                
                let html = `
                    <div class="print-container" style="font-size: ${fontSize}px; ${scaleStyle}">
                        <div class="print-header">
                            <h1>${song.song}</h1>
                            <h2>${song.artist}</h2>
                            <div class="print-meta">
                                ${song.key ? `<span>Key: ${song.key}</span>` : ''}
                                ${song.tuning ? `<span>Tuning: ${song.tuning}</span>` : ''}
                                ${song.duration ? `<span>Duration: ${song.duration}</span>` : ''}
                            </div>
                        </div>
                        <div class="print-body">
                `;
                
                chart.components.forEach(comp => {
                    const lines = comp.lyrics.split('\n');
                    
                    // Helper to detect if a line is a chord line (contains chord-like patterns)
                    const isChordLine = (line) => {
                        const trimmed = line.trim();
                        if (!trimmed) return false;
                        
                        // Strict chord pattern: A-G followed by optional modifiers, separated by spaces
                        // Must be at least 2 characters and contain only chord-like elements
                        const chordPattern = /^[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?(\s+[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?)*$/;
                        
                        // Must NOT contain lowercase words, punctuation (except # and /) or common lyric indicators
                        const hasLyricIndicators = /[a-z]{3,}|[,;.!?'"()]/.test(trimmed);
                        
                        // Must start with a valid chord (uppercase A-G)
                        const startsWithChord = /^[A-G]/.test(trimmed);
                        
                        return startsWithChord && !hasLyricIndicators && chordPattern.test(trimmed);
                    };
                    
                    // Build content HTML
                    let contentHtml = '';
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const lineMetadata = comp.lyricsMetadata && comp.lyricsMetadata[i];
                        
                        if (!line.trim()) {
                            // Empty line - render as empty div to preserve spacing
                            contentHtml += `<div class="lyric-line">&nbsp;</div>`;
                            continue;
                        }
                        
                        // Priority 1: Use explicit metadata from grid editor
                        if (lineMetadata) {
                            if (lineMetadata.type === 'chord') {
                                contentHtml += `<div class="chord-line">${line}</div>`;
                                continue;
                            } else if (lineMetadata.type === 'lyric') {
                                contentHtml += `<div class="lyric-line">${line}</div>`;
                                continue;
                            }
                            // If type is 'generic', fall through to detection
                        }
                        
                        // Priority 2: Check for inline chord format [Chord]
                        if (line.includes('[')) {
                            const formatted = this.inlineToChordLine(line);
                            if (formatted.chords) {
                                contentHtml += `<div class="chord-line">${formatted.chords}</div>`;
                            }
                            contentHtml += `<div class="lyric-line">${formatted.lyrics}</div>`;
                            continue;
                        }
                        
                        // Priority 3: Fallback to regex detection
                        if (isChordLine(line)) {
                            contentHtml += `<div class="chord-line">${line}</div>`;
                            continue;
                        }
                        
                        // Priority 4: Default to lyric
                        contentHtml += `<div class="lyric-line">${line}</div>`;
                    }
                    
                    html += `
                        <div class="print-component">
                            <h3>${comp.displayName}</h3>
                            <div class="print-lyrics">${contentHtml}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            },

            generatePerformanceView(chart, song, options = {}) {
                const { fontSize = 14, scaleToFit = false } = options;
                
                const scaleStyle = scaleToFit ? 'transform: scale(0.85); transform-origin: top left;' : '';
                
                let html = `
                    <div class="performance-container" style="font-size: ${fontSize}px; ${scaleStyle}">
                        <div class="performance-header">
                            <h1>${song.song}</h1>
                            <h2>${song.artist}</h2>
                            <div class="performance-meta">
                                ${song.key ? `<span>Key: ${song.key}</span>` : ''}
                                ${song.tuning ? `<span>Tuning: ${song.tuning}</span>` : ''}
                                ${song.duration ? `<span>Duration: ${song.duration}</span>` : ''}
                            </div>
                        </div>
                        <div class="performance-body">
                `;
                
                chart.components.forEach(comp => {
                    const lines = comp.lyrics.split('\n');
                    
                    // Helper to detect if a line is a chord line (contains chord-like patterns)
                    const isChordLine = (line) => {
                        const trimmed = line.trim();
                        if (!trimmed) return false;
                        
                        // Strict chord pattern: A-G followed by optional modifiers, separated by spaces
                        // Must be at least 2 characters and contain only chord-like elements
                        const chordPattern = /^[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?(\s+[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?)*$/;
                        
                        // Must NOT contain lowercase words, punctuation (except # and /) or common lyric indicators
                        const hasLyricIndicators = /[a-z]{3,}|[,;.!?'"()]/.test(trimmed);
                        
                        // Must start with a valid chord (uppercase A-G)
                        const startsWithChord = /^[A-G]/.test(trimmed);
                        
                        return startsWithChord && !hasLyricIndicators && chordPattern.test(trimmed);
                    };
                    
                    // Build content HTML
                    let contentHtml = '';
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const lineMetadata = comp.lyricsMetadata && comp.lyricsMetadata[i];
                        
                        if (!line.trim()) {
                            // Empty line - render as empty div to preserve spacing
                            contentHtml += `<div class="lyric-line">&nbsp;</div>`;
                            continue;
                        }
                        
                        // Priority 1: Use explicit metadata from grid editor
                        if (lineMetadata) {
                            if (lineMetadata.type === 'chord') {
                                contentHtml += `<div class="chord-line">${line}</div>`;
                                continue;
                            } else if (lineMetadata.type === 'lyric') {
                                contentHtml += `<div class="lyric-line">${line}</div>`;
                                continue;
                            }
                            // If type is 'generic', fall through to detection
                        }
                        
                        // Priority 2: Check for inline chord format [Chord]
                            if (line.includes('[')) {
                                const formatted = this.inlineToChordLine(line);
                                if (formatted.chords) {
                                contentHtml += `<div class="chord-line">${formatted.chords}</div>`;
                                }
                            contentHtml += `<div class="lyric-line">${formatted.lyrics}</div>`;
                            continue;
                            }
                        
                        // Priority 3: Fallback to regex detection
                        if (isChordLine(line)) {
                            contentHtml += `<div class="chord-line">${line}</div>`;
                            continue;
                        }
                        
                        // Priority 4: Default to lyric
                        contentHtml += `<div class="lyric-line">${line}</div>`;
                    }
                    
                    html += `
                        <div class="performance-component">
                            <h3>${comp.displayName}</h3>
                            <div class="performance-lyrics">${contentHtml}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            },

            createComponent(type) {
                return {
                    id: Date.now() + Math.random(),
                    type: type,
                    displayName: type,
                    lyrics: '',
                    number: null
                };
            },

            createEmptyChart() {
                return {
                    components: [],
                    settings: {
                        defaultChordFormat: 'inline',
                        showChordDiagrams: false,
                        fontSize: 14
                    },
                    preferredScrollSpeed: null // Store preferred autoscroll speed for this song
                };
            }
        };

        // ============================================================================
        // MAIN APPLICATION
        // ============================================================================
        
        // Global state
        let currentSongId = null;
        let currentSong = null;
        let chartData = null;
        let autoSaveTimer = null;
        let allSongs = [];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Immediately clear the search box (before anything else)
            const searchBox = document.getElementById('songSearch');
            searchBox.value = '';
            
            // Theme will be loaded by the module script below

            // Load watermark preference
            loadWatermark();

            // Load right panel collapsed state
            loadRightPanelState();

            // Load all songs
            allSongs = Storage.get(STORAGE_KEYS.SONGS) || Storage.get(STORAGE_KEYS.SONGS_LEGACY) || [];

            // Get song ID from URL
            const params = new URLSearchParams(window.location.search);
            const songIdParam = params.get('songId');

            if (songIdParam !== null && songIdParam !== '') {
                // Load the specific song from URL parameter
                currentSongId = songIdParam;
                loadSongData();
                setupDragAndDrop();
                updateSearchBox();
            } else {
                // No song selected - show empty state
                currentSongId = null;
                currentSong = null;
                chartData = null;
                showEmptyState();
                
                // Force clear search box again after a brief delay (to override any browser autocomplete)
                setTimeout(() => {
                    searchBox.value = '';
                }, 50);
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.song-selector')) {
                    document.getElementById('songList').style.display = 'none';
                }
            });

            // Modal event listeners
            const modal = document.getElementById('componentSelectorModal');
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeComponentSelector();
                }
            });

            // Close modal on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal.classList.contains('active')) {
                    closeComponentSelector();
                }
            });

            // Mobile menu event listeners
            const mobileMenu = document.getElementById('mobileMenu');
            if (mobileMenu) {
                // Close on background click
                mobileMenu.addEventListener('click', (e) => {
                    if (e.target === mobileMenu) {
                        toggleMobileMenu();
                    }
                });
                
                // Close on escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && mobileMenu.classList.contains('active')) {
                        toggleMobileMenu();
                    }
                });
            }
        });

        // Update search box with current song
        function updateSearchBox() {
            if (currentSong) {
                document.getElementById('songSearch').value = `${currentSong.artist} - ${currentSong.song}`;
            } else {
                document.getElementById('songSearch').value = '';
            }
        }

        // Show song list dropdown
        window.showSongList = function() {
            filterSongs();
        };

        // Filter songs based on search input
        window.filterSongs = function() {
            const searchTerm = document.getElementById('songSearch').value.toLowerCase();
            const songList = document.getElementById('songList');
            
            const filteredSongs = allSongs.filter(song => {
                const searchText = `${song.artist} ${song.song}`.toLowerCase();
                return searchText.includes(searchTerm);
            });

            if (filteredSongs.length === 0) {
                songList.innerHTML = '<div style="padding: 12px; color: var(--text-secondary); text-align: center;">No songs found</div>';
                songList.style.display = 'block';
                return;
            }

            songList.innerHTML = filteredSongs.map((song, index) => {
                const actualIndex = allSongs.findIndex(s => s === song);
                return `
                    <div class="song-list-item" 
                         data-index="${actualIndex}"
                         onclick="selectSong(${actualIndex})"
                         style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid var(--primary-border); color: var(--text-primary); transition: background 0.2s;"
                         onmouseover="this.style.background='var(--primary-bg)'"
                         onmouseout="this.style.background='transparent'">
                        <div style="font-weight: 500;">${song.song}</div>
                        <div style="font-size: 0.9em; color: var(--text-secondary);">${song.artist}</div>
                    </div>
                `;
            }).join('');
            
            songList.style.display = 'block';
        };

        // Select a song from the dropdown
        window.selectSong = function(index) {
            currentSongId = index.toString();
            
            // Update URL without reloading page
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('songId', currentSongId);
            window.history.pushState({}, '', newUrl);
            
            // Hide dropdown
            document.getElementById('songList').style.display = 'none';
            
            // Load the song
            loadSongData();
            setupDragAndDrop();
            updateSearchBox();
        };

        // Load selected song from dropdown (legacy support)
        window.loadSelectedSong = function() {
            const select = document.getElementById('songSelect');
            if (!select) return;
            
            const selectedIndex = select.value;
            
            if (selectedIndex === '') {
                showEmptyState();
                return;
            }
            
            selectSong(parseInt(selectedIndex));
        };

        // Show empty state when no song is selected
        function showEmptyState() {
            currentSongId = null;
            currentSong = null;
            chartData = null;
            
            // Clear the search box
            document.getElementById('songSearch').value = '';
            
            // Recreate the drop zone with proper structure
            document.getElementById('dropZone').innerHTML = `
                <div class="drop-zone-empty" id="emptyMessage" style="display: block;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity: 0.5;">
                        <path d="M9 18V5l12-2v13"/>
                        <circle cx="6" cy="18" r="3"/>
                        <circle cx="18" cy="16" r="3"/>
                    </svg>
                    <p style="margin-top: 20px; font-size: 18px; font-weight: 500;">No Song Selected</p>
                    <p style="font-size: 14px; color: var(--text-secondary);">Please select a song from the search box above to start editing its chord chart.</p>
                </div>
                <div id="componentsContainer"></div>
            `;
            
            document.getElementById('songInfo').innerHTML = `
                <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                    Select a song to get started
                </div>
            `;
        }

        // Load and apply watermark preference
        function loadWatermark() {
            const watermark = localStorage.getItem('watermark') || 'guitar';
            
            // Remove all watermark classes
            document.body.classList.remove('drum-watermark', 'blackdoubt-watermark');
            
            // Apply appropriate class
            if (watermark === 'drum') {
                document.body.classList.add('drum-watermark');
                updateFavicon('drum');
            } else if (watermark === 'blackdoubt') {
                document.body.classList.add('blackdoubt-watermark');
                updateFavicon('blackdoubt');
            } else {
                // Guitar is default
                updateFavicon('guitar');
            }
        }
        
        // Update favicon to match watermark
        function updateFavicon(type) {
            const currentTheme = localStorage.getItem('bandOrganizerTheme') || 'grey';
            updateFaviconForThemeAndWatermark(currentTheme, type);
        }
        
        function updateFaviconForThemeAndWatermark(theme, watermarkType) {
            const link = document.querySelector("link[rel*='icon']");
            if (!link) return;
            
            // Map themes to colors (hex codes need to be URL encoded with %23)
            const themeColors = {
                'grey': '%23d84315',
                'red': '%23d84315',
                'blue': '%231976d2',
                'green': '%23388e3c',
                'purple': '%237b1fa2',
                'cyan': '%2300838f',
                'amber': '%23f57c00',
                'pink': '%23c2185b',
                'teal': '%2314b8a6',
                'copper': '%23b87333',
                'sunrise': '%23ffb700',
                'sunset': '%23ff8c00',
                'synthwave': '%23a78bfa',
                'prism': '%2314b8a6'
            };
            
            const color = themeColors[theme] || '%23d84315';
            
            // Use guitar, drum, or BlackDoubt icon based on watermark preference
            if (watermarkType === 'drum') {
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' preserveAspectRatio='xMidYMid meet'><g transform='scale(1.4) translate(-2, -2)'><circle cx='23' cy='17' r='4.5' fill='none' stroke='${color}' stroke-width='2.5'/><line x1='16' y1='21.5' x2='16' y2='2' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='11' y1='5' x2='21' y2='5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='18' y1='8' x2='28' y2='8' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='21' y1='10' x2='26' y2='10' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='7' y1='12.5' x2='18' y2='12.5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='30' y1='12.5' x2='30' y2='2' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='25' y1='5' x2='35' y2='5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='27' y1='8' x2='33' y2='8' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='26' y1='14' x2='31' y2='14' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/></g></svg>`;
            } else if (watermarkType === 'blackdoubt') {
                // BlackDoubt icon favicon
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40' fill='none' stroke='${color}' stroke-width='2' stroke-linecap='round'><path d='M 20 3 L 37 20 L 20 37 L 3 20 Z' stroke='${color}' fill='none' stroke-width='2'/><circle cx='20' cy='20' r='13' stroke='${color}' fill='none' stroke-width='2'/><text x='20' y='20' font-size='20' font-family='serif' text-anchor='middle' dominant-baseline='central' fill='${color}' stroke='none'></text></svg>`;
            } else {
                // Guitar icon
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='${color}' stroke-width='2.5' stroke-linecap='round'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>`;
            }
        }

        // Toggle right panel collapsed state
        function toggleRightPanel() {
            const rightSidebar = document.getElementById('rightSidebar');
            const isCollapsed = rightSidebar.classList.toggle('collapsed');
            
            // Update toggle button icon
            const toggleBtn = rightSidebar.querySelector('.collapse-toggle svg');
            if (isCollapsed) {
                toggleBtn.innerHTML = '<polyline points="9 18 15 12 9 6"/>';
            } else {
                toggleBtn.innerHTML = '<polyline points="15 18 9 12 15 6"/>';
            }
            
            // Save state to localStorage
            localStorage.setItem('rightPanelCollapsed', isCollapsed);
        }

        // Load right panel state from localStorage
        function loadRightPanelState() {
            const isCollapsed = localStorage.getItem('rightPanelCollapsed') === 'true';
            const rightSidebar = document.getElementById('rightSidebar');
            
            if (isCollapsed) {
                rightSidebar.classList.add('collapsed');
                const toggleBtn = rightSidebar.querySelector('.collapse-toggle svg');
                toggleBtn.innerHTML = '<polyline points="9 18 15 12 9 6"/>';
            }
        }

        // Make toggleRightPanel available globally
        window.toggleRightPanel = toggleRightPanel;

        // Load song data
        function loadSongData() {
            if (currentSongId === null || currentSongId === '') {
                showEmptyState();
                return;
            }

            const songs = Storage.get(STORAGE_KEYS.SONGS) || Storage.get(STORAGE_KEYS.SONGS_LEGACY) || [];
            const songIndex = parseInt(currentSongId);

            if (isNaN(songIndex) || songIndex < 0 || songIndex >= songs.length) {
                alert('Song not found.');
                showEmptyState();
                return;
            }

            currentSong = songs[songIndex];

            // Recreate song info structure (in case showEmptyState destroyed it)
            document.getElementById('songInfo').innerHTML = `
                <div class="song-info-header">
                    <div class="song-info-title">
                        <h2 id="songTitle">${currentSong.song}</h2>
                        <div class="artist" id="songArtist">${currentSong.artist}</div>
                        <div class="meta">
                            <span id="songKey">${currentSong.key ? `Key: ${currentSong.key}` : ''}</span>
                            <span id="songTuning">${currentSong.tuning ? `Tuning: ${currentSong.tuning}` : ''}</span>
                            <span id="songDuration">${currentSong.duration ? `Duration: ${currentSong.duration}` : ''}</span>
                        </div>
                    </div>
                    <button class="show-time-btn" onclick="openInShowTime()" title="Open in Show Time performance viewer">
                        <svg viewBox="0 0 24 24">
                            <polygon points="5 3 19 12 5 21 5 3"/>
                        </svg>
                        Show Time
                    </button>
                </div>
            `;

            // Load or create chart
            if (currentSong.chordChart) {
                chartData = currentSong.chordChart;
            } else {
                chartData = ChordChartManager.createEmptyChart();
            }

            renderComponents();
        }

        // Setup drag and drop
        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const componentItems = document.querySelectorAll('.component-item');

            // Palette items
            componentItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('componentType', item.dataset.type);
                    e.dataTransfer.effectAllowed = 'copy';
                });
            });

            // Drop zone
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');

                const componentType = e.dataTransfer.getData('componentType');
                if (componentType) {
                    addComponent(componentType);
                }
            });
        }

        // Add component
        function addComponent(type) {
            const newComponent = ChordChartManager.createComponent(type);
            chartData.components.push(newComponent);
            renderComponents();
            scheduleAutoSave();
        }

        // Render components
        function renderComponents() {
            const container = document.getElementById('componentsContainer');
            const emptyMessage = document.getElementById('emptyMessage');

            if (chartData.components.length === 0) {
                emptyMessage.style.display = 'block';
                container.innerHTML = '';
                // Add mobile button even when empty
                addMobileAddButton(container);
                return;
            }

            emptyMessage.style.display = 'none';

            // Auto-number components
            const numberedComponents = ChordChartManager.autoNumber(chartData.components);
            chartData.components = numberedComponents;

            container.innerHTML = '';

            numberedComponents.forEach((comp, index) => {
                const tile = createComponentTile(comp, index);
                container.appendChild(tile);
            });

            // Add mobile "Add Component" button at the end
            addMobileAddButton(container);
        }

        // Add mobile "Add Component" button
        function addMobileAddButton(container) {
            const addBtn = document.createElement('button');
            addBtn.className = 'mobile-add-component-btn';
            addBtn.onclick = openComponentSelector;
            addBtn.innerHTML = `
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12h14"/>
                </svg>
                Add Component
            `;
            container.appendChild(addBtn);
        }

        // Open component selector modal
        function openComponentSelector() {
            document.getElementById('componentSelectorModal').classList.add('active');
        }

        // Close component selector modal
        function closeComponentSelector() {
            document.getElementById('componentSelectorModal').classList.remove('active');
        }

        // Select component type and add it
        function selectComponentType(type) {
            addComponent(type);
            closeComponentSelector();
        }

        // Toggle mobile menu
        function toggleMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            if (menu) {
                menu.classList.toggle('active');
                // Prevent body scroll when menu is open
                if (menu.classList.contains('active')) {
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.overflow = '';
                }
            }
        }

        // Create component tile
        function createComponentTile(comp, index) {
            const tile = document.createElement('div');
            tile.className = 'component-tile';
            tile.dataset.index = index;

            tile.innerHTML = `
                <div class="component-header">
                    <div class="drag-handle" title="Drag to reorder">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="6" x2="21" y2="6"/>
                            <line x1="3" y1="12" x2="21" y2="12"/>
                            <line x1="3" y1="18" x2="21" y2="18"/>
                        </svg>
                    </div>
                    <div class="component-title">${comp.displayName}</div>
                    <div class="component-actions">
                        <button class="icon-btn" onclick="toggleGridEditor(${index})" title="Toggle Grid Editor">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"/>
                                <rect x="14" y="3" width="7" height="7"/>
                                <rect x="3" y="14" width="7" height="7"/>
                                <rect x="14" y="14" width="7" height="7"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="moveComponentUp(${index})" title="Move Up">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="18 15 12 9 6 15"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="moveComponentDown(${index})" title="Move Down">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="deleteComponent(${index})" title="Delete">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="component-editor">
                <textarea 
                    class="component-textarea" 
                    placeholder="Enter lyrics here. Use [C], [G], [Em] for inline chords or write chords on separate line above lyrics."
                    oninput="updateComponentLyrics(${index}, this.value)"
                >${comp.lyrics}</textarea>
                    <div class="grid-editor" style="display: none;" data-index="${index}">
                        <!-- Grid editor will be populated dynamically -->
                    </div>
                </div>
                <div class="chord-format-hint">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; cursor: help;" title="Grid mode exports as chords above lyrics (or use inline [G] format)">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="16" x2="12" y2="12"/>
                        <line x1="12" y1="8" x2="12.01" y2="8"/>
                    </svg>
                </div>
            `;

            // Get the drag handle element
            const dragHandle = tile.querySelector('.drag-handle');
            
            // Only allow dragging from the drag handle
            dragHandle.addEventListener('mousedown', () => {
                tile.draggable = true;
            });
            
            tile.addEventListener('mouseup', () => {
                tile.draggable = false;
            });

            // Drag and drop for reordering
            tile.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('moveIndex', index);
                tile.classList.add('dragging');
            });

            tile.addEventListener('dragend', () => {
                tile.classList.remove('dragging');
                tile.draggable = false;
            });

            tile.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            tile.addEventListener('drop', (e) => {
                e.preventDefault();
                const moveFromIndex = parseInt(e.dataTransfer.getData('moveIndex'));
                const moveToIndex = parseInt(tile.dataset.index);

                if (moveFromIndex !== moveToIndex) {
                    moveComponent(moveFromIndex, moveToIndex);
                }
            });

            return tile;
        }

        // Update component lyrics
        window.updateComponentLyrics = function(index, lyrics) {
            chartData.components[index].lyrics = lyrics;
            scheduleAutoSave();
        };

        // Move component up
        window.moveComponentUp = function(index) {
            if (index > 0) {
                moveComponent(index, index - 1);
            }
        };

        // Move component down
        window.moveComponentDown = function(index) {
            if (index < chartData.components.length - 1) {
                moveComponent(index, index + 1);
            }
        };

        // Move component
        function moveComponent(fromIndex, toIndex) {
            const [moved] = chartData.components.splice(fromIndex, 1);
            chartData.components.splice(toIndex, 0, moved);
            renderComponents();
            scheduleAutoSave();
        }

        // Delete component
        window.deleteComponent = function(index) {
            if (confirm('Delete this component?')) {
                chartData.components.splice(index, 1);
                renderComponents();
                scheduleAutoSave();
            }
        };

        // ============================================================================
        // GRID CHORD EDITOR
        // ============================================================================

        // Toggle between text editor and grid editor
        window.toggleGridEditor = function(index) {
            const tile = document.querySelector(`.component-tile[data-index="${index}"]`);
            const textarea = tile.querySelector('.component-textarea');
            const gridEditor = tile.querySelector('.grid-editor');
            const comp = chartData.components[index];
            
            if (gridEditor.style.display === 'none') {
                // Save current textarea content to comp.lyrics before building grid
                comp.lyrics = textarea.value;
                
                // Show grid editor, hide textarea
                textarea.style.display = 'none';
                gridEditor.style.display = 'block';
                
                // Build grid from current lyrics
                buildGridFromLyrics(index);
            } else {
                // Show textarea, hide grid editor
                gridEditor.style.display = 'none';
                textarea.style.display = 'block';
                
                // Update lyrics from grid
                updateLyricsFromGrid(index);
            }
        };

        // Parse lyrics text into lines and characters (handles both inline and chords-above format)
        function parseLyricsToCharacters(lyrics) {
            const lines = lyrics.split('\n');
            const lyricLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // Check if this is a chord-only line
                const isChordLine = trimmedLine.length > 0 && 
                                   /^[A-G#b\/m0-9\s\-+dim aug sus maj min]+$/i.test(trimmedLine) &&
                                   trimmedLine.match(/[A-G]/);
                
                if (isChordLine && i + 1 < lines.length) {
                    // Skip chord line, process the lyrics line below
                    i++;
                    lyricLines.push(lines[i].split(''));
                } else if (line.includes('[')) {
                    // Inline format - remove chords
                    const cleanLine = line.replace(/\[([^\]]+)\]/g, '');
                    lyricLines.push(cleanLine.split(''));
                } else if (trimmedLine.length > 0) {
                    // Regular lyric line
                    lyricLines.push(line.split(''));
                } else {
                    // Empty line
                    lyricLines.push([]);
                }
            }
            
            return lyricLines;
        }

        // Parse existing chords from lyrics (supports both inline [G] and chords-above format)
        function parseExistingChords(lyrics) {
            const lines = lyrics.split('\n');
            const chordMap = []; // Array of arrays: chordMap[lyricLineIndex][charIndex] = chord
            let currentLyricLine = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // Check if this is a chord-only line (contains only chords, spaces, and common chord characters)
                const isChordLine = trimmedLine.length > 0 && 
                                   /^[A-G#b\/m0-9\s\-+dim aug sus maj min]+$/i.test(trimmedLine) &&
                                   trimmedLine.match(/[A-G]/); // Must have at least one note letter
                
                if (isChordLine && i + 1 < lines.length) {
                    // This is a chord line, next line should be lyrics
                    const nextLine = lines[i + 1];
                    chordMap[currentLyricLine] = [];
                    
                    // Map chord positions to character positions - USE ORIGINAL LINE, NOT TRIMMED!
                    const chordPattern = /[A-G][#b]?(?:maj|min|m|dim|aug|sus)?[0-9]?(?:\/[A-G][#b]?)?/g;
                    let match;
                    
                    while ((match = chordPattern.exec(line)) !== null) {
                        const chord = match[0];
                        const chordPos = match.index;
                        chordMap[currentLyricLine][chordPos] = chord;
                    }
                    
                    i++; // Skip the lyrics line since we've paired it
                    currentLyricLine++;
                } else if (line.includes('[')) {
                    // Inline chord format [G]lyrics
                    chordMap[currentLyricLine] = [];
                    let charIndex = 0;
                    let j = 0;
                    
                    while (j < line.length) {
                        if (line[j] === '[') {
                            const endIndex = line.indexOf(']', j);
                            if (endIndex !== -1) {
                                const chord = line.substring(j + 1, endIndex);
                                chordMap[currentLyricLine][charIndex] = chord;
                                j = endIndex + 1;
                            } else {
                                j++;
                            }
                        } else {
                            charIndex++;
                            j++;
                        }
                    }
                    currentLyricLine++;
                } else if (trimmedLine.length > 0) {
                    // Regular lyric line with no chords
                    chordMap[currentLyricLine] = [];
                    currentLyricLine++;
                }
            }
            
            return chordMap;
        }

        // ============================================================================
        // GRID EDITOR - REDESIGNED FOR SIMPLICITY AND RELIABILITY
        // ============================================================================
        
        /*
         * CORE CONCEPT:
         * - Grid is a 2D array of characters (rows x columns)
         * - Each row has a type: 'chord', 'lyric', or 'generic'
         * - Character positions are preserved exactly for perfect alignment
         * - Bidirectional sync: text  grid  performance view
         */
        
        // Initialize grid from lyrics text
        function initializeGrid(compIndex) {
            const comp = chartData.components[compIndex];
            const lines = comp.lyrics.split('\n');
            
            // Create or update grid structure
            if (!comp.gridRows || comp.gridRows.length === 0) {
                comp.gridRows = lines.map(line => ({
                    type: 'generic',
                    chars: line.split('')
                }));
            } else {
                // Sync existing grid with current text
                lines.forEach((line, i) => {
                    if (!comp.gridRows[i]) {
                        comp.gridRows[i] = { type: 'generic', chars: [] };
                    }
                    comp.gridRows[i].chars = line.split('');
                });
                // Remove extra rows if text is shorter
                comp.gridRows = comp.gridRows.slice(0, lines.length);
            }
            
            // Ensure at least one row exists
            if (comp.gridRows.length === 0) {
                comp.gridRows = [{ type: 'generic', chars: [] }];
            }
        }
        
        // Build grid editor UI - Simple character-by-character system
        function buildGridFromLyrics(index) {
            console.log(`buildGridFromLyrics called for component ${index}`);
            
            const comp = chartData.components[index];
            const gridEditor = document.querySelector(`.grid-editor[data-index="${index}"]`);
            if (!gridEditor) {
                console.error(`Grid editor element not found for index ${index}`);
                return;
            }
            
            console.log(`Found grid editor element:`, gridEditor);
            
            // OPTIMIZATION: Reset handler flag when rebuilding
            gridEditor._handlersInitialized = false;
            
            // Initialize grid structure
            initializeGrid(index);
            
            console.log(`Grid initialized with ${comp.gridRows.length} rows`);
            
            // Calculate grid dimensions
            const maxChars = Math.max(...comp.gridRows.map(r => r.chars.length), 20) + 15;
            
            console.log(`Max chars per row: ${maxChars}`);
            
            // Build controls HTML
            let html = `
                <div class="grid-controls">
                    <button class="btn btn-secondary btn-sm" onclick="addGridRow(${index})" title="Add Row">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        <span class="btn-text">Add</span>
                    </button>
                    <button class="btn btn-secondary btn-sm" id="setChordBtn${index}" onclick="setSelectedRowsType(${index}, 'chord')" disabled title="Mark as Chord Row">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 18V5l12-2v13"></path>
                            <circle cx="6" cy="18" r="3"></circle>
                            <circle cx="18" cy="16" r="3"></circle>
                        </svg>
                        <span class="btn-text">Chord</span>
                    </button>
                    <button class="btn btn-secondary btn-sm" id="setLyricBtn${index}" onclick="setSelectedRowsType(${index}, 'lyric')" disabled title="Mark as Lyric Row">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M4 7V4h16v3M9 20h6M12 4v16"></path>
                        </svg>
                        <span class="btn-text">Lyric</span>
                    </button>
                    <button class="btn btn-secondary btn-sm" id="setGenericBtn${index}" onclick="setSelectedRowsType(${index}, 'generic')" disabled title="Mark as Generic">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        <span class="btn-text">-</span>
                    </button>
                    <button class="btn btn-danger btn-sm" id="deleteRowBtn${index}" onclick="deleteSelectedRows(${index})" disabled title="Delete Selected Rows">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                        <span class="btn-text">Delete</span>
                    </button>
                </div>
                <table class="grid-editor-table">
            `;
            
            // Build grid rows
            comp.gridRows.forEach((row, rowIndex) => {
                const rowType = row.type || 'generic';
                const isSelected = row.selected || false;
                const rowClass = isSelected ? 'grid-row-selected' : '';
                
                // Row type indicator
                let indicator = '';
                if (rowType === 'chord') indicator = 'C';
                if (rowType === 'lyric') indicator = 'L';
                
                html += `<tr class="${rowClass}">`;
                
                // Indicator cell (clickable for selection)
                html += `
                    <td class="grid-indicator-cell" onclick="toggleRowSelection(${index}, ${rowIndex})">
                        <div class="row-indicator row-indicator-${rowType}">${indicator}</div>
                    </td>
                `;
                
                // Character cells
                for (let charIndex = 0; charIndex < maxChars; charIndex++) {
                    const char = row.chars[charIndex] || '';
                    const escapedChar = char.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    const displayChar = char || '';
                    
                    // Lyric rows limit to 1 character per cell
                    const maxLengthAttr = rowType === 'lyric' ? 'maxlength="1"' : '';
                    
                    html += `
                        <td class="grid-content-cell">
                            <input type="text" 
                                   class="grid-cell-input grid-${rowType}-input" 
                                   value="${escapedChar}"
                                   data-comp="${index}"
                                   data-row="${rowIndex}"
                                   data-char="${charIndex}"
                                   ${maxLengthAttr}
                                   placeholder="">
                        </td>
                    `;
                }
                
                html += '</tr>';
            });
            
            html += '</table>';
            
            // Render grid
            gridEditor.innerHTML = html;
            
            console.log(`Grid HTML rendered`);
            
            // Setup event handlers
            setupGridInputHandlers(index);
            updateControlButtonStates(index);
        }

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Setup input event handlers - WITH MULTI-CELL SELECTION (OPTIMIZED)
        function setupGridInputHandlers(compIndex) {
            const gridEditor = document.querySelector(`.grid-editor[data-index="${compIndex}"]`);
            if (!gridEditor) {
                console.error('Grid editor not found for component:', compIndex);
                return;
            }
            
            // OPTIMIZATION: Prevent duplicate setup
            if (gridEditor._handlersInitialized) {
                console.log('Grid handlers already initialized for component', compIndex);
                return;
            }
            gridEditor._handlersInitialized = true;
            
            const allInputs = gridEditor.querySelectorAll('.grid-cell-input');
            console.log(`Setting up ${allInputs.length} grid inputs for component ${compIndex}`);
            
            // Selection state
            let isMouseDown = false;
            let selectionStart = null;
            let selectedCells = new Set();
            
            // OPTIMIZATION: Cache cell lookups
            const cellCache = new Map();
            allInputs.forEach(input => {
                const key = `${input.dataset.row},${input.dataset.char}`;
                cellCache.set(key, input.parentElement);
            });
            
            // Clear selection function
            function clearSelection() {
                selectedCells.clear();
                cellCache.forEach(cell => {
                    cell.classList.remove('selected');
                });
            }
            
            // OPTIMIZATION: Update visual selection only for changed cells
            function updateSelection() {
                cellCache.forEach((cell, key) => {
                    const shouldBeSelected = selectedCells.has(key);
                    const isSelected = cell.classList.contains('selected');
                    if (shouldBeSelected !== isSelected) {
                        cell.classList.toggle('selected', shouldBeSelected);
                    }
                });
            }
            
            // Get selection range
            function selectRange(startRow, startChar, endRow, endChar) {
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                const minChar = Math.min(startChar, endChar);
                const maxChar = Math.max(startChar, endChar);
                
                selectedCells.clear();
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minChar; c <= maxChar; c++) {
                        selectedCells.add(`${r},${c}`);
                    }
                }
                updateSelection();
            }
            
            // OPTIMIZATION: Debounced sync to avoid excessive updates
            const debouncedSync = debounce(() => {
                syncGridToText(compIndex);
            }, 150);
            
            // OPTIMIZATION: Use event delegation on the grid editor instead of individual handlers
            gridEditor.addEventListener('mousedown', function(e) {
                const input = e.target.closest('.grid-cell-input');
                if (!input) return;
                
                const row = parseInt(input.dataset.row);
                const charIdx = parseInt(input.dataset.char);
                
                if (e.ctrlKey || e.metaKey) {
                    // Ctrl+Click: toggle individual cell
                    const key = `${row},${charIdx}`;
                    if (selectedCells.has(key)) {
                        selectedCells.delete(key);
                    } else {
                        selectedCells.add(key);
                    }
                    updateSelection();
                } else if (e.shiftKey && selectionStart) {
                    // Shift+Click: select range
                    selectRange(selectionStart.row, selectionStart.char, row, charIdx);
                } else {
                    // Normal click: start new selection
                    isMouseDown = true;
                    selectionStart = { row, char: charIdx };
                    clearSelection();
                    selectedCells.add(`${row},${charIdx}`);
                    updateSelection();
                }
            });
            
            gridEditor.addEventListener('mouseenter', function(e) {
                if (!isMouseDown || !selectionStart) return;
                const input = e.target.closest('.grid-cell-input');
                if (!input) return;
                
                const row = parseInt(input.dataset.row);
                const charIdx = parseInt(input.dataset.char);
                selectRange(selectionStart.row, selectionStart.char, row, charIdx);
            }, true); // Use capture for better performance
            
            // Mouse movement for drag selection
            gridEditor.addEventListener('mousemove', function(e) {
                if (!isMouseDown || !selectionStart) return;
                const input = e.target.closest('.grid-cell-input');
                if (!input) return;
                
                const row = parseInt(input.dataset.row);
                const charIdx = parseInt(input.dataset.char);
                selectRange(selectionStart.row, selectionStart.char, row, charIdx);
            });
            
            // Mouse up handler for this specific grid
            gridEditor.addEventListener('mouseup', function() {
                isMouseDown = false;
            });
            
            // Also clear on mouse leave to prevent sticky selections
            gridEditor.addEventListener('mouseleave', function() {
                isMouseDown = false;
            });
            
            // Global mouseup as backup (in case mouse is released outside grid)
            const globalMouseUpHandler = function() {
                isMouseDown = false;
            };
            document.addEventListener('mouseup', globalMouseUpHandler);
            
            // Store handler reference for cleanup
            gridEditor._globalMouseUpHandler = globalMouseUpHandler;
            
            // Use event delegation for input events
            gridEditor.addEventListener('input', function(e) {
                const input = e.target.closest('.grid-cell-input');
                if (!input) return;
                
                const row = parseInt(input.dataset.row);
                const charIdx = parseInt(input.dataset.char);
                const comp = chartData.components[compIndex];
                
                // Update grid data
                if (!comp.gridRows[row]) return;
                if (!comp.gridRows[row].chars) comp.gridRows[row].chars = [];
                
                comp.gridRows[row].chars[charIdx] = input.value || '';
                
                // OPTIMIZATION: Use debounced sync
                debouncedSync();
            });
            
            // Use event delegation for keydown events
            gridEditor.addEventListener('keydown', function(e) {
                const input = e.target.closest('.grid-cell-input');
                if (!input) return;
                
                const row = parseInt(input.dataset.row);
                const charIdx = parseInt(input.dataset.char);
                let targetInput = null;
                
                // Copy (Ctrl+C)
                if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                    e.preventDefault();
                    copySelectedCells(compIndex, gridEditor, selectedCells);
                    return;
                }
                
                // Cut (Ctrl+X)
                if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
                    e.preventDefault();
                    cutSelectedCells(compIndex, gridEditor, selectedCells);
                    return;
                }
                
                // Select All (Ctrl+A)
                if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                    e.preventDefault();
                    selectAllCells(compIndex, gridEditor, selectedCells, selectRange);
                    return;
                }
                
                // Delete selected cells
                if (e.key === 'Delete' && selectedCells.size > 0) {
                    e.preventDefault();
                    deleteSelectedCells(compIndex, selectedCells);
                    return;
                }
                
                // Navigation
                switch(e.key) {
                    case 'ArrowRight':
                        e.preventDefault();
                        targetInput = gridEditor.querySelector(
                            `input[data-row="${row}"][data-char="${charIdx + 1}"]`
                        );
                        break;
                        
                    case 'ArrowLeft':
                        e.preventDefault();
                        targetInput = gridEditor.querySelector(
                            `input[data-row="${row}"][data-char="${charIdx - 1}"]`
                        );
                        break;
                        
                    case 'ArrowDown':
                        e.preventDefault();
                        targetInput = gridEditor.querySelector(
                            `input[data-row="${row + 1}"][data-char="${charIdx}"]`
                        );
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        targetInput = gridEditor.querySelector(
                            `input[data-row="${row - 1}"][data-char="${charIdx}"]`
                        );
                        break;
                        
                    case 'Tab':
                        e.preventDefault();
                        const nextChar = gridEditor.querySelector(
                            `input[data-row="${row}"][data-char="${charIdx + 1}"]`
                        );
                        targetInput = nextChar || gridEditor.querySelector(
                            `input[data-row="${row + 1}"][data-char="0"]`
                        );
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        targetInput = gridEditor.querySelector(
                            `input[data-row="${row + 1}"][data-char="${charIdx}"]`
                        );
                        break;
                }
                
                if (targetInput) {
                    targetInput.focus();
                    targetInput.select();
                }
            });
            
            // Use event delegation for paste
            gridEditor.addEventListener('paste', function(e) {
                const input = e.target.closest('.grid-cell-input');
                if (!input) return;
                
                e.preventDefault();
                const text = e.clipboardData.getData('text/plain');
                const row = parseInt(input.dataset.row);
                const charIdx = parseInt(input.dataset.char);
                
                pasteIntoGrid(compIndex, row, charIdx, text);
            });
            
            // Store selection state on the grid editor for access by copy/paste functions
            gridEditor._selectionState = {
                selectedCells,
                clearSelection,
                updateSelection,
                selectRange
            };
        }

        // Paste multi-line text into grid
        function pasteIntoGrid(compIndex, startRow, startChar, text) {
            console.log('Pasting into grid:', { compIndex, startRow, startChar, text });
            const comp = chartData.components[compIndex];
            const gridEditor = document.querySelector(`.grid-editor[data-index="${compIndex}"]`);
            const lines = text.split(/\r?\n/);
            
            lines.forEach((line, lineOffset) => {
                const targetRow = startRow + lineOffset;
                
                // Ensure row exists
                while (targetRow >= comp.gridRows.length) {
                    comp.gridRows.push({ type: 'generic', chars: [] });
                }
                
                // Ensure chars array exists
                if (!comp.gridRows[targetRow].chars) {
                    comp.gridRows[targetRow].chars = [];
                }
                
                // Insert characters starting at startChar
                const chars = line.split('');
                chars.forEach((char, charOffset) => {
                    const targetChar = startChar + charOffset;
                    comp.gridRows[targetRow].chars[targetChar] = char;
                    
                    // Update the input value directly
                    const input = gridEditor.querySelector(`input[data-row="${targetRow}"][data-char="${targetChar}"]`);
                    if (input) {
                        input.value = char;
                    }
                });
            });
            
            // If we added new rows, rebuild. Otherwise just sync
            if (lines.length > 1 && (startRow + lines.length) > comp.gridRows.length) {
                buildGridFromLyrics(compIndex);
            } else {
                syncGridToText(compIndex);
            }
            
            console.log('Paste complete');
        }
        
        // Sync grid data back to text format (preserving exact character positions)
        function syncGridToText(compIndex) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows) return;
            
            const lines = comp.gridRows.map(row => {
                if (!row.chars || row.chars.length === 0) return '';
                
                // Find the last non-empty character position
                let lastNonEmpty = -1;
                for (let i = row.chars.length - 1; i >= 0; i--) {
                    if (row.chars[i] && row.chars[i].trim() !== '') {
                        lastNonEmpty = i;
                        break;
                    }
                }
                
                // If row is completely empty
                if (lastNonEmpty === -1) return '';
                
                // Build line with spaces for empty positions up to last non-empty char
                let line = '';
                for (let i = 0; i <= lastNonEmpty; i++) {
                    line += (row.chars[i] || ' ');
                }
                
                return line;
            });
            
            // Update component lyrics
            comp.lyrics = lines.join('\n');
            
            // Update textarea
            const textarea = document.querySelector(`.component-tile[data-index="${compIndex}"] .component-textarea`);
            if (textarea) {
                textarea.value = comp.lyrics;
            }
            
            scheduleAutoSave();
        }

        // Get selected grid cells (for copy)
        function getGridSelection(gridEditor) {
            // Simple selection - just return focused cell
            const focusedInput = gridEditor.querySelector('.grid-cell-input:focus');
            if (!focusedInput) return [];
            
            return [{
                row: parseInt(focusedInput.dataset.row),
                char: parseInt(focusedInput.dataset.char),
                value: focusedInput.value
            }];
        }

        // Copy selected cells to clipboard
        function copySelectedCells(compIndex, gridEditor, selectedCells) {
            if (selectedCells.size === 0) {
                console.log('No cells selected for copy');
                return;
            }
            
            console.log('Copying cells:', selectedCells);
            const comp = chartData.components[compIndex];
            const cellArray = Array.from(selectedCells).map(key => {
                const [row, char] = key.split(',').map(Number);
                return { row, char, value: comp.gridRows[row]?.chars[char] || '' };
            });
            
            // Group by rows
            const rows = {};
            cellArray.forEach(cell => {
                if (!rows[cell.row]) rows[cell.row] = {};
                rows[cell.row][cell.char] = cell.value;
            });
            
            // Build clipboard text
            const minRow = Math.min(...cellArray.map(c => c.row));
            const maxRow = Math.max(...cellArray.map(c => c.row));
            const minChar = Math.min(...cellArray.map(c => c.char));
            const maxChar = Math.max(...cellArray.map(c => c.char));
            
            let clipboardText = '';
            for (let r = minRow; r <= maxRow; r++) {
                let line = '';
                for (let c = minChar; c <= maxChar; c++) {
                    line += (rows[r] && rows[r][c]) || '';
                }
                clipboardText += line + '\n';
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(clipboardText.trimEnd()).then(() => {
                console.log(' Copied to clipboard:', clipboardText);
            }).catch(err => {
                console.error(' Failed to copy:', err);
            });
        }

        // Cut selected cells (copy then delete)
        function cutSelectedCells(compIndex, gridEditor, selectedCells) {
            if (selectedCells.size === 0) {
                console.log('No cells selected for cut');
                return;
            }
            
            console.log('Cutting cells:', selectedCells);
            
            // First copy
            copySelectedCells(compIndex, gridEditor, selectedCells);
            
            // Then delete (with a small delay to ensure clipboard operation completes)
            setTimeout(() => {
                deleteSelectedCells(compIndex, selectedCells);
            }, 50);
        }

        // Delete selected cells content
        function deleteSelectedCells(compIndex, selectedCells) {
            if (selectedCells.size === 0) return;
            
            console.log('Deleting selected cells:', selectedCells);
            const comp = chartData.components[compIndex];
            const gridEditor = document.querySelector(`.grid-editor[data-index="${compIndex}"]`);
            
            selectedCells.forEach(key => {
                const [row, char] = key.split(',').map(Number);
                if (comp.gridRows[row] && comp.gridRows[row].chars) {
                    comp.gridRows[row].chars[char] = '';
                    
                    // Update the input value directly without rebuilding
                    const input = gridEditor.querySelector(`input[data-row="${row}"][data-char="${char}"]`);
                    if (input) {
                        input.value = '';
                    }
                }
            });
            
            // Sync to text (no rebuild needed)
            syncGridToText(compIndex);
        }

        // Select all cells in the grid
        function selectAllCells(compIndex, gridEditor, selectedCells, selectRange) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows || comp.gridRows.length === 0) return;
            
            const maxChars = Math.max(...comp.gridRows.map(row => row.chars?.length || 0));
            selectRange(0, 0, comp.gridRows.length - 1, maxChars - 1);
        }

        // Row selection toggle
        window.toggleRowSelection = function(compIndex, rowIndex) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows[rowIndex]) return;
            
            comp.gridRows[rowIndex].selected = !comp.gridRows[rowIndex].selected;
            buildGridFromLyrics(compIndex);
        };

        // Set selected rows to a specific type
        window.setSelectedRowsType = function(compIndex, type) {
            const comp = chartData.components[compIndex];
            let hasSelection = false;
            
            comp.gridRows.forEach(row => {
                if (row.selected) {
                    row.type = type;
                    hasSelection = true;
                }
            });
            
            if (hasSelection) {
                buildGridFromLyrics(compIndex);
                syncGridToText(compIndex);
            }
        };

        // Delete selected rows
        window.deleteSelectedRows = function(compIndex) {
            const comp = chartData.components[compIndex];
            const selectedCount = comp.gridRows.filter(r => r.selected).length;
            
            if (selectedCount === 0) return;
            
            if (comp.gridRows.length <= selectedCount) {
                alert('Cannot delete all rows. At least one row must remain.');
                return;
            }
            
            // Remove selected rows
            comp.gridRows = comp.gridRows.filter(row => !row.selected);
            
            buildGridFromLyrics(compIndex);
            syncGridToText(compIndex);
        };

        // Add new row
        window.addGridRow = function(compIndex) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows) comp.gridRows = [];
            
            comp.gridRows.push({
                type: 'generic',
                chars: [],
                selected: false
            });
            
            buildGridFromLyrics(compIndex);
        };

        // Update control button states based on selection
        window.updateControlButtonStates = function(compIndex) {
            const comp = chartData.components[compIndex];
            if (!comp || !comp.gridRows) return;
            
            const hasSelection = comp.gridRows.some(row => row.selected);
            
            const chordBtn = document.getElementById(`setChordBtn${compIndex}`);
            const lyricBtn = document.getElementById(`setLyricBtn${compIndex}`);
            const genericBtn = document.getElementById(`setGenericBtn${compIndex}`);
            const deleteBtn = document.getElementById(`deleteRowBtn${compIndex}`);
            
            if (chordBtn) chordBtn.disabled = !hasSelection;
            if (lyricBtn) lyricBtn.disabled = !hasSelection;
            if (genericBtn) genericBtn.disabled = !hasSelection;
            if (deleteBtn) deleteBtn.disabled = !hasSelection;
        };

        // Legacy functions (redirects)
        
        // Legacy function compatibility (if needed by old code)
        window.updateLyricsFromGrid = function(index) {
            syncGridToText(index);
        };
        
        // ============================================================================
        // END OF GRID EDITOR
        // ============================================================================

        // Clear chart
        window.clearChart = function() {
            if (confirm('Clear entire chart? This cannot be undone.')) {
                chartData = ChordChartManager.createEmptyChart();
                renderComponents();
                saveChart();
            }
        };

        // Schedule auto-save
        function scheduleAutoSave() {
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }
            autoSaveTimer = setTimeout(() => {
                saveChart();
            }, 2000); // Auto-save after 2 seconds of inactivity
        }

        // Save chart
        window.saveChart = function() {
            const songs = Storage.get(STORAGE_KEYS.SONGS) || Storage.get(STORAGE_KEYS.SONGS_LEGACY) || [];
            const songIndex = parseInt(currentSongId);

            if (songIndex >= 0 && songIndex < songs.length) {
                songs[songIndex].chordChart = chartData;
                Storage.set(STORAGE_KEYS.SONGS, songs);
                Storage.set(STORAGE_KEYS.SONGS_LEGACY, songs); // Backup

                // Show save indicator
                const indicator = document.getElementById('saveIndicator');
                indicator.classList.add('show');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }
        };

        // Export chart
        window.exportChart = function() {
            const exportData = {
                song: currentSong.song,
                artist: currentSong.artist,
                key: currentSong.key,
                tuning: currentSong.tuning,
                chart: chartData
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${currentSong.artist} - ${currentSong.song} - Chord Chart.json`;
            link.click();
            URL.revokeObjectURL(url);
        };

        // Open print modal
        // Toggle print modal (open/close)
        window.togglePrintModal = function() {
            const modal = document.getElementById('printModal');
            if (modal.classList.contains('show')) {
                closePrintModal();
            } else {
                openPrintModal();
            }
        };

        // Open print modal
        window.openPrintModal = function() {
            if (chartData.components.length === 0) {
                alert('Add components to your chord chart before printing.');
                return;
            }

            document.getElementById('printModal').classList.add('show');
            document.getElementById('autoscrollControls').classList.add('show');
            loadPreferredSpeed(); // Load saved speed for this song
            updatePrintPreview();
        };

        // Close print modal
        window.closePrintModal = function() {
            document.getElementById('printModal').classList.remove('show');
            document.getElementById('autoscrollControls').classList.remove('show');
            stopAutoscroll();
        };

        // Open current song in Show Time (single-song mode)
        window.openInShowTime = function() {
            if (!currentSong) {
                alert('No song loaded');
                return;
            }
            
            // Encode song ID as artist|song
            const songId = encodeURIComponent(`${currentSong.artist}|${currentSong.song}`);
            
            // Create return URL to come back to this chord chart
            const returnUrl = encodeURIComponent(`chord-chart-editor.html?songId=${currentSongId}`);
            
            // Open Show Time in single-song mode with return URL
            window.location.href = `show-time.html?mode=single&songId=${songId}&returnUrl=${returnUrl}`;
        };

        // ============================================================================
        // AUTOSCROLL FUNCTIONALITY
        // ============================================================================
        
        let autoscrollActive = false;
        let autoscrollInterval = null;
        let scrollSpeed = 1.0;
        const BASE_SCROLL_SPEED = 0.5;
        let accumulatedScroll = 0; // For fractional scrolling

        // Toggle autoscroll
        window.toggleAutoscroll = function() {
            if (autoscrollActive) {
                stopAutoscroll();
            } else {
                startAutoscroll();
            }
        };

        function startAutoscroll() {
            autoscrollActive = true;
            accumulatedScroll = 0; // Reset accumulator
            const playBtn = document.getElementById('autoscrollPlayBtn');
            
            playBtn.classList.add('playing');
            playBtn.querySelector('svg').innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
            
            const modalBody = document.querySelector('#printModal .modal-body');
            
            autoscrollInterval = setInterval(() => {
                if (modalBody) {
                    // Accumulate fractional scroll amounts
                    accumulatedScroll += BASE_SCROLL_SPEED * scrollSpeed;
                    
                    // Only scroll whole pixels
                    const scrollAmount = Math.floor(accumulatedScroll);
                    if (scrollAmount > 0) {
                        modalBody.scrollTop += scrollAmount;
                        accumulatedScroll -= scrollAmount; // Keep the fractional remainder
                    }
                    
                    // Auto-stop at bottom
                    if (modalBody.scrollTop >= modalBody.scrollHeight - modalBody.clientHeight) {
                        stopAutoscroll();
                    }
                }
            }, 20);
        }

        function stopAutoscroll() {
            autoscrollActive = false;
            const playBtn = document.getElementById('autoscrollPlayBtn');
            
            if (playBtn) {
                playBtn.classList.remove('playing');
                playBtn.querySelector('svg').innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';
            }
            
            if (autoscrollInterval) {
                clearInterval(autoscrollInterval);
                autoscrollInterval = null;
            }
        }

        // Adjust scroll speed
        // Adjust speed (called by +/- buttons)
        window.adjustSpeed = function(delta) {
            const newSpeed = Math.max(0.1, Math.min(3, scrollSpeed + delta));
            setScrollSpeed(parseFloat(newSpeed.toFixed(1)));
        };

        // Set scroll speed
        window.setScrollSpeed = function(speed) {
            scrollSpeed = speed;
            document.getElementById('speedValue').textContent = speed.toFixed(1) + 'x';
        };

        // Save preferred scroll speed for current song
        window.savePreferredSpeed = function() {
            if (!chartData || !currentSong) {
                alert('Please load a song first.');
                return;
            }

            // Save speed to chartData
            chartData.preferredScrollSpeed = scrollSpeed;
            
            // Save to localStorage
            saveChart();
            
            // Update button visual
            const btn = document.getElementById('saveSpeedBtn');
            const icon = document.getElementById('saveSpeedIcon');
            const text = document.getElementById('saveSpeedText');
            
            // Fill the bookmark icon
            icon.setAttribute('fill', 'var(--primary-light)');
            text.textContent = `Saved (${scrollSpeed.toFixed(1)}x)`;
            btn.style.borderColor = 'var(--primary-light)';
            
            // Show temporary feedback
            const originalBg = btn.style.background;
            btn.style.background = 'var(--primary-color)';
            setTimeout(() => {
                btn.style.background = originalBg;
            }, 500);
        };

        // Load preferred scroll speed when opening Performance View
        function loadPreferredSpeed() {
            if (chartData && chartData.preferredScrollSpeed) {
                setScrollSpeed(chartData.preferredScrollSpeed);
                
                // Update button visual to show saved state
                const btn = document.getElementById('saveSpeedBtn');
                const icon = document.getElementById('saveSpeedIcon');
                const text = document.getElementById('saveSpeedText');
                
                icon.setAttribute('fill', 'var(--primary-light)');
                text.textContent = `Saved (${chartData.preferredScrollSpeed.toFixed(1)}x)`;
                btn.style.borderColor = 'var(--primary-light)';
            } else {
                // Reset button to default state
                const btn = document.getElementById('saveSpeedBtn');
                const icon = document.getElementById('saveSpeedIcon');
                const text = document.getElementById('saveSpeedText');
                
                icon.setAttribute('fill', 'none');
                text.textContent = 'Save Speed';
                btn.style.borderColor = '';
            }
        }

        // Keyboard controls for autoscroll
        document.addEventListener('keydown', (e) => {
            // Only work when print modal is open and on performance view
            const modal = document.getElementById('printModal');
            const performanceView = document.getElementById('performanceView');
            
            if (!modal.classList.contains('show') || performanceView.style.display === 'none') {
                return;
            }
            
            // Prevent default if we're handling the key
            const handled = ['Space', 'ArrowLeft', 'ArrowRight'].includes(e.code);
            
            // Don't interfere if user is typing in an input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (handled) {
                e.preventDefault();
            }
            
            // Spacebar: Toggle play/stop
            if (e.code === 'Space') {
                toggleAutoscroll();
            }
            
            // Left Arrow: Decrease speed
            if (e.code === 'ArrowLeft') {
                const newSpeed = Math.max(0.5, scrollSpeed - 0.1);
                setScrollSpeed(parseFloat(newSpeed.toFixed(1)));
            }
            
            // Right Arrow: Increase speed
            if (e.code === 'ArrowRight') {
                const newSpeed = Math.min(3, scrollSpeed + 0.1);
                setScrollSpeed(parseFloat(newSpeed.toFixed(1)));
            }
        });

        // ============================================================================
        // UPDATE PRINT PREVIEW
        // ============================================================================

        // Update print preview
        window.updatePrintPreview = function() {
            const fontSize = document.getElementById('fontSize').value;
            const scaleToFit = document.getElementById('scaleToFit').checked;
            document.getElementById('fontSizeValue').textContent = fontSize + 'px';

            const options = {
                fontSize: parseInt(fontSize),
                scaleToFit
            };

            // Update both views
            const performanceHtml = ChordChartManager.generatePerformanceView(chartData, currentSong, options);
            document.getElementById('performanceView').innerHTML = performanceHtml;

            const printHtml = ChordChartManager.generatePrintView(chartData, currentSong, options);
            document.getElementById('printPreview').innerHTML = printHtml;
        };

        // Switch between performance and print view tabs
        window.switchViewTab = function(view) {
            const performanceView = document.getElementById('performanceView');
            const printPreview = document.getElementById('printPreview');
            const autoscrollControls = document.getElementById('autoscrollControls');
            const tabs = document.querySelectorAll('.tab-button');

            if (view === 'performance') {
                performanceView.style.display = 'block';
                printPreview.style.display = 'none';
                autoscrollControls.classList.add('show');
                tabs[0].classList.add('active');
                tabs[1].classList.remove('active');
            } else {
                performanceView.style.display = 'none';
                printPreview.style.display = 'block';
                autoscrollControls.classList.remove('show');
                stopAutoscroll(); // Stop scrolling when switching away
                tabs[0].classList.remove('active');
                tabs[1].classList.add('active');
            }
        };
    </script>

    <!-- Theme Management Script (Inline for file:// compatibility) -->
    <script>
        // Synchronized theme management using localStorage
        function loadTheme() {
            const savedTheme = localStorage.getItem('bandOrganizerTheme') || 'grey';
            applyTheme(savedTheme);
            
            // Sync both desktop and mobile theme selectors
            const themeSelector = document.getElementById('themeSelector');
            if (themeSelector) {
                themeSelector.value = savedTheme;
            }
            const mobileSelector = document.getElementById('mobileThemeSelector');
            if (mobileSelector) {
                mobileSelector.value = savedTheme;
            }
            
            return savedTheme;
        }
        
        function applyTheme(theme) {
            if (theme === 'grey') {
                document.body.removeAttribute('data-theme');
            } else {
                document.body.setAttribute('data-theme', theme);
            }
            updateFaviconForTheme(theme);
        }
        
        function updateFaviconForTheme(theme) {
            const watermark = localStorage.getItem('watermark') || 'guitar';
            updateFaviconForThemeAndWatermark(theme, watermark);
        }
        
        function updateFaviconForThemeAndWatermark(theme, watermarkType) {
            const link = document.querySelector("link[rel*='icon']");
            if (!link) return;
            
            // Map themes to colors (hex codes need to be URL encoded with %23)
            const themeColors = {
                'grey': '%23d84315',
                'red': '%23d84315',
                'blue': '%231976d2',
                'green': '%23388e3c',
                'purple': '%237b1fa2',
                'cyan': '%2300838f',
                'amber': '%23f57c00',
                'pink': '%23c2185b',
                'teal': '%2314b8a6',
                'copper': '%23b87333',
                'sunrise': '%23ffb700',
                'sunset': '%23ff8c00',
                'synthwave': '%23a78bfa',
                'prism': '%2314b8a6'
            };
            
            const color = themeColors[theme] || '%23d84315';
            
            // Use guitar, drum, or BlackDoubt icon based on watermark preference
            if (watermarkType === 'drum') {
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' preserveAspectRatio='xMidYMid meet'><g transform='scale(1.4) translate(-2, -2)'><circle cx='23' cy='17' r='4.5' fill='none' stroke='${color}' stroke-width='2.5'/><line x1='16' y1='21.5' x2='16' y2='2' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='11' y1='5' x2='21' y2='5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='18' y1='8' x2='28' y2='8' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='21' y1='10' x2='26' y2='10' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='7' y1='12.5' x2='18' y2='12.5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='30' y1='12.5' x2='30' y2='2' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='25' y1='5' x2='35' y2='5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='27' y1='8' x2='33' y2='8' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='26' y1='14' x2='31' y2='14' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/></g></svg>`;
            } else if (watermarkType === 'blackdoubt') {
                // BlackDoubt icon favicon
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40' fill='none' stroke='${color}' stroke-width='2' stroke-linecap='round'><path d='M 20 3 L 37 20 L 20 37 L 3 20 Z' stroke='${color}' fill='none' stroke-width='2'/><circle cx='20' cy='20' r='13' stroke='${color}' fill='none' stroke-width='2'/><text x='20' y='20' font-size='20' font-family='serif' text-anchor='middle' dominant-baseline='central' fill='${color}' stroke='none'></text></svg>`;
            } else {
                // Guitar icon
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='${color}' stroke-width='2.5' stroke-linecap='round'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>`;
            }
        }
        
        // Change theme and save to localStorage
        window.changeTheme = function(theme) {
            console.log('Changing theme to:', theme);
            localStorage.setItem('bandOrganizerTheme', theme);
            applyTheme(theme);
            // Sync mobile theme selector
            const mobileSelector = document.getElementById('mobileThemeSelector');
            if (mobileSelector && mobileSelector.value !== theme) {
                mobileSelector.value = theme;
            }
            // Sync desktop theme selector
            const desktopSelector = document.getElementById('themeSelector');
            if (desktopSelector && desktopSelector.value !== theme) {
                desktopSelector.value = theme;
            }
            console.log('Body data-theme attribute:', document.body.getAttribute('data-theme'));
        };
        
        // Load theme immediately
        loadTheme();
    </script>
    
    <!-- Version Management -->
    <script src="./js/version.js"></script>
</body>
</html>

