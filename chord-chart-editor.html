<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Chart Editor</title>
    <!-- PWA Manifest (disabled for file:// protocol - only works on web server) -->
    <!-- <link rel="manifest" href="./manifest.json"> -->
    <meta name="theme-color" content="#d84315">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Band Manager">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23d84315' stroke-width='2'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>">
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/layout.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Custom Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-light);
        }

        ::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }

        /* Firefox Scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Background watermark - Guitar */
        body::before {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.15'%3E%3Ccircle cx='12' cy='17' r='4.5'/%3E%3Cline x1='12' y1='12.5' x2='12' y2='2'/%3E%3Cline x1='9' y1='5' x2='15' y2='5'/%3E%3Cline x1='9' y1='8' x2='15' y2='8'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s ease;
        }

        /* Background watermark - Drum (hidden by default) */
        body::after {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' fill='none' stroke='%23ffffff' stroke-width='1.5' opacity='0.15'%3E%3Ccircle cx='23' cy='17' r='4.5'/%3E%3Cline x1='16' y1='21.5' x2='16' y2='2'/%3E%3Cline x1='11' y1='5' x2='21' y2='5'/%3E%3Cline x1='18' y1='8' x2='28' y2='8'/%3E%3Cline x1='21' y1='10' x2='26' y2='10'/%3E%3Cline x1='7' y1='12.5' x2='18' y2='12.5'/%3E%3Cline x1='30' y1='12.5' x2='30' y2='2'/%3E%3Cline x1='25' y1='5' x2='35' y2='5'/%3E%3Cline x1='27' y1='8' x2='33' y2='8'/%3E%3Cline x1='26' y1='14' x2='31' y2='14'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show drum watermark when active */
        body.drum-watermark::before {
            opacity: 0;
        }

        body.drum-watermark::after {
            opacity: 1;
        }

        /* Header */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            padding: 0;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .header {
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--primary-color);
            flex-shrink: 0;
            position: relative;
            z-index: 9998;
            box-shadow: 0 2px 10px var(--primary-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: visible;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            color: var(--primary-light);
            text-shadow: 0 0 20px var(--primary-glow);
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            flex-shrink: 0;
        }

        .header h1 svg {
            width: 20px;
            height: 20px;
        }

        .header-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .nav-links {
            display: flex;
            gap: 10px;
        }

        .nav-link {
            padding: 6px 12px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            color: var(--primary-light);
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 13px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            display: inline-flex;
            align-items: center;
        }

        .nav-link:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
            color: var(--primary-lighter);
            box-shadow: 0 0 10px var(--primary-glow);
            transform: translateY(-2px);
        }

        .theme-selector {
            padding: 6px 8px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            color: var(--primary-light);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
            min-width: 70px;
            max-width: 90px;
        }

        .theme-selector:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
        }

        .btn {
            padding: 6px 12px;
            border: 2px solid var(--primary-light);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        .btn-primary {
            background: var(--primary-dark);
            color: var(--primary-light);
        }

        .btn-primary:hover {
            background: var(--primary-darker);
            color: var(--primary-lighter);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2a2d33;
            color: #c1c7d0;
        }

        .btn-secondary:hover {
            background: #3a3e47;
            color: #e5e9f0;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #5c1d0a;
            color: #ff6b3d;
            border: 2px solid #ff6b3d;
        }

        .btn-danger:hover {
            background: #7a2710;
            color: #ffa580;
            transform: translateY(-2px);
        }

        .btn-danger:disabled {
            background: #2a1d1a;
            color: #664d3d;
            border-color: #664d3d;
            cursor: not-allowed;
            transform: none;
        }

        /* Main Layout */
        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        /* Left Sidebar - Component Palette */
        .left-sidebar {
            width: 140px;
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-right: 2px solid var(--primary-border);
            padding: 15px 8px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 2px 0 10px var(--primary-glow);
        }

        .palette-title {
            color: var(--primary-light);
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
        }

        .component-item {
            padding: 8px;
            margin-bottom: 5px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-light);
            border-radius: 8px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s;
            -webkit-user-select: none;
            user-select: none;
            font-weight: 600;
            font-size: 13px;
            color: var(--primary-light);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .component-item:hover {
            background: var(--primary-darker);
            border-color: var(--primary-lighter);
            color: var(--primary-lighter);
            transform: translateX(5px);
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .component-item:active {
            cursor: grabbing;
        }

        /* Center - Drop Zone */
        .center-pane {
            flex: 1;
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }

        .song-info {
            background: rgba(26, 26, 26, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid var(--primary-border);
            margin-bottom: 20px;
            box-shadow: 0 2px 10px var(--primary-glow);
        }

        .song-info h2 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
            margin-bottom: 5px;
        }

        .song-info .artist {
            color: var(--text-secondary);
            font-size: 16px;
            margin-bottom: 10px;
        }

        .song-info .meta {
            display: flex;
            gap: 20px;
            font-size: 14px;
            color: var(--text-tertiary);
        }

        .drop-zone {
            min-height: 400px;
            border: 2px dashed var(--primary-border);
            border-radius: 8px;
            padding: 20px;
        }

        .drop-zone.drag-over {
            border-color: var(--primary-light);
            background: var(--primary-bg);
            box-shadow: 0 0 20px var(--primary-glow);
        }

        .drop-zone-empty {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-tertiary);
        }

        .drop-zone-empty svg {
            width: 64px;
            height: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
            stroke: var(--primary-color);
        }

        /* Component Tiles */
        .component-tile {
            background: rgba(26, 26, 26, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px var(--primary-glow);
            transition: all 0.3s;
        }

        .component-tile:hover {
            border-color: var(--primary-light);
            box-shadow: 0 6px 20px var(--primary-glow);
            transform: translateY(-2px);
        }

        .component-tile.dragging {
            opacity: 0.5;
        }

        .component-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--primary-border);
        }

        .component-title {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
            font-weight: bold;
            font-size: 16px;
            flex: 1;
        }

        .component-actions {
            display: flex;
            gap: 5px;
        }

        .icon-btn {
            background: var(--primary-bg);
            border: 2px solid var(--primary-border);
            color: var(--primary-light);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .icon-btn:hover {
            color: var(--primary-lighter);
            background: var(--primary-darker);
            border-color: var(--primary-light);
            transform: scale(1.1);
        }

        .drag-handle {
            cursor: grab;
            padding: 4px 8px;
            margin-right: 10px;
            color: var(--primary-light);
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            background: var(--primary-bg);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            -webkit-user-select: none;
            user-select: none;
        }

        .drag-handle:hover {
            background: var(--primary-darker);
            border-color: var(--primary-light);
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Custom Range Slider (Theme-matched) */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        /* Slider Track */
        input[type="range"]::-webkit-slider-track {
            background: rgba(0, 0, 0, 0.5);
            height: 6px;
            border-radius: 3px;
            border: 1px solid var(--primary-border);
        }

        input[type="range"]::-moz-range-track {
            background: rgba(0, 0, 0, 0.5);
            height: 6px;
            border-radius: 3px;
            border: 1px solid var(--primary-border);
        }

        /* Slider Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            border: 2px solid var(--primary-light);
            margin-top: -6px;
            box-shadow: 0 0 8px var(--primary-glow);
            transition: all 0.3s;
        }

        input[type="range"]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            border: 2px solid var(--primary-light);
            box-shadow: 0 0 8px var(--primary-glow);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.15);
            box-shadow: 0 0 12px var(--primary-glow);
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: var(--primary-light);
            transform: scale(1.15);
            box-shadow: 0 0 12px var(--primary-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            background: var(--primary-lighter);
        }

        input[type="range"]::-moz-range-thumb:active {
            background: var(--primary-lighter);
        }

        /* Custom Checkbox (Theme-matched) */
        input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
            flex-shrink: 0;
        }

        input[type="checkbox"]:hover {
            border-color: var(--primary-light);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        input[type="checkbox"]:checked {
            background: var(--primary-color);
            border-color: var(--primary-light);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        /* Autoscroll Controls (Inside Modal, Scrolls with content) */
        #printModal .autoscroll-controls {
            position: sticky;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 1000;
            display: none;
            justify-content: flex-end;
            align-items: flex-end;
            gap: 15px;
            pointer-events: none;
            padding-right: 30px;
            /* Take no space - orbs overlay content */
            background: transparent;
            border: none;
            margin: 0;
            height: 0;
            overflow: visible;
        }

        #printModal.show .autoscroll-controls.show {
            display: flex;
        }

        .autoscroll-controls > * {
            pointer-events: auto;
        }

        /* Speed Adjustment Orbs */
        .speed-orb {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(26, 26, 26, 0.95);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            border: 2px solid var(--primary-border);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: var(--text-secondary);
            transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
        }

        .speed-orb:hover {
            border-color: var(--primary-light);
            color: var(--primary-light);
            transform: scale(1.15);
            box-shadow: 0 6px 25px var(--primary-glow);
        }

        .speed-orb:active {
            transform: scale(0.95);
        }

        /* Combined Play/Speed Display Orb */
        .autoscroll-play-btn {
            width: 75px;
            height: 75px;
            border-radius: 50%;
            background: rgba(26, 26, 26, 0.95);
            -webkit-backdrop-filter: blur(15px);
            backdrop-filter: blur(15px);
            border: 3px solid var(--primary-color);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            transition: all 0.3s;
            box-shadow: 0 6px 30px var(--primary-glow);
            position: relative;
        }

        .autoscroll-play-btn:hover {
            transform: scale(1.1);
            border-color: var(--primary-light);
            box-shadow: 0 8px 40px var(--primary-glow);
        }

        .autoscroll-play-btn:active {
            transform: scale(0.95);
        }

        .autoscroll-play-btn.playing {
            background: var(--primary-color);
            border-color: var(--primary-light);
        }

        .autoscroll-play-btn svg {
            width: 22px;
            height: 22px;
            fill: var(--primary-light);
            flex-shrink: 0;
        }

        .autoscroll-play-btn.playing svg {
            fill: white;
        }

        .speed-display-text {
            font-size: 12px;
            font-weight: bold;
            color: var(--primary-light);
            margin-top: -2px;
        }

        .autoscroll-play-btn.playing .speed-display-text {
            color: white;
        }

        /* Modal body to allow sticky positioning */
        #printModal .modal-body {
            position: relative;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .component-textarea {
            width: 100%;
            min-height: 100px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            padding: 10px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }

        .component-textarea:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        /* Grid Editor Styles */
        .grid-editor {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
        }

        .grid-editor-table {
            border-collapse: separate;
            border-spacing: 0;
            font-family: 'Courier New', monospace;
            min-width: 100%;
        }

        .grid-controls {
            margin-bottom: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .grid-indicator-cell {
            background: rgba(0, 0, 0, 0.5);
            border-right: 2px solid var(--primary-border);
            padding: 6px;
            vertical-align: middle;
            text-align: center;
            width: 40px;
            min-width: 40px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .grid-indicator-cell:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        .grid-row-selected .grid-indicator-cell {
            background: rgba(33, 150, 243, 0.4);
        }

        .row-indicator {
            font-size: 14px;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
            min-width: 24px;
            text-align: center;
        }

        .row-indicator-generic {
            background: rgba(100, 100, 100, 0.3);
            color: #aaa;
            border: 1px solid #666;
        }

        .row-indicator-chord {
            background: rgba(33, 150, 243, 0.3);
            border: 1px solid var(--primary-color);
            color: var(--primary-light);
        }

        .row-indicator-lyric {
            background: rgba(0, 200, 100, 0.3);
            border: 1px solid #00c864;
            color: #00ff80;
        }

        .grid-content-cell {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(100, 100, 100, 0.3);
            padding: 0;
            width: 20px;
            height: 24px;
        }

        .grid-cell-input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 13px;
            text-align: center;
            padding: 4px 2px;
            outline: none;
        }

        .grid-cell-input:focus {
            background: rgba(255, 255, 255, 0.1);
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.5);
        }

        .grid-cell-input:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .grid-row-selected {
            background: rgba(33, 150, 243, 0.15);
        }

        .grid-editor-table td {
            border: 1px solid var(--primary-border);
            padding: 0;
            text-align: center;
            vertical-align: middle;
            min-width: 24px;
            max-width: 24px;
            height: 30px;
        }

        .grid-editor-table tr:first-child td {
            background: rgba(0, 0, 0, 0.5);
        }

        /* Grid cells are now uniform - old chord/lyric specific styles removed */

        .chord-format-hint {
            margin-top: 5px;
            font-size: 12px;
            color: var(--text-tertiary);
        }

        /* Right Sidebar - Settings */
        .right-sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-left: 2px solid var(--primary-border);
            padding: 20px 10px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: -2px 0 10px var(--primary-glow);
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
        }

        .right-sidebar.collapsed {
            width: 40px;
            padding: 20px 5px;
            overflow: hidden;
        }

        .right-sidebar.collapsed .settings-section {
            display: none;
        }

        .collapse-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--primary-bg);
            border: 2px solid var(--primary-border);
            color: var(--primary-light);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.3s;
            z-index: 10;
        }

        .right-sidebar.collapsed .collapse-toggle {
            right: 5px;
        }

        .collapse-toggle:hover {
            color: var(--primary-lighter);
            background: var(--primary-darker);
            border-color: var(--primary-light);
            transform: scale(1.1);
        }

        .collapsed-label {
            display: none;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            color: var(--primary-light);
            font-weight: bold;
            font-size: 14px;
            margin-top: 60px;
            text-align: center;
        }

        .right-sidebar.collapsed .collapsed-label {
            display: block;
        }

        .settings-section {
            margin-bottom: 25px;
        }

        .settings-title {
            color: var(--primary-light);
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 5px;
        }

        .setting-item input[type="radio"] {
            margin-right: 5px;
        }

        .setting-item select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            color: var(--text-primary);
            border-radius: 4px;
        }

        /* Print Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }

        .modal.show {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 90px 20px 20px 20px;
        }

        .modal-content {
            background: rgba(26, 26, 26, 0.95);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            padding: 0;
            border-radius: 8px;
            max-width: 1200px;
            width: 90%;
            max-height: calc(100vh - 110px);
            overflow: hidden;
            border: 2px solid var(--primary-border);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 2px solid var(--primary-border);
            position: sticky;
            top: 0;
            background: rgba(26, 26, 26, 0.98);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            z-index: 100;
            flex-shrink: 0;
        }

        .modal-header h2 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .close {
            color: var(--text-tertiary);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close:hover {
            color: var(--primary-light);
        }

        .modal-body {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
        }

        .print-controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
            padding: 8px 10px;
            background: var(--primary-bg);
            border-radius: 8px;
            border: 2px solid var(--primary-border);
        }
        
        .print-controls .btn {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        .print-controls .setting-item {
            font-size: 12px;
        }

        .print-preview {
            background: white;
            color: black;
            padding: 30px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .performance-view {
            background: rgba(26, 26, 26, 0.95);
            color: var(--text-primary);
            padding: 30px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            border: 2px solid var(--primary-border);
        }

        .view-tabs {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            border-bottom: 1px solid var(--primary-border);
            padding-bottom: 6px;
        }

        .tab-button {
            padding: 6px 12px;
            background: var(--primary-bg);
            border: 1px solid var(--primary-border);
            color: var(--primary-light);
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 13px;
        }

        .tab-button.active {
            background: var(--primary-color);
            color: white;
            border-bottom-color: transparent;
            border-width: 1px;
        }

        .tab-button:hover:not(.active) {
            background: var(--primary-darker);
            border-color: var(--primary-light);
        }

        .print-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid black;
            padding-bottom: 10px;
        }

        .performance-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }

        .print-header h1,
        .performance-header h1 {
            font-size: 20px;
            margin-bottom: 3px;
        }

        .print-header h1 {
            color: #000;
        }

        .performance-header h1 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .print-header h2,
        .performance-header h2 {
            font-size: 16px;
            margin-bottom: 8px;
        }

        .print-header h2 {
            color: #555;
        }

        .performance-header h2 {
            color: var(--text-secondary);
        }

        .print-lyrics,
        .performance-lyrics {
            line-height: 1.8;
            padding-left: 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            flex: 1;
        }

        .print-lyrics {
            line-height: 1.8;
            padding-left: 0;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            flex: 1;
        }

        .chord-line {
            font-weight: bold;
            font-size: 1em;
            white-space: pre-wrap;
        }

        .lyric-line {
            font-size: 1em;
            white-space: pre-wrap;
        }

        .print-preview .chord-line {
            color: #d84315;
        }

        .performance-container .chord-line {
            color: rgba(255, 255, 255, 0.4);
            opacity: 0.7;
        }

        .performance-view .lyric-line {
            color: var(--text-primary);
        }

        .print-preview .lyric-line {
            color: #000;
        }

        .performance-view .lyric-line {
            color: var(--text-primary);
        }

        .print-component h3,
        .performance-component {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .performance-component h3 {
            font-size: 1.1em;
            margin: 0;
            padding-right: 20px;
            font-weight: bold;
            min-width: 120px;
            flex-shrink: 0;
        }

        .print-component {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .print-component h3 {
            font-size: 1.1em;
            margin: 0;
            padding-right: 20px;
            font-weight: bold;
            min-width: 120px;
            flex-shrink: 0;
            color: #333;
        }

        .performance-component h3 {
            color: var(--primary-light);
            text-shadow: 0 0 5px var(--primary-glow);
        }

        .print-header h1,
        .performance-header h1 {
            font-size: 1.5em;
            margin-bottom: 3px;
            font-weight: bold;
        }

        .print-header h1 {
            color: #000;
        }

        .performance-header h1 {
            color: var(--primary-light);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .print-header h2,
        .performance-header h2 {
            font-size: 1.2em;
            margin-bottom: 8px;
        }

        .print-header h2 {
            color: #555;
        }

        .performance-header h2 {
            color: var(--text-secondary);
        }

        .print-meta,
        .performance-meta {
            display: flex;
            justify-content: center;
            gap: 15px;
            font-size: 0.95em;
            flex-wrap: wrap;
        }

        .performance-meta {
            color: var(--text-tertiary);
        }

        /* Print Styles */
        @media print {
            body * {
                visibility: hidden;
            }
            #printPreview, #printPreview * {
                visibility: visible;
            }
            #printPreview {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                padding: 0.5in;
            }
            #performanceView {
                display: none !important;
            }
            .modal, .print-controls {
                display: none !important;
            }
        }

        /* Auto-save Indicator */
        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: 2px solid var(--primary-light);
        }

        .save-indicator.show {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .header h1 {
                font-size: 18px;
            }
            .song-selector {
                max-width: 300px;
            }
        }

        @media (max-width: 1024px) {
            .left-sidebar, .right-sidebar {
                width: 180px;
            }
            .header {
                padding: 8px 12px;
            }
            .header h1 {
                font-size: 16px;
            }
            .header h1 svg {
                width: 18px;
                height: 18px;
            }
            .song-selector {
                max-width: 250px;
            }
            .btn, .nav-link {
                padding: 5px 10px;
                font-size: 12px;
            }
        }

        @media (max-width: 768px) {
            .main-layout {
                flex-direction: column;
            }
            .left-sidebar, .right-sidebar {
                width: 100%;
                max-height: 200px;
            }
            .header {
                padding: 6px 10px;
            }
            .header h1 {
                font-size: 14px;
            }
            .song-selector label {
                display: none;
            }
            .song-selector {
                min-width: 150px;
                max-width: 200px;
            }
            .btn, .nav-link {
                padding: 4px 8px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18V5l12-2v13"/>
                <circle cx="6" cy="18" r="3"/>
                <circle cx="18" cy="16" r="3"/>
            </svg>
            Chord Chart Editor
        </h1>
        <div class="song-selector" style="display: flex; align-items: center; gap: 8px; margin: 0 10px; position: relative; z-index: 9999; flex: 1; min-width: 200px; max-width: 400px;">
            <label for="songSearch" style="color: var(--text-primary); font-weight: 500; font-size: 14px; flex-shrink: 0;">Song:</label>
            <div style="position: relative; flex: 1; z-index: 9999;">
                <input 
                    type="text" 
                    id="songSearch"
                    name="songSearch"
                    title="Search for a song by artist or title"
                    placeholder="Type to search songs..."
                    autocomplete="off"
                    autocorrect="off"
                    autocapitalize="off"
                    spellcheck="false"
                    value=""
                    aria-label="Search songs by artist or title"
                    style="width: 100%; padding: 6px 8px; background: var(--card-bg); color: var(--text-primary); border: 1px solid var(--primary-border); border-radius: 4px; font-size: 14px;"
                    oninput="filterSongs()"
                    onfocus="showSongList()"
                />
                <div id="songList" class="song-list-dropdown" role="listbox" aria-label="Song search results" style="display: none; position: absolute; top: 100%; left: 0; right: 0; max-height: 400px; overflow-y: auto; background: var(--card-bg); border: 1px solid var(--primary-border); border-radius: 4px; margin-top: 4px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">
                </div>
            </div>
        </div>
            <div class="header-controls">
                <div class="nav-links">
                    <a href="song-manager.html" class="nav-link">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                            <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                            <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                        </svg>
                        Songs
                    </a>
                    <a href="setlist-manager.html" class="nav-link">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                            <line x1="8" y1="6" x2="21" y2="6"/>
                            <line x1="8" y1="12" x2="21" y2="12"/>
                            <line x1="8" y1="18" x2="21" y2="18"/>
                            <line x1="3" y1="6" x2="3.01" y2="6"/>
                            <line x1="3" y1="12" x2="3.01" y2="12"/>
                            <line x1="3" y1="18" x2="3.01" y2="18"/>
                        </svg>
                        Setlists
                    </a>
                </div>
                <label for="themeSelector" class="visually-hidden">Select theme color</label>
                <select id="themeSelector" name="themeSelector" class="theme-selector" title="Choose theme color" aria-label="Theme color selector" onchange="changeTheme(this.value)">
                    <option value="grey">Grey</option>
                    <option value="red">Red</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                    <option value="purple">Purple</option>
                    <option value="cyan">Cyan</option>
                    <option value="teal">Teal</option>
                    <option value="copper">Copper</option>
                    <option value="amber">Amber</option>
                    <option value="pink">Pink</option>
                    <option value="sunrise">Sunrise</option>
                    <option value="sunset">Sunset</option>
                </select>
                <button class="btn btn-primary" onclick="togglePrintModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                        <polyline points="6 9 6 2 18 2 18 9"/>
                        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                        <rect x="6" y="14" width="12" height="8"/>
                    </svg>
                    View/Print
                </button>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
        <!-- Left Sidebar - Component Palette -->
        <div class="left-sidebar">
            <div class="palette-title">Drag Components</div>
            <div class="component-item" draggable="true" data-type="Intro">Intro</div>
            <div class="component-item" draggable="true" data-type="Verse">Verse</div>
            <div class="component-item" draggable="true" data-type="Chorus">Chorus</div>
            <div class="component-item" draggable="true" data-type="Pre-Chorus">Pre-Chorus</div>
            <div class="component-item" draggable="true" data-type="Bridge">Bridge</div>
            <div class="component-item" draggable="true" data-type="Solo">Solo</div>
            <div class="component-item" draggable="true" data-type="Interlude">Interlude</div>
            <div class="component-item" draggable="true" data-type="Outro">Outro</div>
            <div class="component-item" draggable="true" data-type="Tag/Coda">Tag/Coda</div>
        </div>

        <!-- Center Pane - Drop Zone -->
        <div class="center-pane">
            <div class="song-info" id="songInfo">
                <h2 id="songTitle">Loading...</h2>
                <div class="artist" id="songArtist"></div>
                <div class="meta">
                    <span id="songKey"></span>
                    <span id="songTuning"></span>
                    <span id="songDuration"></span>
                </div>
            </div>

            <div class="drop-zone" id="dropZone">
                <div class="drop-zone-empty" id="emptyMessage">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14M5 12h14"/>
                    </svg>
                    <p>Drag components here to build your chord chart</p>
                    <p style="font-size: 12px; margin-top: 10px;">Components will auto-number as you add them</p>
                </div>
                <div id="componentsContainer"></div>
            </div>
        </div>

        <!-- Right Sidebar - Settings -->
        <div class="right-sidebar" id="rightSidebar">
            <button class="collapse-toggle" onclick="toggleRightPanel()" title="Toggle panel">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="15 18 9 12 15 6"/>
                </svg>
            </button>
            <div class="collapsed-label">Help & Actions</div>
            
            <div class="settings-section">
                <div class="settings-title">Chord Format Help</div>
                <div class="setting-item">
                    <p style="font-size: 12px; color: var(--text-tertiary); line-height: 1.6;">
                        <strong style="color: var(--primary-light);">Inline:</strong><br>
                        Amazing [G]grace how [C]sweet the [G]sound<br><br>
                        <strong style="color: var(--primary-light);">Separate Lines:</strong><br>
                        G&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G<br>
                        Amazing grace how sweet the sound
                    </p>
                </div>
            </div>

            <div class="settings-section">
                <div class="settings-title">Quick Actions</div>
                <button class="btn btn-secondary" onclick="saveChart()" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Now
                </button>
                <button class="btn btn-secondary" onclick="exportChart()" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Export
                </button>
                <button class="btn btn-danger" onclick="clearChart()" style="width: 100%;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Clear Chart
                </button>
            </div>

            <div class="settings-section">
                <div class="settings-title">Tips</div>
                <p style="font-size: 11px; color: var(--text-tertiary); line-height: 1.5;">
                    • Charts auto-save as you edit<br>
                    • Drag components to reorder<br>
                    • Numbering updates automatically<br>
                    • Use brackets [C] for inline chords<br>
                    • Print view formats for performance
                </p>
            </div>
        </div>
    </div>

    <!-- Print Modal -->
    <div id="printModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Performance View</h2>
                <span class="close" onclick="closePrintModal()">&times;</span>
            </div>

            <div class="modal-body">
                <div class="view-tabs">
                    <button class="tab-button active" onclick="switchViewTab('performance')">Performance View</button>
                    <button class="tab-button" onclick="switchViewTab('print')">Print Preview</button>
            </div>

            <div class="print-controls">
                    <!-- Font Size Control -->
                    <div class="setting-item" style="display: flex; align-items: center; gap: 8px;">
                        <label for="fontSize" style="margin: 0; font-size: 12px; min-width: 65px;">Font Size:</label>
                        <input type="range" id="fontSize" name="fontSize" min="10" max="20" value="14" title="Adjust font size for printing" aria-label="Font size slider" onchange="updatePrintPreview()" style="flex: 1;">
                        <span id="fontSizeValue" style="min-width: 32px; font-size: 12px;">14px</span>
                </div>
                    
                    <!-- Scale to Fit & Save Speed Row -->
                    <div style="display: flex; gap: 8px;">
                        <label for="scaleToFit" style="display: flex; align-items: center; gap: 5px; margin: 0; cursor: pointer; font-size: 12px; flex: 1;">
                        <input type="checkbox" id="scaleToFit" name="scaleToFit" title="Scale chart to fit one page" onchange="updatePrintPreview()">
                            Scale to fit
                    </label>
                        <button id="saveSpeedBtn" class="btn btn-secondary" onclick="savePreferredSpeed()" style="display: flex; align-items: center; gap: 6px; padding: 4px 10px; font-size: 12px;" title="Save current autoscroll speed for this song">
                            <svg id="saveSpeedIcon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                    </svg>
                            <span id="saveSpeedText">Save Speed</span>
                </button>
                    </div>
            </div>

                <div id="performanceView" class="performance-view">
                    <!-- Performance content will be generated here -->
                </div>

                <div id="printPreview" class="print-preview" style="display: none;">
                <!-- Print content will be generated here -->
                </div>
            </div>

            <!-- Autoscroll Controls (Centered, scrolls with content) -->
            <div class="autoscroll-controls" id="autoscrollControls">
                <!-- Slow button -->
                <button class="speed-orb" onclick="adjustSpeed(-0.1)" title="Slower (←)">−</button>
                
                <!-- Combined Play/Speed Display -->
                <button class="autoscroll-play-btn" id="autoscrollPlayBtn" onclick="toggleAutoscroll()" title="Play/Stop (Space)">
                    <svg viewBox="0 0 24 24">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    <span class="speed-display-text" id="speedValue">1.0x</span>
                </button>
                
                <!-- Fast button -->
                <button class="speed-orb" onclick="adjustSpeed(0.1)" title="Faster (→)">+</button>
            </div>
        </div>
    </div>

    <!-- Auto-save Indicator -->
    <div class="save-indicator" id="saveIndicator">✓ Saved</div>

    <script>
        // ============================================================================
        // STORAGE UTILITIES (Inline for compatibility)
        // ============================================================================
        
        const STORAGE_KEYS = {
            SONGS: 'songDatabase',
            SONGS_LEGACY: 'bandSongs',
            THEME: 'bandOrganizerTheme'
        };

        const Storage = {
            get(key, defaultValue = null) {
                try {
                    const item = localStorage.getItem(key);
                    if (item === null) return defaultValue;
                    
                    // Try to parse as JSON
                    try {
                        return JSON.parse(item);
                    } catch (parseError) {
                        // If parse fails, return the raw string (for legacy data)
                        return item;
                    }
                } catch (error) {
                    console.error(`Error reading from localStorage (${key}):`, error);
                    return defaultValue;
                }
            },
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (error) {
                    console.error(`Error writing to localStorage (${key}):`, error);
                    return false;
                }
            }
        };

        // ============================================================================
        // CHORD CHART UTILITIES
        // ============================================================================
        
        const COMPONENT_TYPES = {
            INTRO: 'Intro',
            VERSE: 'Verse',
            CHORUS: 'Chorus',
            PRE_CHORUS: 'Pre-Chorus',
            BRIDGE: 'Bridge',
            SOLO: 'Solo',
            INTERLUDE: 'Interlude',
            OUTRO: 'Outro',
            TAG: 'Tag/Coda'
        };

        const ChordChartManager = {
            parseChords(text) {
                const chords = [];
                const regex = /\[([^\]]+)\]/g;
                let match;
                
                while ((match = regex.exec(text)) !== null) {
                    chords.push({
                        chord: match[1],
                        position: match.index,
                        length: match[0].length
                    });
                }
                
                return chords;
            },

            extractLyrics(text) {
                return text.replace(/\[([^\]]+)\]/g, '');
            },

            inlineToChordLine(text) {
                const chords = this.parseChords(text);
                const lyrics = this.extractLyrics(text);
                
                if (chords.length === 0) {
                    return { chords: '', lyrics: lyrics };
                }
                
                let chordLine = '';
                let lastPos = 0;
                
                chords.forEach(chord => {
                    const lyricsPos = chord.position - (chordLine.length);
                    const spaces = Math.max(0, lyricsPos - lastPos);
                    chordLine += ' '.repeat(spaces) + chord.chord;
                    lastPos = lyricsPos + chord.chord.length;
                });
                
                return {
                    chords: chordLine,
                    lyrics: lyrics
                };
            },

            autoNumber(components) {
                const counts = {};
                
                components.forEach(comp => {
                    counts[comp.type] = (counts[comp.type] || 0) + 1;
                });
                
                const currentCounts = {};
                
                return components.map(comp => {
                    const type = comp.type;
                    const totalOfType = counts[type];
                    
                    currentCounts[type] = (currentCounts[type] || 0) + 1;
                    const number = currentCounts[type];
                    
                    const displayName = totalOfType > 1 
                        ? `${type} ${number}` 
                        : type;
                    
                    return {
                        ...comp,
                        displayName,
                        number: totalOfType > 1 ? number : null
                    };
                });
            },

            generatePrintView(chart, song, options = {}) {
                const { fontSize = 14, scaleToFit = false } = options;
                
                const scaleStyle = scaleToFit ? 'transform: scale(0.85); transform-origin: top left;' : '';
                
                let html = `
                    <div class="print-container" style="font-size: ${fontSize}px; ${scaleStyle}">
                        <div class="print-header">
                            <h1>${song.song}</h1>
                            <h2>${song.artist}</h2>
                            <div class="print-meta">
                                ${song.key ? `<span>Key: ${song.key}</span>` : ''}
                                ${song.tuning ? `<span>Tuning: ${song.tuning}</span>` : ''}
                                ${song.duration ? `<span>Duration: ${song.duration}</span>` : ''}
                            </div>
                        </div>
                        <div class="print-body">
                `;
                
                chart.components.forEach(comp => {
                    const lines = comp.lyrics.split('\n');
                    
                    // Helper to detect if a line is a chord line (contains chord-like patterns)
                    const isChordLine = (line) => {
                        const trimmed = line.trim();
                        if (!trimmed) return false;
                        
                        // Strict chord pattern: A-G followed by optional modifiers, separated by spaces
                        // Must be at least 2 characters and contain only chord-like elements
                        const chordPattern = /^[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?(\s+[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?)*$/;
                        
                        // Must NOT contain lowercase words, punctuation (except # and /) or common lyric indicators
                        const hasLyricIndicators = /[a-z]{3,}|[,;.!?'"()]/.test(trimmed);
                        
                        // Must start with a valid chord (uppercase A-G)
                        const startsWithChord = /^[A-G]/.test(trimmed);
                        
                        return startsWithChord && !hasLyricIndicators && chordPattern.test(trimmed);
                    };
                    
                    // Build content HTML
                    let contentHtml = '';
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const lineMetadata = comp.lyricsMetadata && comp.lyricsMetadata[i];
                        
                        if (!line.trim()) {
                            // Empty line - render as empty div to preserve spacing
                            contentHtml += `<div class="lyric-line">&nbsp;</div>`;
                            continue;
                        }
                        
                        // Priority 1: Use explicit metadata from grid editor
                        if (lineMetadata) {
                            if (lineMetadata.type === 'chord') {
                                contentHtml += `<div class="chord-line">${line}</div>`;
                                continue;
                            } else if (lineMetadata.type === 'lyric') {
                                contentHtml += `<div class="lyric-line">${line}</div>`;
                                continue;
                            }
                            // If type is 'generic', fall through to detection
                        }
                        
                        // Priority 2: Check for inline chord format [Chord]
                        if (line.includes('[')) {
                            const formatted = this.inlineToChordLine(line);
                            if (formatted.chords) {
                                contentHtml += `<div class="chord-line">${formatted.chords}</div>`;
                            }
                            contentHtml += `<div class="lyric-line">${formatted.lyrics}</div>`;
                            continue;
                        }
                        
                        // Priority 3: Fallback to regex detection
                        if (isChordLine(line)) {
                            contentHtml += `<div class="chord-line">${line}</div>`;
                            continue;
                        }
                        
                        // Priority 4: Default to lyric
                        contentHtml += `<div class="lyric-line">${line}</div>`;
                    }
                    
                    html += `
                        <div class="print-component">
                            <h3>${comp.displayName}</h3>
                            <div class="print-lyrics">${contentHtml}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            },

            generatePerformanceView(chart, song, options = {}) {
                const { fontSize = 14, scaleToFit = false } = options;
                
                const scaleStyle = scaleToFit ? 'transform: scale(0.85); transform-origin: top left;' : '';
                
                let html = `
                    <div class="performance-container" style="font-size: ${fontSize}px; ${scaleStyle}">
                        <div class="performance-header">
                            <h1>${song.song}</h1>
                            <h2>${song.artist}</h2>
                            <div class="performance-meta">
                                ${song.key ? `<span>Key: ${song.key}</span>` : ''}
                                ${song.tuning ? `<span>Tuning: ${song.tuning}</span>` : ''}
                                ${song.duration ? `<span>Duration: ${song.duration}</span>` : ''}
                            </div>
                        </div>
                        <div class="performance-body">
                `;
                
                chart.components.forEach(comp => {
                    const lines = comp.lyrics.split('\n');
                    
                    // Helper to detect if a line is a chord line (contains chord-like patterns)
                    const isChordLine = (line) => {
                        const trimmed = line.trim();
                        if (!trimmed) return false;
                        
                        // Strict chord pattern: A-G followed by optional modifiers, separated by spaces
                        // Must be at least 2 characters and contain only chord-like elements
                        const chordPattern = /^[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?(\s+[A-G](#|b)?(m|M|maj|min|sus|aug|dim|add)?[0-9]?([/-][A-G](#|b)?)?)*$/;
                        
                        // Must NOT contain lowercase words, punctuation (except # and /) or common lyric indicators
                        const hasLyricIndicators = /[a-z]{3,}|[,;.!?'"()]/.test(trimmed);
                        
                        // Must start with a valid chord (uppercase A-G)
                        const startsWithChord = /^[A-G]/.test(trimmed);
                        
                        return startsWithChord && !hasLyricIndicators && chordPattern.test(trimmed);
                    };
                    
                    // Build content HTML
                    let contentHtml = '';
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        const lineMetadata = comp.lyricsMetadata && comp.lyricsMetadata[i];
                        
                        if (!line.trim()) {
                            // Empty line - render as empty div to preserve spacing
                            contentHtml += `<div class="lyric-line">&nbsp;</div>`;
                            continue;
                        }
                        
                        // Priority 1: Use explicit metadata from grid editor
                        if (lineMetadata) {
                            if (lineMetadata.type === 'chord') {
                                contentHtml += `<div class="chord-line">${line}</div>`;
                                continue;
                            } else if (lineMetadata.type === 'lyric') {
                                contentHtml += `<div class="lyric-line">${line}</div>`;
                                continue;
                            }
                            // If type is 'generic', fall through to detection
                        }
                        
                        // Priority 2: Check for inline chord format [Chord]
                            if (line.includes('[')) {
                                const formatted = this.inlineToChordLine(line);
                                if (formatted.chords) {
                                contentHtml += `<div class="chord-line">${formatted.chords}</div>`;
                                }
                            contentHtml += `<div class="lyric-line">${formatted.lyrics}</div>`;
                            continue;
                            }
                        
                        // Priority 3: Fallback to regex detection
                        if (isChordLine(line)) {
                            contentHtml += `<div class="chord-line">${line}</div>`;
                            continue;
                        }
                        
                        // Priority 4: Default to lyric
                        contentHtml += `<div class="lyric-line">${line}</div>`;
                    }
                    
                    html += `
                        <div class="performance-component">
                            <h3>${comp.displayName}</h3>
                            <div class="performance-lyrics">${contentHtml}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
            },

            createComponent(type) {
                return {
                    id: Date.now() + Math.random(),
                    type: type,
                    displayName: type,
                    lyrics: '',
                    number: null
                };
            },

            createEmptyChart() {
                return {
                    components: [],
                    settings: {
                        defaultChordFormat: 'inline',
                        showChordDiagrams: false,
                        fontSize: 14
                    },
                    preferredScrollSpeed: null // Store preferred autoscroll speed for this song
                };
            }
        };

        // ============================================================================
        // MAIN APPLICATION
        // ============================================================================
        
        // Global state
        let currentSongId = null;
        let currentSong = null;
        let chartData = null;
        let autoSaveTimer = null;
        let allSongs = [];

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Immediately clear the search box (before anything else)
            const searchBox = document.getElementById('songSearch');
            searchBox.value = '';
            
            // Theme will be loaded by the module script below

            // Load watermark preference
            loadWatermark();

            // Load right panel collapsed state
            loadRightPanelState();

            // Load all songs
            allSongs = Storage.get(STORAGE_KEYS.SONGS) || Storage.get(STORAGE_KEYS.SONGS_LEGACY) || [];

            // Get song ID from URL
            const params = new URLSearchParams(window.location.search);
            const songIdParam = params.get('songId');

            if (songIdParam !== null && songIdParam !== '') {
                // Load the specific song from URL parameter
                currentSongId = songIdParam;
                loadSongData();
                setupDragAndDrop();
                updateSearchBox();
            } else {
                // No song selected - show empty state
                currentSongId = null;
                currentSong = null;
                chartData = null;
                showEmptyState();
                
                // Force clear search box again after a brief delay (to override any browser autocomplete)
                setTimeout(() => {
                    searchBox.value = '';
                }, 50);
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.song-selector')) {
                    document.getElementById('songList').style.display = 'none';
                }
            });
        });

        // Update search box with current song
        function updateSearchBox() {
            if (currentSong) {
                document.getElementById('songSearch').value = `${currentSong.artist} - ${currentSong.song}`;
            } else {
                document.getElementById('songSearch').value = '';
            }
        }

        // Show song list dropdown
        window.showSongList = function() {
            filterSongs();
        };

        // Filter songs based on search input
        window.filterSongs = function() {
            const searchTerm = document.getElementById('songSearch').value.toLowerCase();
            const songList = document.getElementById('songList');
            
            const filteredSongs = allSongs.filter(song => {
                const searchText = `${song.artist} ${song.song}`.toLowerCase();
                return searchText.includes(searchTerm);
            });

            if (filteredSongs.length === 0) {
                songList.innerHTML = '<div style="padding: 12px; color: var(--text-secondary); text-align: center;">No songs found</div>';
                songList.style.display = 'block';
                return;
            }

            songList.innerHTML = filteredSongs.map((song, index) => {
                const actualIndex = allSongs.findIndex(s => s === song);
                return `
                    <div class="song-list-item" 
                         data-index="${actualIndex}"
                         onclick="selectSong(${actualIndex})"
                         style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid var(--primary-border); color: var(--text-primary); transition: background 0.2s;"
                         onmouseover="this.style.background='var(--primary-bg)'"
                         onmouseout="this.style.background='transparent'">
                        <div style="font-weight: 500;">${song.song}</div>
                        <div style="font-size: 0.9em; color: var(--text-secondary);">${song.artist}</div>
                    </div>
                `;
            }).join('');
            
            songList.style.display = 'block';
        };

        // Select a song from the dropdown
        window.selectSong = function(index) {
            currentSongId = index.toString();
            
            // Update URL without reloading page
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('songId', currentSongId);
            window.history.pushState({}, '', newUrl);
            
            // Hide dropdown
            document.getElementById('songList').style.display = 'none';
            
            // Load the song
            loadSongData();
            setupDragAndDrop();
            updateSearchBox();
        };

        // Load selected song from dropdown (legacy support)
        window.loadSelectedSong = function() {
            const select = document.getElementById('songSelect');
            if (!select) return;
            
            const selectedIndex = select.value;
            
            if (selectedIndex === '') {
                showEmptyState();
                return;
            }
            
            selectSong(parseInt(selectedIndex));
        };

        // Show empty state when no song is selected
        function showEmptyState() {
            currentSongId = null;
            currentSong = null;
            chartData = null;
            
            // Clear the search box
            document.getElementById('songSearch').value = '';
            
            // Recreate the drop zone with proper structure
            document.getElementById('dropZone').innerHTML = `
                <div class="drop-zone-empty" id="emptyMessage" style="display: block;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity: 0.5;">
                        <path d="M9 18V5l12-2v13"/>
                        <circle cx="6" cy="18" r="3"/>
                        <circle cx="18" cy="16" r="3"/>
                    </svg>
                    <p style="margin-top: 20px; font-size: 18px; font-weight: 500;">No Song Selected</p>
                    <p style="font-size: 14px; color: var(--text-secondary);">Please select a song from the search box above to start editing its chord chart.</p>
                </div>
                <div id="componentsContainer"></div>
            `;
            
            document.getElementById('songInfo').innerHTML = `
                <div style="padding: 20px; text-align: center; color: var(--text-secondary);">
                    Select a song to get started
                </div>
            `;
        }

        // Load and apply watermark preference
        function loadWatermark() {
            const watermark = localStorage.getItem('watermark') || 'guitar';
            if (watermark === 'drum') {
                document.body.classList.add('drum-watermark');
            } else {
                document.body.classList.remove('drum-watermark');
            }
        }

        // Toggle right panel collapsed state
        function toggleRightPanel() {
            const rightSidebar = document.getElementById('rightSidebar');
            const isCollapsed = rightSidebar.classList.toggle('collapsed');
            
            // Update toggle button icon
            const toggleBtn = rightSidebar.querySelector('.collapse-toggle svg');
            if (isCollapsed) {
                toggleBtn.innerHTML = '<polyline points="9 18 15 12 9 6"/>';
            } else {
                toggleBtn.innerHTML = '<polyline points="15 18 9 12 15 6"/>';
            }
            
            // Save state to localStorage
            localStorage.setItem('rightPanelCollapsed', isCollapsed);
        }

        // Load right panel state from localStorage
        function loadRightPanelState() {
            const isCollapsed = localStorage.getItem('rightPanelCollapsed') === 'true';
            const rightSidebar = document.getElementById('rightSidebar');
            
            if (isCollapsed) {
                rightSidebar.classList.add('collapsed');
                const toggleBtn = rightSidebar.querySelector('.collapse-toggle svg');
                toggleBtn.innerHTML = '<polyline points="9 18 15 12 9 6"/>';
            }
        }

        // Make toggleRightPanel available globally
        window.toggleRightPanel = toggleRightPanel;

        // Load song data
        function loadSongData() {
            if (currentSongId === null || currentSongId === '') {
                showEmptyState();
                return;
            }

            const songs = Storage.get(STORAGE_KEYS.SONGS) || Storage.get(STORAGE_KEYS.SONGS_LEGACY) || [];
            const songIndex = parseInt(currentSongId);

            if (isNaN(songIndex) || songIndex < 0 || songIndex >= songs.length) {
                alert('Song not found.');
                showEmptyState();
                return;
            }

            currentSong = songs[songIndex];

            // Recreate song info structure (in case showEmptyState destroyed it)
            document.getElementById('songInfo').innerHTML = `
                <h2 id="songTitle">${currentSong.song}</h2>
                <div class="artist" id="songArtist">${currentSong.artist}</div>
                <div class="meta">
                    <span id="songKey">${currentSong.key ? `Key: ${currentSong.key}` : ''}</span>
                    <span id="songTuning">${currentSong.tuning ? `Tuning: ${currentSong.tuning}` : ''}</span>
                    <span id="songDuration">${currentSong.duration ? `Duration: ${currentSong.duration}` : ''}</span>
                </div>
            `;

            // Load or create chart
            if (currentSong.chordChart) {
                chartData = currentSong.chordChart;
            } else {
                chartData = ChordChartManager.createEmptyChart();
            }

            renderComponents();
        }

        // Setup drag and drop
        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const componentItems = document.querySelectorAll('.component-item');

            // Palette items
            componentItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('componentType', item.dataset.type);
                    e.dataTransfer.effectAllowed = 'copy';
                });
            });

            // Drop zone
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');

                const componentType = e.dataTransfer.getData('componentType');
                if (componentType) {
                    addComponent(componentType);
                }
            });
        }

        // Add component
        function addComponent(type) {
            const newComponent = ChordChartManager.createComponent(type);
            chartData.components.push(newComponent);
            renderComponents();
            scheduleAutoSave();
        }

        // Render components
        function renderComponents() {
            const container = document.getElementById('componentsContainer');
            const emptyMessage = document.getElementById('emptyMessage');

            if (chartData.components.length === 0) {
                emptyMessage.style.display = 'block';
                container.innerHTML = '';
                return;
            }

            emptyMessage.style.display = 'none';

            // Auto-number components
            const numberedComponents = ChordChartManager.autoNumber(chartData.components);
            chartData.components = numberedComponents;

            container.innerHTML = '';

            numberedComponents.forEach((comp, index) => {
                const tile = createComponentTile(comp, index);
                container.appendChild(tile);
            });
        }

        // Create component tile
        function createComponentTile(comp, index) {
            const tile = document.createElement('div');
            tile.className = 'component-tile';
            tile.dataset.index = index;

            tile.innerHTML = `
                <div class="component-header">
                    <div class="drag-handle" title="Drag to reorder">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="6" x2="21" y2="6"/>
                            <line x1="3" y1="12" x2="21" y2="12"/>
                            <line x1="3" y1="18" x2="21" y2="18"/>
                        </svg>
                    </div>
                    <div class="component-title">${comp.displayName}</div>
                    <div class="component-actions">
                        <button class="icon-btn" onclick="toggleGridEditor(${index})" title="Toggle Grid Editor">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"/>
                                <rect x="14" y="3" width="7" height="7"/>
                                <rect x="3" y="14" width="7" height="7"/>
                                <rect x="14" y="14" width="7" height="7"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="moveComponentUp(${index})" title="Move Up">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="18 15 12 9 6 15"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="moveComponentDown(${index})" title="Move Down">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"/>
                            </svg>
                        </button>
                        <button class="icon-btn" onclick="deleteComponent(${index})" title="Delete">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="component-editor">
                <textarea 
                    class="component-textarea" 
                    placeholder="Enter lyrics here. Use [C], [G], [Em] for inline chords or write chords on separate line above lyrics."
                    oninput="updateComponentLyrics(${index}, this.value)"
                >${comp.lyrics}</textarea>
                    <div class="grid-editor" style="display: none;" data-index="${index}">
                        <!-- Grid editor will be populated dynamically -->
                    </div>
                </div>
                <div class="chord-format-hint">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; cursor: help;" title="Grid mode exports as chords above lyrics (or use inline [G] format)">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="16" x2="12" y2="12"/>
                        <line x1="12" y1="8" x2="12.01" y2="8"/>
                    </svg>
                </div>
            `;

            // Get the drag handle element
            const dragHandle = tile.querySelector('.drag-handle');
            
            // Only allow dragging from the drag handle
            dragHandle.addEventListener('mousedown', () => {
                tile.draggable = true;
            });
            
            tile.addEventListener('mouseup', () => {
                tile.draggable = false;
            });

            // Drag and drop for reordering
            tile.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('moveIndex', index);
                tile.classList.add('dragging');
            });

            tile.addEventListener('dragend', () => {
                tile.classList.remove('dragging');
                tile.draggable = false;
            });

            tile.addEventListener('dragover', (e) => {
                e.preventDefault();
            });

            tile.addEventListener('drop', (e) => {
                e.preventDefault();
                const moveFromIndex = parseInt(e.dataTransfer.getData('moveIndex'));
                const moveToIndex = parseInt(tile.dataset.index);

                if (moveFromIndex !== moveToIndex) {
                    moveComponent(moveFromIndex, moveToIndex);
                }
            });

            return tile;
        }

        // Update component lyrics
        window.updateComponentLyrics = function(index, lyrics) {
            chartData.components[index].lyrics = lyrics;
            scheduleAutoSave();
        };

        // Move component up
        window.moveComponentUp = function(index) {
            if (index > 0) {
                moveComponent(index, index - 1);
            }
        };

        // Move component down
        window.moveComponentDown = function(index) {
            if (index < chartData.components.length - 1) {
                moveComponent(index, index + 1);
            }
        };

        // Move component
        function moveComponent(fromIndex, toIndex) {
            const [moved] = chartData.components.splice(fromIndex, 1);
            chartData.components.splice(toIndex, 0, moved);
            renderComponents();
            scheduleAutoSave();
        }

        // Delete component
        window.deleteComponent = function(index) {
            if (confirm('Delete this component?')) {
                chartData.components.splice(index, 1);
                renderComponents();
                scheduleAutoSave();
            }
        };

        // ============================================================================
        // GRID CHORD EDITOR
        // ============================================================================

        // Toggle between text editor and grid editor
        window.toggleGridEditor = function(index) {
            const tile = document.querySelector(`.component-tile[data-index="${index}"]`);
            const textarea = tile.querySelector('.component-textarea');
            const gridEditor = tile.querySelector('.grid-editor');
            
            if (gridEditor.style.display === 'none') {
                // Show grid editor, hide textarea
                textarea.style.display = 'none';
                gridEditor.style.display = 'block';
                
                // Build grid from current lyrics
                buildGridFromLyrics(index);
            } else {
                // Show textarea, hide grid editor
                gridEditor.style.display = 'none';
                textarea.style.display = 'block';
                
                // Update lyrics from grid
                updateLyricsFromGrid(index);
            }
        };

        // Parse lyrics text into lines and characters (handles both inline and chords-above format)
        function parseLyricsToCharacters(lyrics) {
            const lines = lyrics.split('\n');
            const lyricLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // Check if this is a chord-only line
                const isChordLine = trimmedLine.length > 0 && 
                                   /^[A-G#b\/m0-9\s\-+dim aug sus maj min]+$/i.test(trimmedLine) &&
                                   trimmedLine.match(/[A-G]/);
                
                if (isChordLine && i + 1 < lines.length) {
                    // Skip chord line, process the lyrics line below
                    i++;
                    lyricLines.push(lines[i].split(''));
                } else if (line.includes('[')) {
                    // Inline format - remove chords
                    const cleanLine = line.replace(/\[([^\]]+)\]/g, '');
                    lyricLines.push(cleanLine.split(''));
                } else if (trimmedLine.length > 0) {
                    // Regular lyric line
                    lyricLines.push(line.split(''));
                } else {
                    // Empty line
                    lyricLines.push([]);
                }
            }
            
            return lyricLines;
        }

        // Parse existing chords from lyrics (supports both inline [G] and chords-above format)
        function parseExistingChords(lyrics) {
            const lines = lyrics.split('\n');
            const chordMap = []; // Array of arrays: chordMap[lyricLineIndex][charIndex] = chord
            let currentLyricLine = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trim();
                
                // Check if this is a chord-only line (contains only chords, spaces, and common chord characters)
                const isChordLine = trimmedLine.length > 0 && 
                                   /^[A-G#b\/m0-9\s\-+dim aug sus maj min]+$/i.test(trimmedLine) &&
                                   trimmedLine.match(/[A-G]/); // Must have at least one note letter
                
                if (isChordLine && i + 1 < lines.length) {
                    // This is a chord line, next line should be lyrics
                    const nextLine = lines[i + 1];
                    chordMap[currentLyricLine] = [];
                    
                    // Map chord positions to character positions - USE ORIGINAL LINE, NOT TRIMMED!
                    const chordPattern = /[A-G][#b]?(?:maj|min|m|dim|aug|sus)?[0-9]?(?:\/[A-G][#b]?)?/g;
                    let match;
                    
                    while ((match = chordPattern.exec(line)) !== null) {
                        const chord = match[0];
                        const chordPos = match.index;
                        chordMap[currentLyricLine][chordPos] = chord;
                    }
                    
                    i++; // Skip the lyrics line since we've paired it
                    currentLyricLine++;
                } else if (line.includes('[')) {
                    // Inline chord format [G]lyrics
                    chordMap[currentLyricLine] = [];
                    let charIndex = 0;
                    let j = 0;
                    
                    while (j < line.length) {
                        if (line[j] === '[') {
                            const endIndex = line.indexOf(']', j);
                            if (endIndex !== -1) {
                                const chord = line.substring(j + 1, endIndex);
                                chordMap[currentLyricLine][charIndex] = chord;
                                j = endIndex + 1;
                            } else {
                                j++;
                            }
                        } else {
                            charIndex++;
                            j++;
                        }
                    }
                    currentLyricLine++;
                } else if (trimmedLine.length > 0) {
                    // Regular lyric line with no chords
                    chordMap[currentLyricLine] = [];
                    currentLyricLine++;
                }
            }
            
            return chordMap;
        }

        // Build grid editor UI - Simple character-by-character system
        function buildGridFromLyrics(index) {
            const comp = chartData.components[index];
            const gridEditor = document.querySelector(`.grid-editor[data-index="${index}"]`);
            
            // Parse lyrics into individual lines, preserving exact spacing
            const lines = comp.lyrics.split('\n');
            
            // Synchronize gridRows with current lyrics while preserving row types
            if (!comp.gridRows) {
                // First time: create new grid
                comp.gridRows = [];
                lines.forEach((line) => {
                    const chars = line.split('');
                    comp.gridRows.push({
                        type: 'generic',
                        chars: chars.length > 0 ? chars : [' ']
                    });
                });
            } else if (comp.gridRows.length !== lines.length) {
                // Number of lines changed: add or remove rows while preserving existing types
                if (lines.length > comp.gridRows.length) {
                    // Lines added: add new generic rows at the end
                    const newRowCount = lines.length - comp.gridRows.length;
                    for (let i = 0; i < newRowCount; i++) {
                        comp.gridRows.push({
                            type: 'generic',
                            chars: [' ']
                        });
                    }
                } else {
                    // Lines removed: trim rows from the end
                    comp.gridRows = comp.gridRows.slice(0, lines.length);
                }
                
                // Update all row contents with current line text
                lines.forEach((line, i) => {
                    const chars = line.split('');
                    comp.gridRows[i].chars = chars.length > 0 ? chars : [' '];
                    // Preserve type: don't modify comp.gridRows[i].type
                });
            } else {
                // Same number of lines: just update content, preserve types
                lines.forEach((line, i) => {
                    const chars = line.split('');
                    comp.gridRows[i].chars = chars.length > 0 ? chars : [' '];
                    // Preserve type: don't modify comp.gridRows[i].type
                });
            }
            
            if (comp.gridRows.length === 0) {
                // Add one empty row if none exist
                comp.gridRows.push({
                    type: 'generic',
                    chars: [' ']
                });
            }
            
            // Initialize or sync metadata with current gridRows
            if (!comp.lyricsMetadata) {
                // First time: initialize metadata based on current gridRows
                comp.lyricsMetadata = comp.gridRows.map(row => ({ type: row.type || 'generic' }));
            } else if (comp.lyricsMetadata.length !== comp.gridRows.length) {
                // Sync metadata length with current rows
                const newMetadata = [];
                comp.gridRows.forEach((row, idx) => {
                    // Preserve existing metadata if available, otherwise use row type
                    newMetadata.push(comp.lyricsMetadata[idx] || { type: row.type || 'generic' });
                });
                comp.lyricsMetadata = newMetadata;
            }
            
            // Find the longest line and add 10 extra cells for padding
            const maxLength = Math.max(...comp.gridRows.map(row => row.chars.length), 10) + 10;
            
            // Build controls
            let html = `
                <div class="grid-controls">
                    <button class="btn btn-secondary btn-sm" onclick="addGridRow(${index})">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Add Row
                    </button>
                    <button class="btn btn-secondary btn-sm" id="toggleChordBtn${index}" onclick="setSelectedRowsType(${index}, 'chord')" disabled>
                        Set as Chord (C)
                    </button>
                    <button class="btn btn-secondary btn-sm" id="toggleLyricBtn${index}" onclick="setSelectedRowsType(${index}, 'lyric')" disabled>
                        Set as Lyric (L)
                    </button>
                    <button class="btn btn-danger btn-sm" id="deleteRowBtn${index}" onclick="deleteSelectedRows(${index})" disabled>
                        Delete Selected
                    </button>
                </div>
                <table class="grid-editor-table">
            `;
            
            comp.gridRows.forEach((row, rowIndex) => {
                const rowType = row.type || 'generic';
                let chars = [...row.chars];
                
                // Pad to maxLength
                while (chars.length < maxLength) {
                    chars.push(' ');
                }
                
                // Determine input behavior based on type
                const maxLengthAttr = rowType === 'lyric' ? 'maxlength="1"' : '';
                const rowClass = row.selected ? 'grid-row-selected' : '';
                
                // Indicator label
                let indicator = '−'; // Generic
                if (rowType === 'chord') indicator = 'C';
                if (rowType === 'lyric') indicator = 'L';
                
                html += `<tr class="${rowClass}">`;
                
                // Indicator cell (clickable for selection)
                html += `<td class="grid-indicator-cell" onclick="toggleRowSelection(${index}, ${rowIndex})">
                    <div class="row-indicator row-indicator-${rowType}">${indicator}</div>
                </td>`;
                
                // Content cells
                chars.forEach((char, charIndex) => {
                    const cellClass = 'grid-content-cell';
                    
                    html += `<td class="${cellClass}">
                        <input type="text" 
                               class="grid-cell-input" 
                               value="${char}" 
                               data-row="${rowIndex}" 
                               data-char="${charIndex}"
                               ${maxLengthAttr}
                               onchange="updateGridCell(${index}, ${rowIndex}, ${charIndex}, this.value)"
                               onfocus="updateControlButtonStates(${index})"
                               placeholder="·">
                    </td>`;
                });
                
                html += '</tr>';
            });
            
            html += '</table>';
            gridEditor.innerHTML = html;
            
            // Add keyboard navigation and copy/paste support
            setupGridKeyboardNavigation(index);
            updateControlButtonStates(index);
        }

        // Setup keyboard navigation for grid
        function setupGridKeyboardNavigation(compIndex) {
            const gridEditor = document.querySelector(`.grid-editor[data-index="${compIndex}"]`);
            if (!gridEditor) return;
            
            const allInputs = gridEditor.querySelectorAll('.grid-chord-input, .grid-lyric-input');
            
            allInputs.forEach(input => {
                // Arrow key navigation
                input.addEventListener('keydown', (e) => {
                    const currentRow = parseInt(input.dataset.row);
                    const currentChar = parseInt(input.dataset.char);
                    
                    let targetInput = null;
                    
                    switch(e.key) {
                        case 'ArrowRight':
                            e.preventDefault();
                            // Move to next cell in same row
                            targetInput = gridEditor.querySelector(
                                `input[data-row="${currentRow}"][data-char="${currentChar + 1}"]`
                            );
                            break;
                            
                        case 'ArrowLeft':
                            e.preventDefault();
                            // Move to previous cell in same row
                            targetInput = gridEditor.querySelector(
                                `input[data-row="${currentRow}"][data-char="${currentChar - 1}"]`
                            );
                            break;
                            
                        case 'ArrowDown':
                            e.preventDefault();
                            // Move to next row, same column
                            targetInput = gridEditor.querySelector(
                                `input[data-row="${currentRow + 1}"][data-char="${currentChar}"]`
                            );
                            break;
                            
                        case 'ArrowUp':
                            e.preventDefault();
                            // Move to previous row, same column
                            targetInput = gridEditor.querySelector(
                                `input[data-row="${currentRow - 1}"][data-char="${currentChar}"]`
                            );
                            break;
                            
                        case 'Tab':
                            e.preventDefault();
                            // Move to next cell (wrap to next row if needed)
                            const nextCharInput = gridEditor.querySelector(
                                `input[data-row="${currentRow}"][data-char="${currentChar + 1}"]`
                            );
                            if (nextCharInput) {
                                targetInput = nextCharInput;
                            } else {
                                // Wrap to next row
                                targetInput = gridEditor.querySelector(
                                    `input[data-row="${currentRow + 1}"][data-char="0"]`
                                );
                            }
                            break;
                            
                        case 'Enter':
                            e.preventDefault();
                            // Move down one row, same column
                            targetInput = gridEditor.querySelector(
                                `input[data-row="${currentRow + 1}"][data-char="${currentChar}"]`
                            );
                            break;
                    }
                    
                    if (targetInput) {
                        targetInput.focus();
                        targetInput.select();
                    }
                });
                
                // Copy/Paste support
                input.addEventListener('copy', (e) => {
                    const selection = getGridSelection(gridEditor);
                    if (selection.length > 1) {
                        e.preventDefault();
                        const tsv = selectionToTSV(selection);
                        e.clipboardData.setData('text/plain', tsv);
                    }
                });
                
                input.addEventListener('paste', (e) => {
                    e.preventDefault();
                    const text = e.clipboardData.getData('text/plain');
                    pasteIntoGrid(gridEditor, input, text, compIndex);
                });
            });
        }

        // Get selected grid cells (for copy)
        function getGridSelection(gridEditor) {
            const selection = [];
            const selectedInputs = gridEditor.querySelectorAll('.grid-chord-input:focus, .grid-lyric-input:focus');
            // For now, just return single cell (multi-select would need additional UI)
            selectedInputs.forEach(input => {
                selection.push({
                    line: parseInt(input.dataset.line),
                    char: parseInt(input.dataset.char),
                    value: input.value,
                    isChord: input.classList.contains('grid-chord-input')
                });
            });
            return selection;
        }

        // Convert selection to TSV (Tab-Separated Values)
        function selectionToTSV(selection) {
            // For now, just return single value
            return selection.length > 0 ? selection[0].value : '';
        }

        // Paste data into grid
        function pasteIntoGrid(gridEditor, startInput, text, compIndex) {
            const startRow = parseInt(startInput.dataset.row);
            const startChar = parseInt(startInput.dataset.char);
            
            // Split by lines (rows)
            const rows = text.split(/\r?\n/);
            
            rows.forEach((row, rowOffset) => {
                const cells = row.split('\t'); // Split by tabs (columns)
                
                cells.forEach((cellValue, colOffset) => {
                    const targetRow = startRow + rowOffset;
                    const targetChar = startChar + colOffset;
                    
                    const targetInput = gridEditor.querySelector(
                        `input[data-row="${targetRow}"][data-char="${targetChar}"]`
                    );
                    
                    if (targetInput) {
                        const maxLength = targetInput.getAttribute('maxlength');
                        targetInput.value = maxLength ? cellValue.slice(0, 1) : cellValue;
                        
                        // Trigger change event
                        updateGridCell(compIndex, targetRow, targetChar, targetInput.value);
                    }
                });
            });
        }

        // Update cell in grid
        window.updateGridCell = function(compIndex, rowIndex, charIndex, value) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows[rowIndex]) return;
            
            // Update the character in the row
            if (!comp.gridRows[rowIndex].chars) {
                comp.gridRows[rowIndex].chars = [];
            }
            comp.gridRows[rowIndex].chars[charIndex] = value || ' ';
        };

        // Toggle row selection
        window.toggleRowSelection = function(compIndex, rowIndex) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows[rowIndex]) return;
            
            comp.gridRows[rowIndex].selected = !comp.gridRows[rowIndex].selected;
            
            // Rebuild to show selection
            buildGridFromLyrics(compIndex);
        };

        // Set selected rows to a specific type
        window.setSelectedRowsType = function(compIndex, type) {
            const comp = chartData.components[compIndex];
            let hasSelection = false;
            
            comp.gridRows.forEach(row => {
                if (row.selected) {
                    row.type = type;
                    hasSelection = true;
                }
            });
            
            if (hasSelection) {
                // Rebuild grid
                buildGridFromLyrics(compIndex);
            }
        };

        // Delete selected rows
        window.deleteSelectedRows = function(compIndex) {
            const comp = chartData.components[compIndex];
            const selectedCount = comp.gridRows.filter(r => r.selected).length;
            
            if (selectedCount === 0) return;
            
            if (comp.gridRows.length <= selectedCount) {
                alert('Cannot delete all rows. At least one row must remain.');
                return;
            }
            
            // Remove selected rows
            comp.gridRows = comp.gridRows.filter(row => !row.selected);
            
            // Rebuild grid
            buildGridFromLyrics(compIndex);
        };

        // Add new row
        window.addGridRow = function(compIndex) {
            const comp = chartData.components[compIndex];
            if (!comp.gridRows) {
                comp.gridRows = [];
            }
            
            comp.gridRows.push({
                type: 'generic',
                chars: [' '],
                selected: false
            });
            
            // Rebuild grid
            buildGridFromLyrics(compIndex);
        };

        // Update control button states based on selection
        window.updateControlButtonStates = function(compIndex) {
            const comp = chartData.components[compIndex];
            if (!comp || !comp.gridRows) return;
            
            const hasSelection = comp.gridRows.some(row => row.selected);
            
            // Enable/disable buttons
            const chordBtn = document.getElementById(`toggleChordBtn${compIndex}`);
            const lyricBtn = document.getElementById(`toggleLyricBtn${compIndex}`);
            const deleteBtn = document.getElementById(`deleteRowBtn${compIndex}`);
            
            if (chordBtn) chordBtn.disabled = !hasSelection;
            if (lyricBtn) lyricBtn.disabled = !hasSelection;
            if (deleteBtn) deleteBtn.disabled = !hasSelection;
        };

        // Legacy functions (redirects)
        window.toggleGridRowType = function(compIndex, rowIndex) {
            toggleRowSelection(compIndex, rowIndex);
        };

        window.deleteGridRow = function(compIndex, rowIndex) {
            const comp = chartData.components[compIndex];
            comp.gridRows[rowIndex].selected = true;
            deleteSelectedRows(compIndex);
        };

        window.updateChordInGrid = function(compIndex, lineIndex, charIndex, chord) {
            updateGridCell(compIndex, lineIndex, charIndex, chord);
        };

        window.updateLyricInGrid = function(compIndex, lineIndex, charIndex, newChar) {
            updateGridCell(compIndex, lineIndex, charIndex, newChar);
        };

        // Convert grid back to chords-above-lyrics format (DEFAULT)
        // Convert grid back to text format
        function updateLyricsFromGrid(index) {
            const comp = chartData.components[index];
            const gridEditor = document.querySelector(`.grid-editor[data-index="${index}"]`);
            
            if (!comp.gridRows) return;
            
            const newLines = [];
            
            // Read all inputs from the grid
            comp.gridRows.forEach((row, rowIndex) => {
                const inputs = gridEditor.querySelectorAll(`input[data-row="${rowIndex}"]`);
                
                if (inputs.length === 0) return;
                
                // Build line content character by character
                let lineContent = '';
                inputs.forEach(input => {
                    const val = input.value;
                    // If empty input, treat as space
                    lineContent += val || ' ';
                });
                
                // Find the last non-space character position
                let lastNonSpace = -1;
                for (let i = lineContent.length - 1; i >= 0; i--) {
                    if (lineContent[i] !== ' ') {
                        lastNonSpace = i;
                        break;
                    }
                }
                
                // Trim to last non-space character (preserve all spaces before that point)
                // If entire line is spaces, keep just one space
                const trimmedContent = lastNonSpace >= 0 
                    ? lineContent.substring(0, lastNonSpace + 1)
                    : (lineContent.length > 0 ? ' ' : '');
                
                // Update row chars array with trimmed content
                row.chars = trimmedContent.split('');
                
                // Add to output
                newLines.push(trimmedContent);
            });
            
            // Update component lyrics
            comp.lyrics = newLines.join('\n');
            
            // Save row type metadata for accurate chord/lyric detection
            comp.lyricsMetadata = comp.gridRows.map(row => ({ type: row.type || 'generic' }));
            
            const textarea = document.querySelector(`.component-tile[data-index="${index}"] .component-textarea`);
            if (textarea) {
                textarea.value = comp.lyrics;
            }
            
            scheduleAutoSave();
        }

        // Clear chart
        window.clearChart = function() {
            if (confirm('Clear entire chart? This cannot be undone.')) {
                chartData = ChordChartManager.createEmptyChart();
                renderComponents();
                saveChart();
            }
        };

        // Schedule auto-save
        function scheduleAutoSave() {
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }
            autoSaveTimer = setTimeout(() => {
                saveChart();
            }, 2000); // Auto-save after 2 seconds of inactivity
        }

        // Save chart
        window.saveChart = function() {
            const songs = Storage.get(STORAGE_KEYS.SONGS) || Storage.get(STORAGE_KEYS.SONGS_LEGACY) || [];
            const songIndex = parseInt(currentSongId);

            if (songIndex >= 0 && songIndex < songs.length) {
                songs[songIndex].chordChart = chartData;
                Storage.set(STORAGE_KEYS.SONGS, songs);
                Storage.set(STORAGE_KEYS.SONGS_LEGACY, songs); // Backup

                // Show save indicator
                const indicator = document.getElementById('saveIndicator');
                indicator.classList.add('show');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }
        };

        // Export chart
        window.exportChart = function() {
            const exportData = {
                song: currentSong.song,
                artist: currentSong.artist,
                key: currentSong.key,
                tuning: currentSong.tuning,
                chart: chartData
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${currentSong.artist} - ${currentSong.song} - Chord Chart.json`;
            link.click();
            URL.revokeObjectURL(url);
        };

        // Open print modal
        // Toggle print modal (open/close)
        window.togglePrintModal = function() {
            const modal = document.getElementById('printModal');
            if (modal.classList.contains('show')) {
                closePrintModal();
            } else {
                openPrintModal();
            }
        };

        // Open print modal
        window.openPrintModal = function() {
            if (chartData.components.length === 0) {
                alert('Add components to your chord chart before printing.');
                return;
            }

            document.getElementById('printModal').classList.add('show');
            document.getElementById('autoscrollControls').classList.add('show');
            loadPreferredSpeed(); // Load saved speed for this song
            updatePrintPreview();
        };

        // Close print modal
        window.closePrintModal = function() {
            document.getElementById('printModal').classList.remove('show');
            document.getElementById('autoscrollControls').classList.remove('show');
            stopAutoscroll();
        };

        // ============================================================================
        // AUTOSCROLL FUNCTIONALITY
        // ============================================================================
        
        let autoscrollActive = false;
        let autoscrollInterval = null;
        let scrollSpeed = 1.0;
        const BASE_SCROLL_SPEED = 0.5;
        let accumulatedScroll = 0; // For fractional scrolling

        // Toggle autoscroll
        window.toggleAutoscroll = function() {
            if (autoscrollActive) {
                stopAutoscroll();
            } else {
                startAutoscroll();
            }
        };

        function startAutoscroll() {
            autoscrollActive = true;
            accumulatedScroll = 0; // Reset accumulator
            const playBtn = document.getElementById('autoscrollPlayBtn');
            
            playBtn.classList.add('playing');
            playBtn.querySelector('svg').innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
            
            const modalBody = document.querySelector('#printModal .modal-body');
            
            autoscrollInterval = setInterval(() => {
                if (modalBody) {
                    // Accumulate fractional scroll amounts
                    accumulatedScroll += BASE_SCROLL_SPEED * scrollSpeed;
                    
                    // Only scroll whole pixels
                    const scrollAmount = Math.floor(accumulatedScroll);
                    if (scrollAmount > 0) {
                        modalBody.scrollTop += scrollAmount;
                        accumulatedScroll -= scrollAmount; // Keep the fractional remainder
                    }
                    
                    // Auto-stop at bottom
                    if (modalBody.scrollTop >= modalBody.scrollHeight - modalBody.clientHeight) {
                        stopAutoscroll();
                    }
                }
            }, 20);
        }

        function stopAutoscroll() {
            autoscrollActive = false;
            const playBtn = document.getElementById('autoscrollPlayBtn');
            
            if (playBtn) {
                playBtn.classList.remove('playing');
                playBtn.querySelector('svg').innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';
            }
            
            if (autoscrollInterval) {
                clearInterval(autoscrollInterval);
                autoscrollInterval = null;
            }
        }

        // Adjust scroll speed
        // Adjust speed (called by +/- buttons)
        window.adjustSpeed = function(delta) {
            const newSpeed = Math.max(0.1, Math.min(3, scrollSpeed + delta));
            setScrollSpeed(parseFloat(newSpeed.toFixed(1)));
        };

        // Set scroll speed
        window.setScrollSpeed = function(speed) {
            scrollSpeed = speed;
            document.getElementById('speedValue').textContent = speed.toFixed(1) + 'x';
        };

        // Save preferred scroll speed for current song
        window.savePreferredSpeed = function() {
            if (!chartData || !currentSong) {
                alert('Please load a song first.');
                return;
            }

            // Save speed to chartData
            chartData.preferredScrollSpeed = scrollSpeed;
            
            // Save to localStorage
            saveChart();
            
            // Update button visual
            const btn = document.getElementById('saveSpeedBtn');
            const icon = document.getElementById('saveSpeedIcon');
            const text = document.getElementById('saveSpeedText');
            
            // Fill the bookmark icon
            icon.setAttribute('fill', 'var(--primary-light)');
            text.textContent = `Saved (${scrollSpeed.toFixed(1)}x)`;
            btn.style.borderColor = 'var(--primary-light)';
            
            // Show temporary feedback
            const originalBg = btn.style.background;
            btn.style.background = 'var(--primary-color)';
            setTimeout(() => {
                btn.style.background = originalBg;
            }, 500);
        };

        // Load preferred scroll speed when opening Performance View
        function loadPreferredSpeed() {
            if (chartData && chartData.preferredScrollSpeed) {
                setScrollSpeed(chartData.preferredScrollSpeed);
                
                // Update button visual to show saved state
                const btn = document.getElementById('saveSpeedBtn');
                const icon = document.getElementById('saveSpeedIcon');
                const text = document.getElementById('saveSpeedText');
                
                icon.setAttribute('fill', 'var(--primary-light)');
                text.textContent = `Saved (${chartData.preferredScrollSpeed.toFixed(1)}x)`;
                btn.style.borderColor = 'var(--primary-light)';
            } else {
                // Reset button to default state
                const btn = document.getElementById('saveSpeedBtn');
                const icon = document.getElementById('saveSpeedIcon');
                const text = document.getElementById('saveSpeedText');
                
                icon.setAttribute('fill', 'none');
                text.textContent = 'Save Speed';
                btn.style.borderColor = '';
            }
        }

        // Keyboard controls for autoscroll
        document.addEventListener('keydown', (e) => {
            // Only work when print modal is open and on performance view
            const modal = document.getElementById('printModal');
            const performanceView = document.getElementById('performanceView');
            
            if (!modal.classList.contains('show') || performanceView.style.display === 'none') {
                return;
            }
            
            // Prevent default if we're handling the key
            const handled = ['Space', 'ArrowLeft', 'ArrowRight'].includes(e.code);
            
            // Don't interfere if user is typing in an input/textarea
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (handled) {
                e.preventDefault();
            }
            
            // Spacebar: Toggle play/stop
            if (e.code === 'Space') {
                toggleAutoscroll();
            }
            
            // Left Arrow: Decrease speed
            if (e.code === 'ArrowLeft') {
                const newSpeed = Math.max(0.5, scrollSpeed - 0.1);
                setScrollSpeed(parseFloat(newSpeed.toFixed(1)));
            }
            
            // Right Arrow: Increase speed
            if (e.code === 'ArrowRight') {
                const newSpeed = Math.min(3, scrollSpeed + 0.1);
                setScrollSpeed(parseFloat(newSpeed.toFixed(1)));
            }
        });

        // ============================================================================
        // UPDATE PRINT PREVIEW
        // ============================================================================

        // Update print preview
        window.updatePrintPreview = function() {
            const fontSize = document.getElementById('fontSize').value;
            const scaleToFit = document.getElementById('scaleToFit').checked;
            document.getElementById('fontSizeValue').textContent = fontSize + 'px';

            const options = {
                fontSize: parseInt(fontSize),
                scaleToFit
            };

            // Update both views
            const performanceHtml = ChordChartManager.generatePerformanceView(chartData, currentSong, options);
            document.getElementById('performanceView').innerHTML = performanceHtml;

            const printHtml = ChordChartManager.generatePrintView(chartData, currentSong, options);
            document.getElementById('printPreview').innerHTML = printHtml;
        };

        // Switch between performance and print view tabs
        window.switchViewTab = function(view) {
            const performanceView = document.getElementById('performanceView');
            const printPreview = document.getElementById('printPreview');
            const autoscrollControls = document.getElementById('autoscrollControls');
            const tabs = document.querySelectorAll('.tab-button');

            if (view === 'performance') {
                performanceView.style.display = 'block';
                printPreview.style.display = 'none';
                autoscrollControls.classList.add('show');
                tabs[0].classList.add('active');
                tabs[1].classList.remove('active');
            } else {
                performanceView.style.display = 'none';
                printPreview.style.display = 'block';
                autoscrollControls.classList.remove('show');
                stopAutoscroll(); // Stop scrolling when switching away
                tabs[0].classList.remove('active');
                tabs[1].classList.add('active');
            }
        };
    </script>

    <!-- Theme Management Script (Inline for file:// compatibility) -->
    <script>
        // Synchronized theme management using localStorage
        function loadTheme() {
            const savedTheme = localStorage.getItem('bandOrganizerTheme') || 'grey';
            applyTheme(savedTheme);
            const themeSelector = document.getElementById('themeSelector');
            if (themeSelector) {
                themeSelector.value = savedTheme;
            }
            return savedTheme;
        }
        
        function applyTheme(theme) {
            if (theme === 'grey') {
                document.body.removeAttribute('data-theme');
            } else {
                document.body.setAttribute('data-theme', theme);
            }
        }
        
        // Change theme and save to localStorage
        window.changeTheme = function(theme) {
            console.log('Changing theme to:', theme);
            localStorage.setItem('bandOrganizerTheme', theme);
            applyTheme(theme);
            console.log('Body data-theme attribute:', document.body.getAttribute('data-theme'));
        };
        
        // Load theme immediately
        loadTheme();
    </script>
</body>
</html>

