<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Song Manager</title>
    <meta name="app-version" content="v2.3.0">
    <!-- PWA Manifest (disabled for file:// protocol - only works on web server) -->
    <!-- <link rel="manifest" href="./manifest.json"> -->
    <meta name="theme-color" content="#d84315">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Band Manager">
    <link rel="manifest" href="manifest.json">
    <!-- Performance: Resource Hints -->
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="preconnect" href="//fonts.googleapis.com">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23d84315' stroke-width='2'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>">
    <link rel="stylesheet" href="./css/themes.css">
    <link rel="stylesheet" href="./css/layout.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            min-width: 320px; /* Prevent extreme narrow layouts */
        }

        /* Compact stats in header */
        .compact-stats {
            display: flex;
            gap: 12px;
            padding: 4px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
        }

        .compact-stats .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .compact-stats .stat-label {
            color: var(--text-tertiary);
            font-size: 10px;
            text-transform: uppercase;
        }

        .compact-stats .stat-value {
            color: var(--primary-light);
            font-weight: 600;
            font-size: 14px;
        }

        /* Bulk actions sticky footer */
        .bulk-actions-footer {
            position: sticky;
            bottom: 0;
            background: var(--primary-dark);
            border-top: 2px solid var(--primary-light);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 -2px 10px var(--primary-glow);
            z-index: 100;
        }

        .bulk-actions-footer #selectedCount {
            color: var(--primary-light);
            font-weight: 600;
            margin-right: auto;
        }

        /* Table container fills center pane */
        .center-pane .table-container {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Background watermark - Guitar */
        body::before {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.15'%3E%3Ccircle cx='12' cy='17' r='4.5'/%3E%3Cline x1='12' y1='12.5' x2='12' y2='2'/%3E%3Cline x1='9' y1='5' x2='15' y2='5'/%3E%3Cline x1='9' y1='8' x2='15' y2='8'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s ease;
        }

        /* Background watermark - Drum (hidden by default) */
        body::after {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' fill='none' stroke='%23ffffff' stroke-width='1.5' opacity='0.15'%3E%3Ccircle cx='23' cy='17' r='4.5'/%3E%3Cline x1='16' y1='21.5' x2='16' y2='2'/%3E%3Cline x1='11' y1='5' x2='21' y2='5'/%3E%3Cline x1='18' y1='8' x2='28' y2='8'/%3E%3Cline x1='21' y1='10' x2='26' y2='10'/%3E%3Cline x1='7' y1='12.5' x2='18' y2='12.5'/%3E%3Cline x1='30' y1='12.5' x2='30' y2='2'/%3E%3Cline x1='25' y1='5' x2='35' y2='5'/%3E%3Cline x1='27' y1='8' x2='33' y2='8'/%3E%3Cline x1='26' y1='14' x2='31' y2='14'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show drum watermark when active */
        body.drum-watermark::before {
            opacity: 0;
        }

        body.drum-watermark::after {
            opacity: 1;
        }

        /* BlackDoubt watermark overlay (hidden by default) */
        .blackdoubt-watermark-overlay {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.12'%3E%3Cpath d='M 20 3 L 37 20 L 20 37 L 3 20 Z' stroke='%23ffffff' fill='none' stroke-width='1.5'/%3E%3Ccircle cx='20' cy='20' r='13' stroke='%23ffffff' fill='none' stroke-width='1.5'/%3E%3Ctext x='20' y='20' font-size='20' font-family='serif' text-anchor='middle' dominant-baseline='central' fill='%23ffffff' stroke='none'%3E%F0%9D%94%85%3C/text%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show BlackDoubt watermark when active */
        body.blackdoubt-watermark::before,
        body.blackdoubt-watermark::after {
            opacity: 0;
        }

        body.blackdoubt-watermark .blackdoubt-watermark-overlay {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            padding: 5px 10px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            text-shadow: 0 0 20px var(--primary-glow);
            margin: 2px 0;
            font-size: 1.3em;
            letter-spacing: 1px;
        }

        .nav-links {
            text-align: center;
            margin-bottom: 4px;
        }

        .nav-links a {
            color: var(--primary-light);
            text-decoration: none;
            margin: 0 15px;
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid var(--primary-border);
            display: inline-block;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-links a:hover {
            background: var(--primary-bg);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .controls {
            background: rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 4px 8px;
            border-radius: 6px;
            margin-bottom: 4px;
            box-shadow: 0 2px 10px var(--primary-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .button-group {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-bottom: 4px;
        }

        button {
            padding: 4px 10px;
            border: none;
            font-size: 0.85em;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: var(--primary-dark);
            color: var(--primary-light);
            border: 2px solid var(--primary-light);
        }

        .btn-primary:hover {
            background: var(--primary-darker);
            color: var(--primary-lighter);
            transform: translateY(-2px);
        }

        .btn-success {
            background: var(--primary-dark);
            color: var(--primary-light);
            border: 2px solid var(--primary-light);
        }

        .btn-success:hover {
            background: var(--primary-darker);
            color: var(--primary-lighter);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #5c1d0a;
            color: #ff6b3d;
            border: 2px solid #ff6b3d;
        }

        .btn-danger:hover {
            background: #7a2710;
            color: #ffa580;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2a2d33;
            color: #c1c7d0;
            border: 2px solid #c1c7d0;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 200px;
        }

        .dropdown-menu button {
            display: block;
            width: 100%;
            padding: 12px 16px;
            background: none;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95em;
        }

        .dropdown-menu button:hover {
            background: var(--primary-color);
            color: white;
        }

        .dropdown-menu button:first-child {
            border-radius: 6px 6px 0 0;
        }

        .dropdown-menu button:last-child {
            border-radius: 0 0 6px 6px;
        }

        .dropdown-menu button svg {
            opacity: 0.7;
        }

        .dropdown-menu button:hover svg {
            opacity: 1;
        }

        .btn-secondary:hover {
            background: #3a3e47;
            color: #e5e9f0;
            transform: translateY(-2px);
        }

        input[type="file"] {
            display: none;
        }
        
        /* Import Option Boxes */
        .import-option {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--primary-border);
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 15px;
            min-height: 80px;
        }

        .import-option:hover {
            border-color: var(--primary-color);
            background: rgba(var(--primary-color-rgb, 255, 107, 61), 0.1);
        }

        @media (max-width: 768px) {
            .import-option {
                padding: 16px;
                min-height: 88px;
                margin-bottom: 12px;
            }
            
            #importModal .modal-content {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
        }

        .search-box {
            width: 100%;
            padding: 6px 10px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            font-size: 0.85em;
            color: #e0e0e0;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1a1a1a;
            border: 2px solid var(--primary-border);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s ease;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: var(--primary-bg);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-type {
            font-size: 0.75em;
            color: var(--primary-color);
            text-transform: uppercase;
            font-weight: 600;
            margin-right: 8px;
        }

        .autocomplete-text {
            color: #e0e0e0;
        }

        .autocomplete-count {
            float: right;
            font-size: 0.85em;
            color: #999;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .table-container {
            background: 
                radial-gradient(circle at top left, var(--primary-bg) 0%, transparent 40%),
                radial-gradient(circle at top right, var(--primary-bg) 0%, transparent 40%),
                radial-gradient(circle at bottom left, var(--primary-bg) 0%, transparent 40%),
                radial-gradient(circle at bottom right, var(--primary-bg) 0%, transparent 40%),
                rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            overflow-x: auto;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            box-shadow: 0 4px 20px var(--primary-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Performance: Enable GPU acceleration for smooth scrolling */
            will-change: scroll-position;
            transform: translateZ(0);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
        }

        thead {
            background: var(--primary-bg);
            border-bottom: 2px solid var(--primary-border);
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: var(--primary-color);
            text-shadow: 0 0 8px var(--primary-glow);
            background: rgba(0, 0, 0, 0.95); /* Opaque background for readability */
        }

        tbody {
            background: transparent;
        }

        tbody tr {
            background: rgba(40, 40, 40, 0.5);
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(60, 60, 60, 0.3);
        }

        /* Table Density Modes */
        .table-compact th {
            padding: 8px 10px;
            font-size: 0.85em;
        }
        
        .table-compact td {
            padding: 6px 10px;
            font-size: 0.9em;
            line-height: 1.3;
        }

        .table-spacious th {
            padding: 18px 20px;
            font-size: 1.05em;
        }
        
        .table-spacious td {
            padding: 16px 20px;
            font-size: 1.05em;
            line-height: 1.8;
        }

        tr:hover {
            background: var(--primary-bg) !important;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 16px;
            min-width: 32px;
        }

        .action-buttons {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #000000;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px var(--primary-glow);
            border: 1px solid var(--primary-border);
        }

        .modal-content.large {
            max-width: 95%;
            width: 95%;
            max-height: 95vh;
            resize: both;
            overflow: auto;
            min-width: 800px;
            min-height: 500px;
            position: relative;
        }
        
        /* Mobile: remove min-width constraint on large modals */
        @media (max-width: 768px) {
            .modal-content.large {
                min-width: 0;
                width: 95vw;
                min-height: 300px;
            }
            
            /* Make mobile menu header fully opaque to cover scrolling content */
            .mobile-menu-header {
                background: #000000 !important; /* Solid black background */
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                z-index: 100 !important; /* Ensure it stays above all content */
                position: sticky;
                top: 0;
            }
        }

        .modal-content.large::after {
            content: '‚á≤';
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 20px;
            color: var(--primary-glow);
            pointer-events: none;
            text-shadow: 0 0 5px var(--primary-glow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--primary-border);
        }

        .modal-header h2 {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0a0a0a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 10px var(--primary-glow));
        }

        .close {
            cursor: pointer;
            font-size: 28px;
            color: #e0e0e0;
            transition: all 0.3s ease;
        }

        .close:hover {
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--primary-light);
            font-weight: 500;
        }

        /* Themed select dropdowns */
        select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: var(--primary-light);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover {
            border-color: var(--primary-color);
            background: rgba(255, 107, 61, 0.1);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 107, 61, 0.3);
        }

        select option {
            background: #1a1a1a;
            color: var(--primary-light);
            padding: 10px;
        }

        select option:hover {
            background: var(--primary-bg);
        }

        input[type="text"],
        input[type="url"],
        textarea {
            width: 100%;
            padding: 10px 15px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="url"]:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        textarea {
            resize: vertical;
            min-height: 60px;
        }

        .import-preview {
            max-height: 60vh;
            overflow: auto;
            margin-top: 20px;
        }

        .import-preview table {
            min-width: 100%;
            white-space: nowrap;
        }

        .import-preview td, .import-preview th {
            white-space: normal;
        }

        .import-item {
            background: #000000;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
        }

        .import-item.update {
            border-left-color: #f59e0b;
        }

        .import-item.new {
            border-left-color: #10b981;
        }

        .import-item h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .import-changes {
            font-size: 14px;
            margin-top: 10px;
        }

        .change-line {
            padding: 5px;
            margin: 2px 0;
        }

        .change-old {
            color: #ef4444;
            text-decoration: line-through;
        }

        .change-new {
            color: #10b981;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Custom styled checkboxes for column visibility */
        #columnVisibilityPanel input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-color);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            background: transparent;
            transition: all 0.2s;
        }

        #columnVisibilityPanel input[type="checkbox"]:hover {
            background: var(--primary-bg);
        }

        #columnVisibilityPanel input[type="checkbox"]:checked {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        #columnVisibilityPanel input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 14px;
            font-weight: bold;
        }

        #columnVisibilityPanel label {
            color: #e0e0e0;
            transition: color 0.2s;
        }

        #columnVisibilityPanel label:hover {
            color: var(--primary-light);
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #6b7280;
            font-size: 18px;
        }

        .stats {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .stat-card {
            background: #000000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            border: 1px solid var(--primary-border);
            flex: 1;
            min-width: 130px;
        }

        .stat-card h3 {
            background: linear-gradient(135deg, var(--primary-color) 0%, #4a4a4a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .stat-card p {
            font-size: 20px;
            font-weight: bold;
            color: #e0e0e0;
        }

        /* Inline editing styles */
        .editable-cell {
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .editable-cell:hover {
            background: rgba(255, 255, 255, 0.05);
            outline: 1px solid var(--primary-border);
        }

        .editable-cell.editing {
            padding: 0 !important;
            background: rgba(0, 0, 0, 0.3);
        }

        .inline-input {
            width: 100%;
            background: #1a1a1a;
            border: 2px solid var(--primary-color);
            color: #e0e0e0;
            padding: 8px;
            font-family: inherit;
            font-size: inherit;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .inline-input:focus {
            outline: none;
            border-color: var(--primary-light);
        }

        .inline-select {
            width: 100%;
            background: #1a1a1a;
            border: 2px solid var(--primary-color);
            color: #e0e0e0;
            padding: 8px;
            font-family: inherit;
            font-size: inherit;
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .inline-select:focus {
            outline: none;
            border-color: var(--primary-light);
        }

        /* Column resizing styles */
        th {
            position: relative;
            user-select: none;
        }

        .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            z-index: 1;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle:hover,
        .resize-handle.resizing {
            background: var(--primary-color);
        }

        ::-webkit-scrollbar {
            width: 14px; /* Increased from 10px for easier targeting */
            height: 14px;
        }

        ::-webkit-scrollbar-track {
            background: #000000;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1a1a1a 100%);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--primary-light) 0%, #2a2a2a 100%);
        }

        .link-icon {
            color: var(--primary-light) !important;
            text-decoration: none;
            font-size: 18px;
            text-shadow: 
                0 0 5px var(--primary-glow),
                0 0 10px var(--primary-glow),
                0 0 15px var(--primary-glow);
            transition: all 0.3s ease;
        }

        .link-icon:hover {
            color: var(--primary-lighter) !important;
            text-shadow: 
                0 0 8px var(--primary-glow),
                0 0 15px var(--primary-glow),
                0 0 20px var(--primary-glow);
            transform: scale(1.1);
        }

        .sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 25px !important;
        }

        .sortable:hover {
            color: var(--primary-light);
        }

        .sortable::after {
            content: '‚áÖ';
            position: absolute;
            right: 8px;
            opacity: 0.3;
        }

        .sortable.asc::after {
            content: '‚Üë';
            opacity: 1;
        }

        .sortable.desc::after {
            content: '‚Üì';
            opacity: 1;
        }

        .filter-container {
            margin-top: 10px;
            padding: 12px;
            background: #000000;
            border-radius: 8px;
            border: 1px solid var(--primary-border);
        }

        .filter-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 8px 12px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            min-width: 150px;
        }

        .filter-input {
            padding: 8px 12px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            flex: 1;
            min-width: 200px;
        }

        .btn-filter {
            padding: 8px 16px;
            font-size: 14px;
        }

        .active-filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .filter-tag {
            background: var(--primary-bg);
            border: 1px solid var(--primary-border);
            padding: 6px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .filter-tag-remove {
            cursor: pointer;
            color: var(--primary-color);
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .filter-tag-remove:hover {
            color: var(--primary-light);
            text-shadow: 0 0 5px var(--primary-glow);
        }

        /* Column visibility classes */
        .hidden-col { display: none; }

        /* Toast notification styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: rgba(40, 40, 40, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid var(--primary-border);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--primary-light));
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.85em;
            box-shadow: 0 0 10px var(--primary-glow);
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            background: var(--primary-dark);
            color: var(--primary-light);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 4px 20px var(--primary-glow);
            border: 2px solid var(--primary-border);
            min-width: 300px;
            max-width: 400px;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.hide {
            opacity: 0;
            transform: translateX(400px);
        }

        .toast-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-weight: 500;
        }

        .toast-close {
            cursor: pointer;
            font-size: 20px;
            opacity: 0.7;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .toast-close:hover {
            opacity: 1;
        }

        .toast.success {
            border-color: #10b981;
            background: #064e3b;
            color: #6ee7b7;
        }

        .toast.error {
            border-color: #ef4444;
            background: #7f1d1d;
            color: #fca5a5;
        }

        .toast.warning {
            border-color: #f59e0b;
            background: #78350f;
            color: #fde68a;
        }

        .toast.info {
            border-color: #3b82f6;
            background: #1e3a8a;
            color: #93c5fd;
        }

        /* Auto-save indicator */
        .save-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 8px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-border);
            color: var(--primary-light);
            font-weight: 600;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 4px 15px var(--primary-glow);
        }

        .save-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }

        .save-indicator.saved {
            background: #064e3b;
            border-color: #10b981;
            color: #6ee7b7;
        }

        /* Custom themed checkboxes */
        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        input[type="checkbox"]:hover {
            border-color: var(--primary-color);
            background: rgba(255, 107, 61, 0.1);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        input[type="checkbox"]:checked {
            background: var(--primary-color);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        input[type="checkbox"]:indeterminate {
            background: var(--primary-color);
            border-color: var(--primary-color);
            opacity: 0.7;
        }

        input[type="checkbox"]:indeterminate::after {
            content: '‚àí';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
        }

        input[type="checkbox"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Checkbox in table header */
        th input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        /* Checkbox focus state */
        input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 107, 61, 0.3);
        }

        /* Make labels with checkboxes interactive */
        label:has(input[type="checkbox"]) {
            cursor: pointer;
            user-select: none;
        }

        label:has(input[type="checkbox"]):hover {
            color: var(--primary-light);
        }

        /* Song Manager specific overrides */
        .left-sidebar {
            width: 220px !important; /* Wider to accommodate filters */
        }

        .left-sidebar.collapsed {
            width: 45px !important; /* Just enough for collapse button */
        }

        .left-sidebar.collapsed .sidebar-content {
            display: none;
        }

        .left-sidebar.collapsed .collapsed-label {
            display: block;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            margin: 20px auto;
            text-align: center;
            color: var(--primary-light);
            font-size: 12px;
            font-weight: 600;
        }

        .left-sidebar .collapsed-label {
            display: none;
        }

        /* Ensure dropdowns appear above other content */
        .filter-select,
        .filter-input {
            position: relative;
            z-index: 100;
        }

        datalist {
            position: absolute;
            z-index: 1000;
        }

        /* Center pane adjusts to left sidebar */
        .center-pane {
            flex: 1;
            overflow-y: auto;
            position: relative;
            cursor: grab;
            padding: 0; /* Remove padding to bring table closer to header */
        }
        
        .center-pane.dragging {
            cursor: grabbing;
            user-select: none;
        }
        
        .center-pane table {
            margin: 0; /* Remove top margin */
        }
        
        /* Search bar row - sits between header and table */
        .search-bar-row {
            background: rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 8px 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid var(--primary-border);
            flex-shrink: 0;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }
        
        .search-bar-row .search-box {
            flex: 1;
            max-width: 50%; /* Half the screen or reasonable size */
            padding: 8px 15px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            border-radius: 8px;
            color: var(--text-primary);
        }
        
        .search-bar-row .compact-stats {
            display: flex;
            gap: 15px;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .search-bar-row {
                display: none; /* Hide on mobile - use mobile menu */
            }
        }
    </style>
</head>
<body>
    <!-- BlackDoubt Watermark Overlay -->
    <div class="blackdoubt-watermark-overlay"></div>
    
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Auto-save Indicator -->
    <div class="save-indicator" id="saveIndicator">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
            <polyline points="20 6 9 17 4 12"/>
        </svg>
        Saved ‚úì
    </div>
    
    <!-- Header -->
    <div class="header">
        <h1>
            <svg id="guitarIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 0 8px var(--primary-glow)); cursor: pointer;" onclick="switchWatermark('guitar')" title="Show Guitar Watermark">
                <circle cx="12" cy="17" r="4.5" stroke="var(--primary-color)" fill="none"/>
                <line x1="12" y1="12.5" x2="12" y2="2" stroke="var(--primary-color)"/>
                <line x1="9" y1="5" x2="15" y2="5" stroke="var(--primary-color)"/>
                <line x1="9" y1="8" x2="15" y2="8" stroke="var(--primary-color)"/>
            </svg>
            Song Manager
            <svg id="drumIcon" width="40" height="20" viewBox="0 0 40 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="filter: drop-shadow(0 0 8px var(--primary-glow)); cursor: pointer; opacity: 0.8;" onclick="switchWatermark('drum')" title="Show Drum Watermark">
                <circle cx="23" cy="17" r="4.5" fill="none" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="16" y1="21.5" x2="16" y2="2" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="11" y1="5" x2="21" y2="5" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="18" y1="8" x2="28" y2="8" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="21" y1="10" x2="26" y2="10" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="7" y1="12.5" x2="18" y2="12.5" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="30" y1="12.5" x2="30" y2="2" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="25" y1="5" x2="35" y2="5" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="27" y1="8" x2="33" y2="8" stroke="var(--primary-color)" stroke-width="2"/>
                <line x1="26" y1="14" x2="31" y2="14" stroke="var(--primary-color)" stroke-width="2"/>
            </svg>
        </h1>
        
        <!-- BlackDoubt Easter Egg Icon -->
        <div id="blackDoubtIcon" style="display: none; margin: 0 15px; align-items: center; justify-content: center; filter: drop-shadow(0 0 10px var(--primary-glow)); cursor: pointer; opacity: 0.5;" onclick="switchWatermark('blackdoubt')" title="Show BlackDoubt Watermark">
            <svg width="32" height="32" viewBox="0 0 40 40" fill="none" stroke="currentColor" stroke-width="1.5">
                <!-- Diamond (simple rotated square, slightly bigger than circle) -->
                <path d="M 20 3 L 37 20 L 20 37 L 3 20 Z" 
                      stroke="var(--primary-color)" 
                      fill="none"
                      stroke-width="1.8"/>
                <!-- Circle intertwined -->
                <circle cx="20" cy="20" r="13" stroke="var(--primary-color)" fill="none" stroke-width="1.8"/>
                <!-- Unicode Mathematical Bold Fraktur B in center -->
                <text x="20" y="20" 
                      font-size="20" 
                      font-family="serif" 
                      text-anchor="middle" 
                      dominant-baseline="central"
                      fill="var(--primary-color)"
                      stroke="none">ùîÖ</text>
            </svg>
        </div>
        
        <a href="setlist-manager.html" class="nav-link" style="margin-left: auto;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="8" y1="6" x2="21" y2="6"/>
                <line x1="8" y1="12" x2="21" y2="12"/>
                <line x1="8" y1="18" x2="21" y2="18"/>
                <line x1="3" y1="6" x2="3.01" y2="6"/>
                <line x1="3" y1="12" x2="3.01" y2="12"/>
                <line x1="3" y1="18" x2="3.01" y2="18"/>
            </svg>
            Setlists
        </a>
        <a href="chord-chart-editor.html" class="nav-link">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18V5l12-2v13"/>
                <circle cx="6" cy="18" r="3"/>
                <circle cx="18" cy="16" r="3"/>
            </svg>
            Charts
        </a>
        <a href="show-time.html" class="nav-link">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>
            Show Time
        </a>
        <a href="storage-wizard.html" class="nav-link">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
            Storage
        </a>
        
        <select id="themeSelector" class="theme-selector" onchange="changeTheme(this.value)" title="Theme">
            <option value="grey">Grey</option>
            <option value="red">Red</option>
            <option value="blue">Blue</option>
            <option value="green">Green</option>
            <option value="purple">Purple</option>
            <option value="cyan">Cyan</option>
            <option value="teal">Teal</option>
            <option value="copper">Copper</option>
            <option value="amber">Amber</option>
            <option value="pink">Pink</option>
            <option value="sunrise">Sunrise</option>
            <option value="sunset">Sunset</option>
            <option value="synthwave">Synth</option>
            <option value="prism">Prism</option>
        </select>
        
        <!-- Mobile Menu Button (Hamburger) - Rightmost position -->
        <button class="mobile-menu-btn" onclick="toggleMobileMenu()" aria-label="Open menu">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        </button>
    </div>
    
    <!-- Search Bar Row - Separate from header -->
    <div class="search-bar-row">
        <div class="compact-stats">
            <div class="stat-item">
                <span class="stat-label">Songs</span>
                <span class="stat-value" id="compactTotalSongs">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Artists</span>
                <span class="stat-value" id="compactTotalArtists">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Bands</span>
                <span class="stat-value" id="compactTotalBands">0</span>
            </div>
        </div>
        <input type="text" class="search-box" id="searchBox" placeholder="üîç Search songs..." oninput="handleSearchInput(event)" onkeydown="handleSearchKeydown(event)">
    </div>

    <!-- Mobile Command Menu (Full Screen Overlay) -->
    <div class="mobile-menu-overlay" id="mobileMenu">
        <div class="mobile-menu-header">
            <span class="mobile-menu-title">Menu</span>
            <button class="mobile-menu-close" onclick="toggleMobileMenu()" aria-label="Close menu">‚úï</button>
        </div>
        <div class="mobile-menu-content">
            <!-- Navigation Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Navigate</div>
                <a href="setlist-manager.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="8" y1="6" x2="21" y2="6"/>
                        <line x1="8" y1="12" x2="21" y2="12"/>
                        <line x1="8" y1="18" x2="21" y2="18"/>
                        <line x1="3" y1="6" x2="3.01" y2="6"/>
                        <line x1="3" y1="12" x2="3.01" y2="12"/>
                        <line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                    Setlists
                </a>
                <a href="chord-chart-editor.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 18V5l12-2v13"/>
                        <circle cx="6" cy="18" r="3"/>
                        <circle cx="18" cy="16" r="3"/>
                    </svg>
                    Charts
                </a>
                <a href="show-time.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Show Time
                </a>
                <a href="storage-wizard.html" class="nav-link">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Storage Wizard
                </a>
            </div>

            <!-- Actions Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Actions</div>
                
                <!-- Add Song Button -->
                <button class="btn btn-success" onclick="openAddModal(); toggleMobileMenu();" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add Song(s)
                </button>
                
                <!-- Undo Button -->
                <button class="btn btn-secondary" id="mobileUndoButton" onclick="undo()" disabled title="Undo last action" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                    </svg>
                    Undo
                </button>
                
                <!-- Spotify Setup Button -->
                <button class="btn btn-secondary" onclick="openSpotifySettings(); toggleMobileMenu();" style="width: 100%; margin-bottom: 10px; background: rgba(30, 215, 96, 0.1); border-color: rgba(30, 215, 96, 0.5); color: #1ED760;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="#1ED760">
                        <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
                    </svg>
                    Spotify Setup
                </button>
                
                <!-- Print Button -->
                <button class="btn btn-secondary" onclick="printSongs(); toggleMobileMenu();" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 6 2 18 2 18 9"/>
                        <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                        <rect x="6" y="14" width="12" height="8"/>
                    </svg>
                    Print
                </button>
            </div>
            
            <!-- Filters Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Filters</div>
                
                <!-- Filter Column Selection -->
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: var(--text-secondary);">Filter by Column:</label>
                    <select id="mobileFilterColumn" class="filter-select" onchange="updateFilterSuggestions()" style="width: 100%; padding: 8px; border-radius: 6px; background: var(--primary-darker); border: 1px solid var(--primary-border); color: var(--text-primary); font-size: 14px;">
                        <option value="">Select Column</option>
                        <option value="artist">Artist</option>
                        <option value="song">Song</option>
                        <option value="album">Album</option>
                        <option value="duration">Duration</option>
                        <option value="practiceStatus">Practice Status</option>
                        <option value="tuning">Tuning</option>
                        <option value="bands">Bands</option>
                        <option value="tags">Tags</option>
                        <option value="key">Key</option>
                        <option value="firstNote">First Note</option>
                        <option value="lastNote">Last Note</option>
                    </select>
                </div>
                
                <!-- Filter Value Input -->
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: var(--text-secondary);">Filter Value:</label>
                    <input type="text" id="mobileFilterValue" class="filter-input" placeholder="Enter filter value..." list="mobileFilterSuggestions" onkeypress="if(event.key==='Enter') addMobileFilter()" style="width: 100%; padding: 8px; border-radius: 6px; background: var(--primary-darker); border: 1px solid var(--primary-border); color: var(--text-primary); font-size: 14px;">
                    <datalist id="mobileFilterSuggestions"></datalist>
                </div>
                
                <!-- Add/Clear Filter Buttons -->
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <button class="btn btn-success" onclick="addMobileFilter()" style="flex: 1;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        Add
                    </button>
                    <button class="btn btn-secondary" onclick="clearFilters()" style="flex: 1;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                        Clear
                    </button>
                </div>
                
                <!-- Active Filters Display -->
                <div id="mobileActiveFilters" style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px;">
                    <!-- Active filter chips will appear here -->
                </div>
                
                <!-- Saved Filters Selector -->
                <div style="margin-top: 15px; margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 12px; color: var(--text-secondary);">Saved Filters:</label>
                    <select id="mobileSavedFiltersDropdown" onchange="applySavedFilter()" style="width: 100%; padding: 8px; border-radius: 6px; background: var(--primary-darker); border: 1px solid var(--primary-border); color: var(--text-primary); font-size: 14px; margin-bottom: 8px;">
                        <option value="">-- Select a saved filter --</option>
                    </select>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-success" onclick="openSaveFilterModal(); toggleMobileMenu();" title="Save current filters" style="flex: 1; font-size: 13px; padding: 8px;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                <polyline points="17 21 17 13 7 13 7 21"/>
                                <polyline points="7 3 7 8 15 8"/>
                            </svg>
                            Save
                        </button>
                        <button class="btn btn-secondary" onclick="openManageFiltersModal(); toggleMobileMenu();" title="Manage saved filters" style="flex: 1; font-size: 13px; padding: 8px;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"/>
                                <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"/>
                            </svg>
                            Manage
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Column Visibility Section (Collapsible) -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title" onclick="toggleMobileColumnVisibility()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; margin-bottom: 0;">
                    <span>Column Visibility</span>
                    <svg id="columnVisibilityChevron" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="transition: transform 0.3s;">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div id="mobileColumnCheckboxes" style="display: none; flex-direction: column; gap: 8px; font-size: 14px; padding: 10px 0; margin-top: 10px;">
                    <!-- Column checkboxes will be populated by JavaScript -->
                </div>
            </div>
            
            <!-- Other Tools Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Tools</div>
                
                <!-- Trash Button -->
                <button class="btn btn-secondary" onclick="openTrashModal(); toggleMobileMenu();" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Trash (<span id="mobileTrashCount">0</span>)
                </button>
                
                <!-- Density Button -->
                <button class="btn btn-secondary" onclick="cycleDensity()" id="mobileDensityButton" title="Toggle table density" style="width: 100%; margin-bottom: 10px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"/>
                        <line x1="3" y1="12" x2="21" y2="12"/>
                        <line x1="3" y1="18" x2="21" y2="18"/>
                    </svg>
                    <span id="mobileDensityLabel">Normal</span>
                </button>
            </div>

            <!-- Storage Management Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Storage Management</div>
                <a href="storage-wizard.html" class="btn-secondary" style="width: 100%; text-decoration: none; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    üíæ Storage Wizard
                </a>
            </div>
            
            <!-- Performance Monitor Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Monitoring</div>
                <button class="btn-secondary" onclick="openPerformanceMonitor(); toggleMobileMenu();" style="width: 100%;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                    </svg>
                    ‚ö° Performance Monitor
                </button>
            </div>

            <!-- Theme Section -->
            <div class="mobile-menu-section">
                <div class="mobile-menu-section-title">Theme</div>
                <select id="mobileThemeSelector" class="theme-selector" onchange="changeTheme(this.value)">
                    <option value="grey">Grey</option>
                    <option value="red">Red</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                    <option value="purple">Purple</option>
                    <option value="cyan">Cyan</option>
                    <option value="teal">Teal</option>
                    <option value="copper">Copper</option>
                    <option value="amber">Amber</option>
                    <option value="pink">Pink</option>
                    <option value="sunrise">Sunrise</option>
                    <option value="sunset">Sunset</option>
                    <option value="synthwave">Synth Wave</option>
                    <option value="prism">Dark Prism</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Mobile Search Bar (visible only on mobile, below header) -->
    <div class="mobile-search-bar">
        <input type="text" class="search-box" id="mobileSearchInput" placeholder="üîç Search songs..." oninput="handleSearchInput(event)" onkeydown="handleSearchKeydown(event)">
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
        <!-- Left Sidebar: Control Panel -->
        <div class="left-sidebar">
            <button class="collapse-btn" onclick="toggleLeftSidebar()">‚ò∞</button>
            <div class="collapsed-label">Commands</div>
            <div class="sidebar-content">
            <div class="sidebar-title">Actions</div>
            
            <button class="btn btn-success" onclick="openAddModal()" style="width: 100%; margin-bottom: 10px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <line x1="12" y1="5" x2="12" y2="19"/>
                    <line x1="5" y1="12" x2="19" y2="12"/>
                </svg>
                Add Song(s)
            </button>
            
            <button class="btn btn-secondary" id="undoButton" onclick="undo()" disabled title="Undo last action (Ctrl+Z)" style="width: 100%; margin-bottom: 10px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 7v6h6"/>
                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                </svg>
                Undo
            </button>
            
            <a href="storage-wizard.html" class="btn btn-primary" style="width: 100%; margin-bottom: 10px; text-decoration: none; display: flex; align-items: center; justify-content: center; gap: 8px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
                üíæ Storage Wizard
            </a>
            
            <button class="btn btn-secondary" onclick="openSpotifySettings()" style="width: 100%; margin-bottom: 10px; background: rgba(30, 215, 96, 0.1); border-color: rgba(30, 215, 96, 0.5); color: #1ED760;" title="Configure Spotify API for auto-filling song details">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="#1ED760">
                    <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
                </svg>
                Spotify Setup
            </button>
            
            <button class="btn btn-secondary" onclick="printSongs()" style="width: 100%; margin-bottom: 10px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 6 2 18 2 18 9"/>
                    <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/>
                    <rect x="6" y="14" width="12" height="8"/>
                </svg>
                Print
            </button>
            
            <div class="settings-section">
                <div class="settings-title">Filters</div>
                <select id="filterColumn" class="filter-select" onchange="updateFilterSuggestions()" style="width: 100%; margin-bottom: 8px;">
                    <option value="">Select Column</option>
                    <option value="artist">Artist</option>
                    <option value="song">Song</option>
                    <option value="album">Album</option>
                    <option value="duration">Duration</option>
                    <option value="practiceStatus">Practice Status</option>
                    <option value="tuning">Tuning</option>
                    <option value="bands">Bands</option>
                    <option value="tags">Tags</option>
                    <option value="key">Key</option>
                    <option value="firstNote">First Note</option>
                    <option value="lastNote">Last Note</option>
                </select>
                
                <input type="text" id="filterValue" class="filter-input" placeholder="Filter value..." list="filterSuggestions" onkeypress="if(event.key==='Enter') addFilter()" style="width: 100%; margin-bottom: 8px;">
                <datalist id="filterSuggestions"></datalist>
                
                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                    <button class="btn btn-success btn-small" onclick="addFilter()" style="flex: 1;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                        Add
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="clearFilters()" title="Clear all filters" style="flex: 1;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"/>
                            <line x1="6" y1="6" x2="18" y2="18"/>
                        </svg>
                        Clear
                    </button>
                </div>
                
                <!-- Active Filters Display -->
                <div id="activeFilters" style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">
                    <!-- Active filter tags will appear here -->
                </div>
            </div>
            
            <div class="settings-section">
                <div class="settings-title">Saved Filters</div>
                <select id="savedFiltersDropdown" class="filter-select" onchange="applySavedFilter()" style="width: 100%; margin-bottom: 8px;">
                    <option value="">-- Select filter --</option>
                </select>
                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                    <button class="btn btn-success btn-small" onclick="openSaveFilterModal()" title="Save current filters" style="flex: 1;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                            <polyline points="17 21 17 13 7 13 7 21"/>
                            <polyline points="7 3 7 8 15 8"/>
                        </svg>
                    </button>
                    <button class="btn btn-secondary btn-small" onclick="openManageFiltersModal()" title="Manage saved filters" style="flex: 1;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"/>
                            <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <div id="columnVisibilityPanel" class="settings-section" style="display: none;">
                <div class="settings-title">Column Visibility</div>
                <div id="columnCheckboxes" style="display: flex; flex-direction: column; gap: 6px; font-size: 12px;">
                    <!-- Column checkboxes will be populated by JavaScript -->
                </div>
            </div>
            
            <button class="btn btn-secondary" onclick="toggleColumnVisibilityPanel()" style="width: 100%; margin-bottom: 10px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                    <circle cx="12" cy="12" r="3"/>
                </svg>
                Columns
            </button>
            
            <button class="btn btn-secondary" onclick="openTrashModal()" style="width: 100%; margin-bottom: 10px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="3 6 5 6 21 6"/>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                </svg>
                Trash (<span id="trashCount">0</span>)
            </button>
            
            <button class="btn btn-secondary" onclick="cycleDensity()" id="densityButton" title="Toggle table density" style="width: 100%; margin-bottom: 10px;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="3" y1="6" x2="21" y2="6"/>
                    <line x1="3" y1="12" x2="21" y2="12"/>
                    <line x1="3" y1="18" x2="21" y2="18"/>
                </svg>
                <span id="densityLabel">Normal</span>
            </button>
            </div>
        </div>

        <!-- Center Pane: Song Table -->
        <div class="center-pane">
            <table>
                <thead>
                    <tr>
                        <th class="col-checkbox" style="width: 40px;">
                            <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" title="Select All">
                        </th>
                        <th class="col-actions">Actions</th>
                        <th class="col-link">Link</th>
                        <th class="sortable col-artist" onclick="sortTable('artist')">Artist</th>
                        <th class="sortable col-song" onclick="sortTable('song')">Song</th>
                        <th class="sortable col-album" onclick="sortTable('album')">Album</th>
                        <th class="sortable col-duration" onclick="sortTable('duration')">Duration</th>
                        <th class="sortable col-practiceStatus" onclick="sortTable('practiceStatus')">Status</th>
                        <th class="sortable col-tuning" onclick="sortTable('tuning')">Tuning</th>
                        <th class="sortable col-bands" onclick="sortTable('bands')">Bands</th>
                        <th class="sortable col-tags" onclick="sortTable('tags')">Tags</th>
                        <th class="sortable col-key" onclick="sortTable('key')">Key</th>
                        <th class="sortable col-firstNote" onclick="sortTable('firstNote')">First Note</th>
                        <th class="sortable col-lastNote" onclick="sortTable('lastNote')">Last Note</th>
                        <th class="col-chordChart">Chord Chart</th>
                        <th class="sortable col-playCount" onclick="sortTable('playCount')">Plays</th>
                    </tr>
                </thead>
                <tbody id="songTableBody">
                </tbody>
            </table>
            
            <!-- Bulk Actions Sticky Footer -->
            <div class="bulk-actions-footer" id="bulkActionsFooter" style="display: none;">
                <span id="selectedCount">0 songs selected</span>
                <button class="btn btn-secondary" onclick="openBulkEditModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                    </svg>
                    Bulk Edit
                </button>
                <button class="btn btn-danger" onclick="deleteSelected()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Delete Selected
                </button>
                <button class="btn btn-secondary" onclick="openAddToSetlistModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add to Setlist
                </button>
                <button class="btn btn-secondary" onclick="clearBulkSelection()">Clear Selection</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Modal -->
    <div id="songModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Add Song</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            
            <!-- Spotify Search Section -->
            <div style="background: rgba(30, 215, 96, 0.1); border: 2px solid rgba(30, 215, 96, 0.3); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="#1ED760">
                            <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
                        </svg>
                        <div>
                            <strong style="color: #1ED760; font-size: 16px;">Search Spotify</strong>
                            <small style="display: block; color: #999; font-size: 12px;">Auto-fill song details from Spotify</small>
                        </div>
                    </div>
                    <button type="button" onclick="openSpotifySettings()" title="Configure Spotify API" style="background: transparent; border: 1px solid rgba(30, 215, 96, 0.5); color: #1ED760; padding: 6px 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 4px;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.2 4.2l4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.2-4.2l4.2-4.2"></path>
                        </svg>
                        Settings
                    </button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="spotifySearchInput" placeholder="üîç Search for artist, song, or album..." style="flex: 1; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid rgba(30, 215, 96, 0.5); border-radius: 6px; color: #e0e0e0;">
                    <button type="button" class="btn" onclick="searchSpotify()" style="background: #1ED760; color: #000; font-weight: 600; padding: 10px 20px; white-space: nowrap;">
                        Search
                    </button>
                </div>
                <div id="spotifyResults" style="margin-top: 10px; max-height: 300px; overflow-y: auto; display: none;"></div>
            </div>
            
            <form id="songForm">
                <div class="form-group">
                    <label>Artist *</label>
                    <input type="text" id="artist" required>
                </div>
                <div class="form-group">
                    <label>Song *</label>
                    <input type="text" id="song" required>
                </div>
                <div class="form-group">
                    <label>Album</label>
                    <input type="text" id="album">
                </div>
                <div class="form-group">
                    <label>Link</label>
                    <input type="url" id="link">
                </div>
                <div class="form-group">
                    <label>Tuning</label>
                    <input type="text" id="tuning" placeholder="e.g., Standard, Drop D">
                </div>
                <div class="form-group">
                    <label>Bands</label>
                    <input type="text" id="bands" placeholder="Comma-separated band names">
                </div>
                <div class="form-group">
                    <label>Tags</label>
                    <input type="text" id="tags" placeholder="e.g., upbeat, ballad, dance, cover, original">
                    <small style="color: #999; display: block; margin-top: 5px;">Comma-separated tags for flexible organization</small>
                </div>
                <div class="form-group">
                    <label>Duration (mm:ss)</label>
                    <input type="text" id="duration" placeholder="e.g., 3:45" pattern="[0-9]{1,2}:[0-9]{2}">
                </div>
                <div class="form-group">
                    <label>Practice Status</label>
                    <select id="practiceStatus">
                        <option value="">Not set</option>
                        <option value="learning">üéì Learning</option>
                        <option value="practicing">üéµ Practicing</option>
                        <option value="ready">‚úì Ready</option>
                        <option value="mastered">‚≠ê Mastered</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Key</label>
                    <input type="text" id="key" placeholder="e.g., Am, G">
                </div>
                <div class="form-group">
                    <label>First Note</label>
                    <input type="text" id="firstNote">
                </div>
                <div class="form-group">
                    <label>Last Note</label>
                    <input type="text" id="lastNote">
                </div>
                <div class="button-group">
                    <button type="submit" class="btn-primary" id="saveSongBtn">
                        <span id="saveBtnText">Save</span>
                        <span id="saveBtnSpinner" style="display: none;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; animation: spin 1s linear infinite;">
                                <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
                                <path d="M12 2 A10 10 0 0 1 22 12" stroke-opacity="1"/>
                            </svg>
                            Saving...
                        </span>
                    </button>
                    <button type="button" class="btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Import Preview Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content large">
            <div class="modal-header">
                <h2>Import Preview <span style="font-size: 14px; color: #6b7280; font-weight: normal;">(Drag corner to resize)</span></h2>
                <span class="close" onclick="closeImportModal()">&times;</span>
            </div>
            <div id="importPreview" class="import-preview"></div>
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn-success" onclick="confirmImport()">‚úì Confirm Import</button>
                <button class="btn-secondary" onclick="closeImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Trash Modal -->
    <div id="trashModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="color: var(--primary-light); text-align: center;">üóëÔ∏è Trash (2-day retention)</h2>
                <span class="close" onclick="closeTrashModal()">&times;</span>
            </div>
            <div id="trashContent" style="max-height: 500px; overflow-y: auto;">
                <!-- Trash items will be rendered here -->
            </div>
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn-primary" onclick="restoreAllFromTrash()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                    </svg>
                    Restore All
                </button>
                <button class="btn-danger" onclick="emptyTrash()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Empty Trash
                </button>
                <button class="btn-secondary" onclick="closeTrashModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Save Filter Modal -->
    <div id="saveFilterModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="display: flex; align-items: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Current Filter
                </h2>
                <span class="close" onclick="closeSaveFilterModal()">&times;</span>
            </div>
            <div style="padding: 20px;">
                <p style="color: #999; margin-bottom: 15px;">Save your current search and filter settings for quick access later.</p>
                <div class="form-group">
                    <label>Filter Name *</label>
                    <input type="text" id="filterNameInput" placeholder="e.g., Drop D Songs, Practice Queue" required>
                </div>
                <div style="padding: 15px; background: rgba(40, 40, 40, 0.5); border-radius: 6px; margin-bottom: 15px;">
                    <h4 style="color: var(--primary-color); margin: 0 0 10px 0;">Current Settings:</h4>
                    <div id="currentFilterSummary" style="color: #ccc; font-size: 0.9em;"></div>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="saveCurrentFilter()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Filter
                </button>
                <button class="btn-secondary" onclick="closeSaveFilterModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Filter Builder Modal -->
    <div id="filterBuilderModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2 style="display: flex; align-items: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
                    </svg>
                    Add Filter
                </h2>
                <span class="close" onclick="closeFilterBuilderModal()">&times;</span>
            </div>
            <div style="padding: 20px;">
                <div class="form-group">
                    <label>Filter Column *</label>
                    <select id="filterColumnSelect" class="theme-selector" onchange="updateFilterValueOptions()" style="width: 100%;">
                        <option value="">-- Select Column --</option>
                        <option value="artist">Artist</option>
                        <option value="song">Song</option>
                        <option value="album">Album</option>
                        <option value="band">Band</option>
                        <option value="tuning">Tuning</option>
                        <option value="key">Key</option>
                        <option value="tags">Tags</option>
                        <option value="practiceStatus">Status</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Value *</label>
                    <select id="filterValueSelect" class="theme-selector" style="width: 100%;">
                        <option value="">-- Select column first --</option>
                    </select>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="applyNewFilter()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <polyline points="20 6 9 17 4 12"/>
                    </svg>
                    Apply Filter
                </button>
                <button class="btn-secondary" onclick="closeFilterBuilderModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Manage Filters Modal -->
    <div id="manageFiltersModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="display: flex; align-items: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"/>
                        <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"/>
                    </svg>
                    Manage Saved Filters
                </h2>
                <span class="close" onclick="closeManageFiltersModal()">&times;</span>
            </div>
            <div id="savedFiltersList" style="padding: 20px; max-height: 400px; overflow-y: auto;"></div>
            <div class="button-group">
                <button class="btn-secondary" onclick="closeManageFiltersModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Import Selection Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>Import Songs</h2>
                <span class="close" onclick="closeImportModal()">&times;</span>
            </div>
            <div style="margin: 20px 0;">
                <p style="color: var(--primary-light); margin-bottom: 20px;">
                    Choose how you want to import your songs:
                </p>
                
                <!-- CSV Import Option -->
                <div class="import-option" onclick="document.getElementById('csvFile').click(); closeImportModal();">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="var(--primary-color)" stroke-width="2">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    <div>
                        <h3 style="color: var(--primary-light); margin: 0 0 5px 0; font-size: 1.1em;">Import from CSV File</h3>
                        <p style="color: #999; margin: 0; font-size: 0.9em;">Upload a CSV file from your computer</p>
                    </div>
                </div>
                
                <!-- Paste Import Option -->
                <div class="import-option" onclick="closeImportModal(); openPasteImportModal();">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="var(--primary-color)" stroke-width="2">
                        <rect x="9" y="2" width="6" height="4" rx="1"/>
                        <path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2h-2"/>
                        <path d="M12 11v6m-3-3h6"/>
                    </svg>
                    <div>
                        <h3 style="color: var(--primary-light); margin: 0 0 5px 0; font-size: 1.1em;">Paste from Clipboard</h3>
                        <p style="color: #999; margin: 0; font-size: 0.9em;">Paste tab/comma-separated text from anywhere</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Paste Import Modal -->
    <div id="pasteImportModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>üìã Paste Import</h2>
                <span class="close" onclick="closePasteImportModal()">&times;</span>
            </div>
            <div style="margin: 20px 0;">
                <p style="color: var(--primary-light); margin-bottom: 10px;">
                    Paste your song list below. Supported formats:
                </p>
                <ul style="color: #999; font-size: 14px; margin-left: 20px; margin-bottom: 15px;">
                    <li><strong>Artist - Song</strong> (e.g., "Metallica - Enter Sandman")</li>
                    <li><strong>Artist, Song</strong> (comma-separated)</li>
                    <li><strong>Artist\tSong</strong> (tab-separated, from spreadsheets)</li>
                    <li><strong>Multiple columns</strong> (Artist, Song, Album, etc.)</li>
                </ul>
                <textarea id="pasteImportText" placeholder="Paste your song list here...&#10;&#10;Examples:&#10;Metallica - Enter Sandman&#10;Iron Maiden, The Trooper&#10;Tool	Schism	Lateralus" style="width: 100%; min-height: 300px; padding: 10px; background: #1a1a1a; border: 2px solid var(--primary-border); color: #e0e0e0; font-family: monospace; font-size: 13px; border-radius: 4px;"></textarea>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button type="button" class="btn-secondary" onclick="closePasteImportModal()">Cancel</button>
                <button type="button" class="btn-success" onclick="processPasteImport()">Preview & Import</button>
            </div>
        </div>
    </div>

    <!-- Bulk Edit Preview Modal -->
    <div id="bulkEditPreviewModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Preview Bulk Changes</h2>
                <span class="close" onclick="closeBulkEditPreview()">&times;</span>
            </div>
            <div id="bulkEditPreviewContent" style="margin: 20px 0; max-height: 500px; overflow-y: auto;">
                <!-- Preview content will be inserted here -->
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button type="button" class="btn-secondary" onclick="closeBulkEditPreview()">Cancel</button>
                <button type="button" class="btn-success" onclick="confirmBulkEdit()">Apply Changes</button>
            </div>
        </div>
    </div>

    <!-- Bulk Edit Modal -->
    <div id="bulkEditModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Bulk Edit <span id="bulkEditCount" style="color: var(--primary-light);">(0 songs)</span></h2>
                <span class="close" onclick="closeBulkEditModal()">&times;</span>
            </div>
            <form id="bulkEditForm" style="margin-top: 20px;">
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,107,61,0.1); border: 1px solid var(--primary-border); border-radius: 6px;">
                    <p style="color: var(--primary-light); margin-bottom: 10px;">
                        <strong>How bulk edit works:</strong>
                    </p>
                    <ul style="color: #999; font-size: 14px; margin-left: 20px;">
                        <li><strong>Replace:</strong> Overwrites the field with new value</li>
                        <li><strong>Add:</strong> Appends to existing value (for bands/tags)</li>
                        <li><strong>Remove:</strong> Removes specific text from field</li>
                    </ul>
                </div>

                <!-- Tuning -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateTuning">
                        <strong>Update Tuning</strong>
                    </label>
                    <div id="tuningBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkTuning" placeholder="e.g., Drop D, Standard, DADGAD" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkTuningAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- Album -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateAlbum">
                        <strong>Update Album</strong>
                    </label>
                    <div id="albumBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkAlbum" placeholder="e.g., Greatest Hits, Live Album" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkAlbumAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- Duration -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateDuration">
                        <strong>Update Duration</strong>
                    </label>
                    <div id="durationBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkDuration" placeholder="e.g., 3:45, 4:20" pattern="[0-9]{1,2}:[0-9]{2}" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkDurationAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                        <small style="color: #999; display: block; margin-top: 5px;">Format: mm:ss</small>
                    </div>
                </div>

                <!-- Bands -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateBands">
                        <strong>Update Bands</strong>
                    </label>
                    <div id="bandsBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkBands" placeholder="e.g., Rock Band, Jazz Trio" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkBandsAction" style="width: 100%; padding: 8px;">
                            <option value="add">Add to existing bands</option>
                            <option value="replace">Replace all bands</option>
                            <option value="remove">Remove from bands</option>
                        </select>
                    </div>
                </div>

                <!-- Tags -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateTags">
                        <strong>Update Tags</strong>
                    </label>
                    <div id="tagsBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkTags" placeholder="e.g., upbeat, dance, cover" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkTagsAction" style="width: 100%; padding: 8px;">
                            <option value="add">Add to existing tags</option>
                            <option value="replace">Replace all tags</option>
                            <option value="remove">Remove from tags</option>
                        </select>
                    </div>
                </div>

                <!-- Practice Status -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateStatus">
                        <strong>Update Practice Status</strong>
                    </label>
                    <div id="statusBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <select id="bulkPracticeStatus" style="width: 100%; padding: 8px;">
                            <option value="">Not set</option>
                            <option value="learning">üéì Learning</option>
                            <option value="practicing">üéµ Practicing</option>
                            <option value="ready">‚úì Ready</option>
                            <option value="mastered">‚≠ê Mastered</option>
                        </select>
                    </div>
                </div>

                <!-- Key -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateKey">
                        <strong>Update Key</strong>
                    </label>
                    <div id="keyBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkKey" placeholder="e.g., Am, G, C#m" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkKeyAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- First Note -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateFirstNote">
                        <strong>Update First Note</strong>
                    </label>
                    <div id="firstNoteBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkFirstNote" placeholder="e.g., A, C#, Eb" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkFirstNoteAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- Last Note -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateLastNote">
                        <strong>Update Last Note</strong>
                    </label>
                    <div id="lastNoteBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkLastNote" placeholder="e.g., E, G, D" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkLastNoteAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <div class="button-group" style="margin-top: 30px;">
                    <button type="submit" class="btn-success">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        Apply Changes
                    </button>
                    <button type="button" class="btn-secondary" onclick="closeBulkEditModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        /**
         * Debounce function - delays execution until after specified wait time
         * @param {Function} func - Function to debounce
         * @param {number} wait - Milliseconds to wait
         * @returns {Function} Debounced function
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================
        
        let songs = [];
        let editIndex = -1;
        let importData = [];
        let currentSort = { column: null, direction: 'asc' };
        let activeFilters = [];
        let hiddenColumns = new Set(); // Track hidden columns
        
        // Performance: Memoization caches
        let statsCache = null;
        let statsCacheKey = null;
        let searchDebounceTimer = null; // For debouncing search
        let lastFilterState = null; // Cache last filter state to avoid redundant filtering
        let cachedFilteredSongs = null; // Cache filtered results
        
        // Helper function to invalidate filter cache
        function invalidateFilterCache() {
            lastFilterState = null;
            cachedFilteredSongs = null;
        }
        
        // Autocomplete system
        let autocompleteSelectedIndex = -1;
        let autocompleteSuggestions = [];
        
        // Undo system
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 10;
        
        // Trash system - Simple version that works
        let trash = [];
        const TRASH_RETENTION_DAYS = 2;
        
        // Bulk edit system
        let selectedSongIndices = new Set();

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úì',
                error: '‚úï',
                warning: '‚ö†',
                info: '‚Ñπ'
            };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-message">${message}</div>
                <div class="toast-close" onclick="this.parentElement.remove()">‚úï</div>
            `;
            
            container.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('hide');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // Auto-save indicator
        function showSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            indicator.classList.add('show', 'saved');
            
            setTimeout(() => {
                indicator.classList.remove('show');
                setTimeout(() => {
                    indicator.classList.remove('saved');
                }, 300);
            }, 1500);
        }

        // Undo system functions
        function saveUndoState(action, data) {
            undoHistory.push({
                action: action,
                data: JSON.parse(JSON.stringify(data)), // Deep clone
                timestamp: Date.now()
            });
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }

        function undo() {
            if (undoHistory.length === 0) return;
            
            const lastAction = undoHistory.pop();
            console.log('Undoing action:', lastAction.action, lastAction.data);
            
            switch (lastAction.action) {
                case 'delete':
                    // Restore deleted song
                    songs.splice(lastAction.data.index, 0, lastAction.data.song);
                    
                    // IMPORTANT: Also remove from trash if it's there
                    const songToRemove = lastAction.data.song;
                    trash = trash.filter(item => 
                        !(item.song.song === songToRemove.song && item.song.artist === songToRemove.artist)
                    );
                    saveTrash();
                    
                    showToast(`Restored: ${lastAction.data.song.song} by ${lastAction.data.song.artist}`, 'success');
                    break;
                    
                case 'bulkDelete':
                    // Restore multiple deleted songs
                    if (lastAction.data.songs && Array.isArray(lastAction.data.songs)) {
                        lastAction.data.songs.forEach(item => {
                            songs.splice(item.index, 0, item.song);
                            
                            // Also remove from trash
                            trash = trash.filter(trashItem => 
                                !(trashItem.song.song === item.song.song && trashItem.song.artist === item.song.artist)
                            );
                        });
                        saveTrash();
                        showToast(`Restored ${lastAction.data.songs.length} song(s)`, 'success');
                    }
                    break;
                    
                case 'add':
                    // Remove added song
                    songs.pop();
                    showToast('Add song undone', 'info');
                    break;
                    
                case 'edit':
                    // Restore old song data
                    songs[lastAction.data.index] = lastAction.data.oldSong;
                    showToast('Edit undone', 'info');
                    break;
                    
                case 'clearAll':
                    // Restore all songs
                    songs = lastAction.data.songs;
                    showToast(`Restored ${songs.length} song(s)`, 'success');
                    break;
                    
                case 'import':
                    // Remove imported songs
                    songs.splice(songs.length - lastAction.data.count, lastAction.data.count);
                    showToast(`Import of ${lastAction.data.count} song(s) undone`, 'info');
                    break;
                    
                default:
                    console.warn('Unknown undo action:', lastAction.action);
                    showToast('Cannot undo this action', 'warning');
                    return;
            }
            
            saveSongs();
            applyFilters();
            updateStats();
            updateUndoButton();
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoButton');
            if (undoBtn) {
                undoBtn.disabled = undoHistory.length === 0;
                if (undoHistory.length > 0) {
                    const lastAction = undoHistory[undoHistory.length - 1];
                    const actionNames = {
                        'delete': 'Undo delete',
                        'add': 'Undo add',
                        'edit': 'Undo edit',
                        'clearAll': 'Undo clear all',
                        'import': 'Undo import'
                    };
                    undoBtn.title = actionNames[lastAction.action] || 'Undo last action';
                }
            }
        }

        // Keyboard shortcut for undo
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
        });

        // Bulk edit system functions
        function toggleSongSelection(index, event) {
            const checkbox = event.target;
            
            // Sync our Set with the checkbox state
            if (checkbox.checked) {
                selectedSongIndices.add(index);
            } else {
                selectedSongIndices.delete(index);
            }
            
            updateSelectAllCheckbox();
            updateBulkActionsBar();
        }

        function toggleSelectAll() {
            const checkbox = document.getElementById('selectAllCheckbox');
            if (checkbox.checked) {
                // Select all visible songs
                songs.forEach((_, index) => selectedSongIndices.add(index));
            } else {
                selectedSongIndices.clear();
            }
            applyFilters(); // Re-render to update checkboxes
        }

        function updateSelectAllCheckbox() {
            const checkbox = document.getElementById('selectAllCheckbox');
            if (selectedSongIndices.size === 0) {
                checkbox.checked = false;
                checkbox.indeterminate = false;
            } else if (selectedSongIndices.size === songs.length) {
                checkbox.checked = true;
                checkbox.indeterminate = false;
            } else {
                checkbox.checked = false;
                checkbox.indeterminate = true;
            }
        }

        function updateBulkActionsBar() {
            const bar = document.getElementById('bulkActionsBar');
            const count = document.getElementById('selectedCount');
            
            // Only update if old bar exists (for backwards compatibility)
            if (bar && count) {
                count.textContent = selectedSongIndices.size;
                
                if (selectedSongIndices.size > 0) {
                    bar.style.display = 'block';
                } else {
                    bar.style.display = 'none';
                }
            }
            
            updateSelectAllCheckbox();
            updateBulkActionsFooter(); // Update new footer as well
        }

        function clearBulkSelection() {
            selectedSongIndices.clear();
            applyFilters(); // Re-render to update checkboxes
        }

        function openBulkEditModal() {
            if (selectedSongIndices.size === 0) {
                showToast('No songs selected!', 'warning');
                return;
            }
            
            document.getElementById('bulkEditCount').textContent = `(${selectedSongIndices.size} songs)`;
            document.getElementById('bulkEditModal').classList.add('active');
            
            // Set up checkbox toggle handlers
            const checkboxes = [
                'bulkUpdateTuning', 
                'bulkUpdateAlbum', 
                'bulkUpdateDuration', 
                'bulkUpdateBands', 
                'bulkUpdateTags', 
                'bulkUpdateStatus', 
                'bulkUpdateKey',
                'bulkUpdateFirstNote',
                'bulkUpdateLastNote'
            ];
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                const optionsId = id.replace('bulkUpdate', '').toLowerCase() + 'BulkOptions';
                checkbox.onchange = function() {
                    document.getElementById(optionsId).style.display = this.checked ? 'block' : 'none';
                };
            });
        }

        function closeBulkEditModal() {
            document.getElementById('bulkEditModal').classList.remove('active');
            document.getElementById('bulkEditForm').reset();
            // Hide all option divs
            [
                'tuningBulkOptions', 
                'albumBulkOptions', 
                'durationBulkOptions', 
                'bandsBulkOptions', 
                'tagsBulkOptions', 
                'statusBulkOptions', 
                'keyBulkOptions',
                'firstNoteBulkOptions',
                'lastNoteBulkOptions'
            ].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
        }

        // Progress indicator variables
        let progressCancelRequested = false;

        function showProgress(title, message) {
            progressCancelRequested = false;
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressMessage').textContent = message;
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            document.getElementById('progressStats').textContent = '';
            document.getElementById('progressCancelBtn').style.display = 'inline-block';
            document.getElementById('progressModal').classList.add('active');
        }

        function updateProgress(current, total, message = '') {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressBar').textContent = percent + '%';
            if (message) {
                document.getElementById('progressMessage').textContent = message;
            }
            document.getElementById('progressStats').textContent = `${current} of ${total} completed`;
        }

        function hideProgress() {
            document.getElementById('progressModal').classList.remove('active');
            progressCancelRequested = false;
        }

        function cancelBulkOperation() {
            progressCancelRequested = true;
            document.getElementById('progressCancelBtn').disabled = true;
            document.getElementById('progressCancelBtn').textContent = 'Cancelling...';
        }

        async function bulkDelete() {
            if (selectedSongIndices.size === 0) {
                showToast('No songs selected!', 'warning');
                return;
            }
            
            if (!confirm(`Move ${selectedSongIndices.size} song(s) to trash?`)) {
                return;
            }
            
            const totalSongs = selectedSongIndices.size;
            showProgress('Deleting Songs', `Preparing to delete ${totalSongs} song(s)...`);
            
            // Save undo state
            const deletedSongs = [];
            selectedSongIndices.forEach(index => {
                deletedSongs.push({ index, song: JSON.parse(JSON.stringify(songs[index])) });
            });
            saveUndoState('bulkDelete', { songs: deletedSongs });
            
            // Move to trash and delete (in reverse order to maintain indices)
            const indicesToDelete = Array.from(selectedSongIndices).sort((a, b) => b - a);
            
            // Process in batches with progress updates
            let processed = 0;
            for (const index of indicesToDelete) {
                if (progressCancelRequested) {
                    hideProgress();
                    showToast('Delete operation cancelled', 'warning');
                    return;
                }
                
                trash.push({
                    song: JSON.parse(JSON.stringify(songs[index])),
                    deletedAt: Date.now()
                });
                songs.splice(index, 1);
                processed++;
                
                updateProgress(processed, totalSongs, `Deleting song ${processed} of ${totalSongs}...`);
                
                // Allow UI to update every 10 songs
                if (processed % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            selectedSongIndices.clear();
            saveSongs();
            saveTrash();
            applyFilters();
            updateStats();
            hideProgress();
            showToast(`${indicesToDelete.length} song(s) moved to trash`, 'success');
        }

        // Handle bulk edit form submission
        document.getElementById('bulkEditForm').onsubmit = async function(e) {
            e.preventDefault();
            
            // Instead of applying immediately, show preview first
            showBulkEditPreview();
        };

        // Store pending bulk edit data
        let pendingBulkEdits = null;

        function showBulkEditPreview() {
            const totalSongs = selectedSongIndices.size;
            const selectedSongs = Array.from(selectedSongIndices).map(i => songs[i]);
            
            // Calculate what changes will be made
            const changes = {
                byField: {},
                affected: 0,
                preview: []
            };
            
            // Check each field
            const fieldUpdates = [
                { id: 'bulkUpdateTuning', field: 'tuning', value: 'bulkTuning', action: null },
                { id: 'bulkUpdateAlbum', field: 'album', value: 'bulkAlbum', action: null },
                { id: 'bulkUpdateDuration', field: 'duration', value: 'bulkDuration', action: null },
                { id: 'bulkUpdateBands', field: 'bands', value: 'bulkBands', action: 'bulkBandsAction' },
                { id: 'bulkUpdateTags', field: 'tags', value: 'bulkTags', action: 'bulkTagsAction' },
                { id: 'bulkUpdateStatus', field: 'practiceStatus', value: 'bulkPracticeStatus', action: null },
                { id: 'bulkUpdateKey', field: 'key', value: 'bulkKey', action: null },
                { id: 'bulkUpdateFirstNote', field: 'firstNote', value: 'bulkFirstNote', action: null },
                { id: 'bulkUpdateLastNote', field: 'lastNote', value: 'bulkLastNote', action: null }
            ];
            
            selectedSongs.forEach((song, idx) => {
                const songChanges = [];
                
                fieldUpdates.forEach(update => {
                    if (document.getElementById(update.id).checked) {
                        const value = document.getElementById(update.value).value.trim();
                        const action = update.action ? document.getElementById(update.action).value : 'replace';
                        
                        if (value || update.field === 'practiceStatus') {
                            const oldValue = song[update.field] || '';
                            let newValue = value;
                            
                            // Calculate new value based on action
                            if (action === 'add' && (update.field === 'bands' || update.field === 'tags')) {
                                const existing = oldValue ? oldValue.split(',').map(t => t.trim()) : [];
                                const newItems = value.split(',').map(t => t.trim());
                                const combined = [...new Set([...existing, ...newItems])];
                                newValue = combined.join(', ');
                            } else if (action === 'remove' && (update.field === 'bands' || update.field === 'tags')) {
                                const existing = oldValue ? oldValue.split(',').map(t => t.trim()) : [];
                                const toRemove = value.split(',').map(t => t.trim());
                                const filtered = existing.filter(t => !toRemove.includes(t));
                                newValue = filtered.join(', ');
                            }
                            
                            if (oldValue !== newValue) {
                                songChanges.push({
                                    field: update.field,
                                    oldValue: oldValue,
                                    newValue: newValue
                                });
                                
                                if (!changes.byField[update.field]) {
                                    changes.byField[update.field] = 0;
                                }
                                changes.byField[update.field]++;
                            }
                        }
                    }
                });
                
                if (songChanges.length > 0) {
                    changes.affected++;
                    changes.preview.push({
                        song: song,
                        changes: songChanges
                    });
                }
            });
            
            // Store for later
            pendingBulkEdits = changes;
            
            // Render preview
            const previewHtml = `
                <div style="padding: 15px; background: rgba(var(--primary-color-rgb, 255, 107, 61), 0.1); border: 1px solid var(--primary-border); border-radius: 6px; margin-bottom: 20px;">
                    <h3 style="color: var(--primary-light); margin: 0 0 10px 0;">Summary</h3>
                    <p style="color: #e0e0e0; margin-bottom: 5px;"><strong>${changes.affected}</strong> of <strong>${totalSongs}</strong> songs will be changed</p>
                    <div style="margin-top: 10px;">
                        ${Object.keys(changes.byField).map(field => 
                            `<div style="color: #999; font-size: 14px;">‚Ä¢ <strong>${field}</strong>: ${changes.byField[field]} song(s)</div>`
                        ).join('')}
                    </div>
                </div>
                
                <h3 style="color: var(--primary-light); margin-bottom: 10px;">Changes Preview (showing first ${Math.min(changes.preview.length, 10)})</h3>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    ${changes.preview.slice(0, 10).map(item => `
                        <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px; border: 1px solid var(--primary-border);">
                            <div style="color: var(--primary-light); font-weight: bold; margin-bottom: 8px;">
                                ${escapeHtml(item.song.artist)} - ${escapeHtml(item.song.song)}
                            </div>
                            ${item.changes.map(change => `
                                <div style="margin-left: 15px; font-size: 13px; color: #999;">
                                    <strong style="color: #e0e0e0;">${change.field}:</strong>
                                    <span style="color: #ff6b6b; text-decoration: line-through;">${escapeHtml(change.oldValue || '(empty)')}</span>
                                    ‚Üí
                                    <span style="color: #51cf66;">${escapeHtml(change.newValue)}</span>
                                </div>
                            `).join('')}
                        </div>
                    `).join('')}
                    ${changes.preview.length > 10 ? `<div style="color: #999; text-align: center; padding: 10px;">... and ${changes.preview.length - 10} more</div>` : ''}
                </div>
            `;
            
            document.getElementById('bulkEditPreviewContent').innerHTML = previewHtml;
            document.getElementById('bulkEditPreviewModal').classList.add('active');
        }

        function closeBulkEditPreview() {
            document.getElementById('bulkEditPreviewModal').classList.remove('active');
            pendingBulkEdits = null;
        }

        async function confirmBulkEdit() {
            if (!pendingBulkEdits) return;
            
            // Close preview
            closeBulkEditPreview();
            closeBulkEditModal();
            
            // Now apply the changes (original logic)
            const totalSongs = selectedSongIndices.size;
            showProgress('Updating Songs', `Preparing to update ${totalSongs} song(s)...`);
            
            let updateCount = 0;
            const updates = [];
            
            // Get selected songs
            const selectedSongs = Array.from(selectedSongIndices).map(i => songs[i]);
            
            let processed = 0;
            for (let idx = 0; idx < selectedSongs.length; idx++) {
                if (progressCancelRequested) {
                    hideProgress();
                    showToast('Update operation cancelled', 'warning');
                    return;
                }
                
                const song = selectedSongs[idx];
                const originalIndex = Array.from(selectedSongIndices)[idx];
                let hasChanges = false;
                
                updateProgress(processed + 1, totalSongs, `Updating song ${processed + 1} of ${totalSongs}...`);
                
                // Tuning
                if (document.getElementById('bulkUpdateTuning').checked) {
                    const value = document.getElementById('bulkTuning').value.trim();
                    if (value) {
                        song.tuning = value;
                        hasChanges = true;
                    }
                }
                
                // Album
                if (document.getElementById('bulkUpdateAlbum').checked) {
                    const value = document.getElementById('bulkAlbum').value.trim();
                    if (value) {
                        song.album = value;
                        hasChanges = true;
                    }
                }
                
                // Duration
                if (document.getElementById('bulkUpdateDuration').checked) {
                    const value = document.getElementById('bulkDuration').value.trim();
                    if (value) {
                        song.duration = value;
                        hasChanges = true;
                    }
                }
                
                // Bands
                if (document.getElementById('bulkUpdateBands').checked) {
                    const value = document.getElementById('bulkBands').value.trim();
                    const action = document.getElementById('bulkBandsAction').value;
                    if (value) {
                        if (action === 'replace') {
                            song.bands = value;
                            hasChanges = true;
                        } else if (action === 'add') {
                            const existing = song.bands ? song.bands.split(',').map(b => b.trim()) : [];
                            const newBands = value.split(',').map(b => b.trim());
                            const combined = [...new Set([...existing, ...newBands])];
                            song.bands = combined.join(', ');
                            hasChanges = true;
                        } else if (action === 'remove') {
                            const existing = song.bands ? song.bands.split(',').map(b => b.trim()) : [];
                            const toRemove = value.split(',').map(b => b.trim());
                            const filtered = existing.filter(b => !toRemove.includes(b));
                            song.bands = filtered.join(', ');
                            hasChanges = true;
                        }
                    }
                }
                
                // Tags
                if (document.getElementById('bulkUpdateTags').checked) {
                    const value = document.getElementById('bulkTags').value.trim();
                    const action = document.getElementById('bulkTagsAction').value;
                    if (value) {
                        if (action === 'replace') {
                            song.tags = value;
                            hasChanges = true;
                        } else if (action === 'add') {
                            const existing = song.tags ? song.tags.split(',').map(t => t.trim()) : [];
                            const newTags = value.split(',').map(t => t.trim());
                            const combined = [...new Set([...existing, ...newTags])];
                            song.tags = combined.join(', ');
                            hasChanges = true;
                        } else if (action === 'remove') {
                            const existing = song.tags ? song.tags.split(',').map(t => t.trim()) : [];
                            const toRemove = value.split(',').map(t => t.trim());
                            const filtered = existing.filter(t => !toRemove.includes(t));
                            song.tags = filtered.join(', ');
                            hasChanges = true;
                        }
                    }
                }
                
                // Practice Status
                if (document.getElementById('bulkUpdateStatus').checked) {
                    song.practiceStatus = document.getElementById('bulkPracticeStatus').value;
                    hasChanges = true;
                }
                
                // Key
                if (document.getElementById('bulkUpdateKey').checked) {
                    const value = document.getElementById('bulkKey').value.trim();
                    if (value) {
                        song.key = value;
                        hasChanges = true;
                    }
                }
                
                // First Note
                if (document.getElementById('bulkUpdateFirstNote').checked) {
                    const value = document.getElementById('bulkFirstNote').value.trim();
                    if (value) {
                        song.firstNote = value;
                        hasChanges = true;
                    }
                }
                
                // Last Note
                if (document.getElementById('bulkUpdateLastNote').checked) {
                    const value = document.getElementById('bulkLastNote').value.trim();
                    if (value) {
                        song.lastNote = value;
                        hasChanges = true;
                    }
                }
                
                if (hasChanges) {
                    updateCount++;
                    updates.push({ index: originalIndex, song: JSON.parse(JSON.stringify(song)) });
                }
                
                processed++;
                
                // Allow UI to update every 10 songs
                if (processed % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            hideProgress();
            
            if (updateCount === 0) {
                showToast('No changes to apply. Please select at least one field to update.', 'warning');
                return;
            }
            
            // Save undo state
            saveUndoState('bulkEdit', { updates });
            
            // Save and update
            saveSongs();
            applyFilters();
            closeBulkEditModal();
            selectedSongIndices.clear();
            showToast(`Successfully updated ${updateCount} song(s)!`, 'success');
        };

        // Trash system functions
        function loadTrash() {
            const stored = localStorage.getItem('bandSongsTrash');
            if (stored) {
                trash = JSON.parse(stored);
                cleanExpiredTrash();
            }
        }

        function saveTrash() {
            localStorage.setItem('bandSongsTrash', JSON.stringify(trash));
            updateTrashCount();
        }

        // Duplicate detection using Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            matrix[i][j - 1] + 1,     // insertion
                            matrix[i - 1][j] + 1      // deletion
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        function findSimilarSongs(artist, song, threshold = 0.8) {
            const similar = [];
            const artistLower = artist.toLowerCase();
            const songLower = song.toLowerCase();

            songs.forEach((existingSong, index) => {
                // Skip the song being edited
                if (editIndex >= 0 && index === editIndex) return;

                const existingArtistLower = existingSong.artist.toLowerCase();
                const existingSongLower = existingSong.song.toLowerCase();

                // Calculate similarity
                const artistDist = levenshteinDistance(artistLower, existingArtistLower);
                const songDist = levenshteinDistance(songLower, existingSongLower);

                const artistSim = 1 - (artistDist / Math.max(artistLower.length, existingArtistLower.length));
                const songSim = 1 - (songDist / Math.max(songLower.length, existingSongLower.length));

                // If both artist and song are very similar, or exact match
                if ((artistSim > threshold && songSim > threshold) || 
                    (artistLower === existingArtistLower && songLower === existingSongLower)) {
                    similar.push({
                        song: existingSong,
                        artistSimilarity: artistSim,
                        songSimilarity: songSim,
                        index: index
                    });
                }
            });

            return similar;
        }

        function showDuplicateWarning(similarSongs, callback) {
            if (similarSongs.length === 0) {
                callback(true);
                return;
            }

            const duplicateList = similarSongs.map(item => 
                `‚Ä¢ ${escapeHtml(item.song.song)} by ${escapeHtml(item.song.artist)}`
            ).join('\n');

            const message = `‚ö†Ô∏è Found ${similarSongs.length} similar song(s):\n\n${duplicateList}\n\nDo you want to add this song anyway?`;
            
            if (confirm(message)) {
                callback(true);
            } else {
                callback(false);
            }
        }

        function cleanExpiredTrash() {
            const now = Date.now();
            const retentionMs = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000;
            trash = trash.filter(item => (now - item.deletedAt) < retentionMs);
            saveTrash();
        }

        function moveToTrash(song) {
            trash.push({
                song: JSON.parse(JSON.stringify(song)),
                deletedAt: Date.now()
            });
            saveTrash();
        }

        function restoreFromTrash(index) {
            const item = trash[index];
            if (!item || !item.song) {
                showToast('Invalid trash item', 'error');
                return;
            }
            
            console.log('Restoring:', item.song.song, 'by', item.song.artist);
            
            // Add back to songs
            songs.push(item.song);
            
            // Remove from trash
            trash.splice(index, 1);
            
            // Save
            localStorage.setItem('songDatabase', JSON.stringify(songs));
            localStorage.setItem('songTrash', JSON.stringify(trash));
            
            // Show message and reload page
            showToast(`Restoring song - page will reload...`, 'success');
            setTimeout(() => location.reload(), 800);
        }

        function restoreAllFromTrash() {
            if (trash.length === 0) {
                showToast('Trash is empty', 'info');
                return;
            }
            
            const count = trash.length;
            
            // Add all songs back
            trash.forEach(item => {
                songs.push(item.song);
            });
            
            // Clear trash
            trash = [];
            
            // Save
            localStorage.setItem('songDatabase', JSON.stringify(songs));
            localStorage.setItem('songTrash', JSON.stringify(trash));
            
            // Reload
            showToast(`Restoring ${count} songs - page will reload...`, 'success');
            setTimeout(() => location.reload(), 800);
        }

        function emergencyRecovery() {
            console.log('=== EMERGENCY RECOVERY ===');
            console.log('Current songs count:', songs.length);
            console.log('Current trash count:', trash.length);
            
            // Check localStorage for backup data
            const backupSongs = localStorage.getItem('songDatabase');
            const backupTrash = localStorage.getItem('songTrash');
            
            console.log('LocalStorage songDatabase:', backupSongs ? JSON.parse(backupSongs).length : 0);
            console.log('LocalStorage songTrash:', backupTrash ? JSON.parse(backupTrash).length : 0);
            
            // Show recovery dialog
            const message = `Current State:
- Songs in table: ${songs.length}
- Songs in trash: ${trash.length}
- Songs in localStorage: ${backupSongs ? JSON.parse(backupSongs).length : 0}
- Trash in localStorage: ${backupTrash ? JSON.parse(backupTrash).length : 0}

What would you like to do?
1. Reload from localStorage (may restore lost songs)
2. Export current data to CSV as backup
3. Cancel`;
            
            const choice = prompt(message + '\n\nEnter 1, 2, or 3:');
            
            if (choice === '1') {
                // Reload from localStorage
                songs = backupSongs ? JSON.parse(backupSongs) : [];
                trash = backupTrash ? JSON.parse(backupTrash) : [];
                
                // Clear filters and re-render
                document.getElementById('searchBox').value = '';
                activeFilters = [];
                updateFilterTags();
                renderSongs(songs);
                updateStats();
                renderTrashContent();
                
                showToast(`Reloaded: ${songs.length} songs, ${trash.length} in trash`, 'success');
                console.log('Recovery complete - songs:', songs.length, 'trash:', trash.length);
            } else if (choice === '2') {
                exportToCSV();
            }
        }

        function deleteFromTrashPermanently(index) {
            const item = trash[index];
            if (confirm(`Permanently delete "${item.song.song}" by ${item.song.artist}? This cannot be undone!`)) {
                trash.splice(index, 1);
                saveTrash();
                renderTrashContent();
                showToast('Permanently deleted', 'warning');
            }
        }

        function emptyTrash() {
            if (trash.length === 0) {
                showToast('Trash is already empty', 'info');
                return;
            }
            if (confirm(`Permanently delete all ${trash.length} item(s) in trash? This cannot be undone!`)) {
                trash = [];
                saveTrash();
                renderTrashContent();
                showToast('Trash emptied', 'warning');
            }
        }

        function updateTrashCount() {
            document.getElementById('trashCount').textContent = trash.length;
        }

        function openTrashModal() {
            cleanExpiredTrash();
            renderTrashContent();
            document.getElementById('trashModal').classList.add('active');
        }

        function closeTrashModal() {
            document.getElementById('trashModal').classList.remove('active');
        }

        function renderTrashContent() {
            const container = document.getElementById('trashContent');
            
            if (trash.length === 0) {
                container.innerHTML = '<div class="no-data">Trash is empty</div>';
                return;
            }

            const now = Date.now();
            const retentionMs = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000;

            container.innerHTML = trash.map((item, index) => {
                const timeLeft = retentionMs - (now - item.deletedAt);
                const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                const daysLeft = Math.floor(hoursLeft / 24);
                const timeLeftStr = daysLeft > 0 
                    ? `${daysLeft} day${daysLeft !== 1 ? 's' : ''} left`
                    : `${hoursLeft} hour${hoursLeft !== 1 ? 's' : ''} left`;

                return `
                    <div class="import-item" style="margin-bottom: 10px;">
                        <h4>${escapeHtml(item.song.song)} - ${escapeHtml(item.song.artist)}</h4>
                        <div style="font-size: 13px; color: #999; margin-top: 5px;">
                            ${item.song.album ? `Album: ${escapeHtml(item.song.album)} ‚Ä¢ ` : ''}
                            ${item.song.key ? `Key: ${escapeHtml(item.song.key)} ‚Ä¢ ` : ''}
                            <span style="color: #f59e0b;">${timeLeftStr}</span>
                        </div>
                        <div class="button-group" style="margin-top: 10px;">
                            <button class="btn-success btn-small" onclick="restoreFromTrash(${index})">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                    <path d="M3 7v6h6"/>
                                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                                </svg>
                                Restore
                            </button>
                            <button class="btn-danger btn-small" onclick="deleteFromTrashPermanently(${index})">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                    <line x1="18" y1="6" x2="6" y2="18"/>
                                    <line x1="6" y1="6" x2="18" y2="18"/>
                                </svg>
                                Delete Permanently
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Column Visibility Management
        function toggleColumnVisibilityPanel() {
            const panel = document.getElementById('columnVisibilityPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function initColumnCheckboxes() {
            const container = document.getElementById('columnCheckboxes');
            const mobileContainer = document.getElementById('mobileColumnCheckboxes');
            const columns = [
                { id: 'artist', label: 'Artist' },
                { id: 'song', label: 'Song' },
                { id: 'album', label: 'Album' },
                { id: 'duration', label: 'Duration' },
                { id: 'practiceStatus', label: 'Status' },
                { id: 'link', label: 'Link' },
                { id: 'tuning', label: 'Tuning' },
                { id: 'bands', label: 'Bands' },
                { id: 'tags', label: 'Tags' },
                { id: 'key', label: 'Key' },
                { id: 'firstNote', label: 'First Note' },
                { id: 'lastNote', label: 'Last Note' },
                { id: 'playCount', label: 'Plays' },
                { id: 'actions', label: 'Actions' }
            ];
            
            const checkboxHTML = columns.map(col => `
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                    <input type="checkbox" class="col-checkbox-${col.id}" checked onchange="toggleColumn('${col.id}')">
                    <span>${col.label}</span>
                </label>
            `).join('');
            
            // Populate both desktop and mobile
            if (container) container.innerHTML = checkboxHTML;
            if (mobileContainer) mobileContainer.innerHTML = checkboxHTML;
        }

        function toggleColumn(columnName) {
            const checkboxes = document.querySelectorAll(`.col-checkbox-${columnName}`);
            const isChecked = checkboxes[0] && checkboxes[0].checked;
            
            if (isChecked) {
                hiddenColumns.delete(columnName);
            } else {
                hiddenColumns.add(columnName);
            }
            
            // Sync all checkboxes with same name
            checkboxes.forEach(cb => cb.checked = isChecked);
            
            // Save to localStorage
            localStorage.setItem('hiddenColumns', JSON.stringify([...hiddenColumns]));
            
            // Re-render the table
            applyFilters();
        }

        function loadColumnVisibility() {
            const saved = localStorage.getItem('hiddenColumns');
            if (saved) {
                hiddenColumns = new Set(JSON.parse(saved));
                // Update all checkboxes
                hiddenColumns.forEach(col => {
                    const checkboxes = document.querySelectorAll(`.col-checkbox-${col}`);
                    checkboxes.forEach(cb => {
                        if (cb) cb.checked = false;
                    });
                });
            }
        }

        // Table Density Management
        let currentDensity = 'normal'; // normal, compact, spacious
        const densityModes = ['compact', 'normal', 'spacious'];

        function cycleDensity() {
            const currentIndex = densityModes.indexOf(currentDensity);
            const nextIndex = (currentIndex + 1) % densityModes.length;
            currentDensity = densityModes[nextIndex];
            
            applyDensity();
            saveDensity();
        }

        function applyDensity() {
            const table = document.querySelector('table');
            
            // Remove all density classes
            table.classList.remove('table-compact', 'table-spacious');
            
            // Apply current density class
            if (currentDensity === 'compact') {
                table.classList.add('table-compact');
            } else if (currentDensity === 'spacious') {
                table.classList.add('table-spacious');
            }
            
            // Update button label
            const label = document.getElementById('densityLabel');
            label.textContent = currentDensity.charAt(0).toUpperCase() + currentDensity.slice(1);
        }

        function saveDensity() {
            localStorage.setItem('tableDensity', currentDensity);
        }

        function loadDensity() {
            const saved = localStorage.getItem('tableDensity');
            if (saved && densityModes.includes(saved)) {
                currentDensity = saved;
                applyDensity();
            }
        }

        // Saved Filters Management
        let savedFilters = [];

        function loadSavedFilters() {
            const saved = localStorage.getItem('savedFilters');
            if (saved) {
                savedFilters = JSON.parse(saved);
                updateSavedFiltersDropdown();
            }
        }

        function saveSavedFilters() {
            localStorage.setItem('savedFilters', JSON.stringify(savedFilters));
        }

        function updateSavedFiltersDropdown() {
            const dropdown = document.getElementById('savedFiltersDropdown');
            const mobileDropdown = document.getElementById('mobileSavedFiltersDropdown');
            
            const optionsHTML = '<option value="">-- Select a saved filter --</option>' + 
                savedFilters.map((filter, index) => 
                    `<option value="${index}">${filter.name}</option>`
                ).join('');
            
            if (dropdown) dropdown.innerHTML = optionsHTML;
            if (mobileDropdown) mobileDropdown.innerHTML = optionsHTML;
        }

        function openSaveFilterModal() {
            // Show current filter settings
            const summary = [];
            
            if (searchTerm) {
                summary.push(`Search: "${searchTerm}"`);
            }
            
            if (activeFilters.length > 0) {
                summary.push(`Active Filters: ${activeFilters.length}`);
                activeFilters.forEach(f => {
                    summary.push(`  - ${f.column}: ${f.value}`);
                });
            }
            
            if (currentSort.column) {
                summary.push(`Sort: ${currentSort.column} (${currentSort.direction})`);
            }
            
            if (summary.length === 0) {
                summary.push('No filters or search active');
            }
            
            document.getElementById('currentFilterSummary').innerHTML = summary.join('<br>');
            document.getElementById('filterNameInput').value = '';
            document.getElementById('saveFilterModal').classList.add('active');
            setTimeout(() => document.getElementById('filterNameInput').focus(), 100);
        }

        function closeSaveFilterModal() {
            document.getElementById('saveFilterModal').classList.remove('active');
        }

        function saveCurrentFilter() {
            const name = document.getElementById('filterNameInput').value.trim();
            
            if (!name) {
                showToast('‚ö†Ô∏è Please enter a filter name', 'error');
                return;
            }
            
            // Check if name already exists
            if (savedFilters.some(f => f.name === name)) {
                if (!confirm(`A filter named "${name}" already exists. Overwrite it?`)) {
                    return;
                }
                // Remove existing filter
                savedFilters = savedFilters.filter(f => f.name !== name);
            }
            
            // Save current state
            const filterState = {
                name: name,
                searchTerm: searchTerm,
                activeFilters: JSON.parse(JSON.stringify(activeFilters)),
                sort: JSON.parse(JSON.stringify(currentSort)),
                timestamp: new Date().toISOString()
            };
            
            savedFilters.push(filterState);
            saveSavedFilters();
            updateSavedFiltersDropdown();
            closeSaveFilterModal();
            
            showToast(`‚úì Saved filter: "${name}"`);
        }

        function applySavedFilter() {
            // Get selected index from either desktop or mobile dropdown
            const dropdown = document.getElementById('savedFiltersDropdown');
            const mobileDropdown = document.getElementById('mobileSavedFiltersDropdown');
            
            const selectedIndex = dropdown ? dropdown.value : (mobileDropdown ? mobileDropdown.value : '');
            
            if (selectedIndex === '') return;
            
            const filter = savedFilters[parseInt(selectedIndex)];
            
            // Apply search term
            searchTerm = filter.searchTerm || '';
            const searchBox = document.getElementById('searchBox');
            if (searchBox) searchBox.value = searchTerm;
            
            // Clear and apply filters
            activeFilters = JSON.parse(JSON.stringify(filter.activeFilters || []));
            
            // Apply sort
            if (filter.sort && filter.sort.column) {
                currentSort = JSON.parse(JSON.stringify(filter.sort));
            }
            
            // Update both filter displays (PC and mobile)
            updateFilterTags();
            renderActiveFilters();
            
            // Re-render
            invalidateFilterCache();
            applyFilters();
            
            // Sync both dropdowns to show the same selection
            if (dropdown) dropdown.value = selectedIndex;
            if (mobileDropdown) mobileDropdown.value = selectedIndex;
            
            showToast(`‚úì Applied filter: "${filter.name}"`);
        }

        function openManageFiltersModal() {
            renderSavedFiltersList();
            document.getElementById('manageFiltersModal').classList.add('active');
        }

        function closeManageFiltersModal() {
            document.getElementById('manageFiltersModal').classList.remove('active');
        }

        function renderSavedFiltersList() {
            const container = document.getElementById('savedFiltersList');
            
            if (savedFilters.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px 20px;">No saved filters yet. Save your current search and filters to quickly access them later!</p>';
                return;
            }
            
            container.innerHTML = savedFilters.map((filter, index) => `
                <div style="background: rgba(40, 40, 40, 0.5); padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 5px 0; color: var(--primary-color);">${escapeHtml(filter.name)}</h3>
                            <p style="margin: 0; font-size: 0.85em; color: #999;">
                                Saved: ${new Date(filter.timestamp).toLocaleDateString()}
                            </p>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn-success btn-small" onclick="applySavedFilterByIndex(${index}); closeManageFiltersModal();" title="Apply this filter">
                                ‚úì Apply
                            </button>
                            <button class="btn-danger btn-small" onclick="deleteSavedFilter(${index})" title="Delete this filter">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 0.9em; color: #ccc;">
                        ${filter.searchTerm ? `<div>üîç Search: "${escapeHtml(filter.searchTerm)}"</div>` : ''}
                        ${filter.activeFilters && filter.activeFilters.length > 0 ? `<div>üéØ Filters: ${filter.activeFilters.length} active</div>` : ''}
                        ${filter.sort && filter.sort.column ? `<div>‚ÜïÔ∏è Sort: ${filter.sort.column} (${filter.sort.direction})</div>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function applySavedFilterByIndex(index) {
            document.getElementById('savedFiltersDropdown').value = index;
            applySavedFilter();
        }

        function deleteSavedFilter(index) {
            const filter = savedFilters[index];
            
            if (!confirm(`Delete saved filter "${filter.name}"?`)) {
                return;
            }
            
            savedFilters.splice(index, 1);
            saveSavedFilters();
            updateSavedFiltersDropdown();
            renderSavedFiltersList();
            
            showToast(`‚úì Deleted filter: "${filter.name}"`);
        }
        
        // ============================================================================
        // ADVANCED MULTI-COLUMN FILTERING SYSTEM
        // ============================================================================
        
        // Open filter builder modal
        function addFilter() {
            document.getElementById('filterBuilderModal').classList.add('active');
            document.getElementById('filterColumnSelect').value = '';
            document.getElementById('filterValueSelect').innerHTML = '<option value="">-- Select column first --</option>';
        }
        
        // Close filter builder modal
        function closeFilterBuilderModal() {
            document.getElementById('filterBuilderModal').classList.remove('active');
        }
        
        // Update value options based on selected column and existing filters
        function updateFilterValueOptions() {
            const columnSelect = document.getElementById('filterColumnSelect');
            const valueSelect = document.getElementById('filterValueSelect');
            const selectedColumn = columnSelect.value;
            
            if (!selectedColumn) {
                valueSelect.innerHTML = '<option value="">-- Select column first --</option>';
                return;
            }
            
            // Get the current filtered dataset (based on existing active filters)
            let dataToAnalyze = songs;
            
            // Apply existing filters to get contextual values
            if (activeFilters.length > 0) {
                // If filtering on the same column type, use all songs to allow OR logic
                const sameColumnFilters = activeFilters.filter(f => f.column === selectedColumn);
                if (sameColumnFilters.length > 0) {
                    // Same column: use all songs (OR logic within same column)
                    dataToAnalyze = songs;
                } else {
                    // Different column: use filtered results (AND logic between columns)
                    dataToAnalyze = applyFiltersToDataset(songs, activeFilters);
                }
            }
            
            // Get unique values from the column
            const uniqueValues = [...new Set(dataToAnalyze.map(song => {
                const value = song[selectedColumn];
                if (!value) return null;
                
                // Handle tags (array)
                if (selectedColumn === 'tags' && Array.isArray(value)) {
                    return value; // Will flatten later
                }
                return value;
            }).filter(v => v !== null && v !== ''))];
            
            // Flatten tags if needed
            let flatValues = [];
            uniqueValues.forEach(val => {
                if (Array.isArray(val)) {
                    flatValues.push(...val);
                } else {
                    flatValues.push(val);
                }
            });
            
            // Remove duplicates and sort
            flatValues = [...new Set(flatValues)].sort();
            
            // Populate dropdown
            if (flatValues.length === 0) {
                valueSelect.innerHTML = '<option value="">-- No values available --</option>';
            } else {
                valueSelect.innerHTML = '<option value="">-- Select value --</option>' +
                    flatValues.map(val => `<option value="${escapeHtml(val)}">${escapeHtml(val)}</option>`).join('');
            }
        }
        
        // Apply filters to a dataset (helper function)
        function applyFiltersToDataset(dataset, filters) {
            if (filters.length === 0) return dataset;
            
            return dataset.filter(song => {
                // Group filters by column for OR logic within same column
                const filtersByColumn = {};
                filters.forEach(filter => {
                    if (!filtersByColumn[filter.column]) {
                        filtersByColumn[filter.column] = [];
                    }
                    filtersByColumn[filter.column].push(filter.value);
                });
                
                // Check each column group (AND logic between columns)
                for (const [column, values] of Object.entries(filtersByColumn)) {
                    const songValue = song[column];
                    
                    // Handle tags (array)
                    if (column === 'tags' && Array.isArray(songValue)) {
                        // Check if any of the song's tags match any filter value
                        const hasMatch = songValue.some(tag => values.includes(tag));
                        if (!hasMatch) return false;
                    } else {
                        // Check if song value matches any of the filter values (OR within column)
                        if (!values.includes(songValue)) return false;
                    }
                }
                
                return true; // Passed all filter groups
            });
        }
        
        // Apply new filter from modal
        function applyNewFilter() {
            const column = document.getElementById('filterColumnSelect').value;
            const value = document.getElementById('filterValueSelect').value;
            
            if (!column || !value) {
                showToast('Please select both column and value', 'error');
                return;
            }
            
            // Add to active filters
            activeFilters.push({ column, value });
            
            // Update UI and apply filters - sync both PC and mobile displays
            updateFilterTags();
            renderActiveFilters();
            invalidateFilterCache();
            applyFilters();
            closeFilterBuilderModal();
            
            showToast(`‚úì Filter added: ${formatFieldName(column)} = ${value}`, 'success', 2000);
        }
        
        // Render active filter chips
        function renderActiveFilters() {
            const container = document.getElementById('activeFilters');
            const mobileContainer = document.getElementById('mobileActiveFilters');
            
            const noFiltersHTML = '<p style="color: #999; font-size: 13px; font-style: italic;">No active filters</p>';
            const filtersHTML = activeFilters.length === 0 ? noFiltersHTML : activeFilters.map((filter, index) => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(40, 40, 40, 0.8); border: 2px solid var(--primary-color); border-radius: 6px;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
                    </svg>
                    <span style="flex: 1; font-size: 13px;">
                        <strong style="color: var(--primary-light);">${formatFieldName(filter.column)}:</strong> 
                        ${escapeHtml(filter.value)}
                    </span>
                    <button onclick="removeFilter(${index})" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px; display: flex; align-items: center;" title="Remove filter">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            `).join('');
            
            if (container) container.innerHTML = filtersHTML;
            if (mobileContainer) mobileContainer.innerHTML = filtersHTML;
        }
        
        // Clear all filters (advanced filter modal version - redirects to main clearAllFilters)
        function clearAllFiltersAdvanced() {
            clearAllFilters();
        }
        
        // NOTE: applyAdvancedFilters() has been removed - all filtering now uses the unified applyFilters() function
        // which already handles OR logic within columns and AND logic between columns

        // Apply default sort (Artist ‚Üí Album ‚Üí Song)
        function applyDefaultSort() {
            songs.sort((a, b) => {
                // Sort by Artist first
                const artistA = (a.artist || '').toLowerCase();
                const artistB = (b.artist || '').toLowerCase();
                if (artistA < artistB) return -1;
                if (artistA > artistB) return 1;
                
                // If artists are the same, sort by Album
                const albumA = (a.album || '').toLowerCase();
                const albumB = (b.album || '').toLowerCase();
                if (albumA < albumB) return -1;
                if (albumA > albumB) return 1;
                
                // If albums are the same, sort by Song
                const songA = (a.song || '').toLowerCase();
                const songB = (b.song || '').toLowerCase();
                if (songA < songB) return -1;
                if (songA > songB) return 1;
                
                return 0;
            });
            
            // Save the sorted order
            saveSongs();
        }

        // ============================================================================
        // SPOTIFY API INTEGRATION
        // ============================================================================
        
        let spotifyAccessToken = null;
        let spotifyTokenExpiry = null;
        
        // Get Spotify access token using Client Credentials Flow
        async function getSpotifyToken() {
            // Check if we have a valid cached token
            if (spotifyAccessToken && spotifyTokenExpiry && Date.now() < spotifyTokenExpiry) {
                return spotifyAccessToken;
            }
            
            // Get credentials from localStorage
            const clientId = localStorage.getItem('spotifyClientId');
            const clientSecret = localStorage.getItem('spotifyClientSecret');
            
            if (!clientId || !clientSecret) {
                throw new Error('Spotify credentials not configured. Click the gear icon to set them up.');
            }
            
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + btoa(clientId + ':' + clientSecret)
                    },
                    body: 'grant_type=client_credentials'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to authenticate with Spotify. Check your credentials.');
                }
                
                const data = await response.json();
                spotifyAccessToken = data.access_token;
                spotifyTokenExpiry = Date.now() + (data.expires_in * 1000) - 60000; // Refresh 1 min early
                
                return spotifyAccessToken;
            } catch (error) {
                throw new Error('Authentication failed: ' + error.message);
            }
        }
        
        // Search Spotify for tracks
        async function searchSpotify() {
            const searchInput = document.getElementById('spotifySearchInput');
            const query = searchInput.value.trim();
            
            if (!query) {
                alert('Please enter a search term');
                return;
            }
            
            const resultsDiv = document.getElementById('spotifyResults');
            resultsDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: #999;">Searching Spotify...</div>';
            resultsDiv.style.display = 'block';
            
            try {
                // Get access token
                const token = await getSpotifyToken();
                
                // Use Spotify's Web API with authentication
                const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Spotify API error: ${response.status}`);
                }
                
                const data = await response.json();
                displaySpotifyResults(data.tracks.items);
            } catch (error) {
                console.error('Spotify search error:', error);
                resultsDiv.innerHTML = `
                    <div style="padding: 15px; text-align: center; color: #ff6b6b; background: rgba(255,107,107,0.1); border-radius: 6px;">
                        <strong>Unable to search Spotify</strong><br>
                        <small style="color: #999; display: block; margin-top: 8px;">
                            ${error.message}
                        </small>
                        <button onclick="openSpotifySettings()" style="margin-top: 10px; padding: 8px 16px; background: #1ED760; color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Configure Spotify API
                        </button>
                    </div>
                `;
            }
        }
        
        // Open Spotify settings modal
        window.openSpotifySettings = function() {
            const clientId = localStorage.getItem('spotifyClientId') || '';
            const clientSecret = localStorage.getItem('spotifyClientSecret') || '';
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h2>Spotify API Settings</h2>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div style="padding: 20px;">
                        <div style="background: rgba(30, 215, 96, 0.1); border: 1px solid rgba(30, 215, 96, 0.3); border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                            <h3 style="margin: 0 0 10px 0; color: #1ED760;">How to get Spotify API credentials (Free!):</h3>
                            <ol style="margin: 10px 0; padding-left: 20px; color: #ccc; line-height: 1.8;">
                                <li>Go to <a href="https://developer.spotify.com/dashboard" target="_blank" style="color: #1ED760;">Spotify Developer Dashboard</a></li>
                                <li>Log in with your Spotify account (or create one - it's free!)</li>
                                <li>Click "Create app"</li>
                                <li>Fill in any name and description (e.g., "Band Practice Manager")</li>
                                <li>For "Redirect URI" enter: <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px;">http://localhost</code></li>
                                <li>Agree to terms and click "Save"</li>
                                <li>Click "Settings" and copy your <strong>Client ID</strong> and <strong>Client Secret</strong></li>
                                <li>Paste them below</li>
                            </ol>
                            <small style="color: #999;">Your credentials are stored locally in your browser only. They are never sent anywhere except directly to Spotify.</small>
                        </div>
                        
                        <div class="form-group">
                            <label>Client ID *</label>
                            <input type="text" id="spotifyClientIdInput" value="${clientId}" placeholder="e.g., a1b2c3d4e5f6g7h8i9j0" style="font-family: monospace;">
                        </div>
                        
                        <div class="form-group">
                            <label>Client Secret *</label>
                            <input type="password" id="spotifyClientSecretInput" value="${clientSecret}" placeholder="e.g., 1a2b3c4d5e6f7g8h9i0j" style="font-family: monospace;">
                            <small style="color: #999; display: block; margin-top: 5px;">
                                <label style="cursor: pointer;">
                                    <input type="checkbox" onchange="document.getElementById('spotifyClientSecretInput').type = this.checked ? 'text' : 'password'">
                                    Show Client Secret
                                </label>
                            </small>
                        </div>
                        
                        <div class="button-group">
                            <button class="btn btn-success" onclick="saveSpotifySettings()">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                                Save Settings
                            </button>
                            <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                            ${clientId && clientSecret ? `
                                <button class="btn btn-danger" onclick="clearSpotifySettings()" style="margin-left: auto;">
                                    Clear Settings
                                </button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        // Save Spotify settings
        window.saveSpotifySettings = function() {
            const clientId = document.getElementById('spotifyClientIdInput').value.trim();
            const clientSecret = document.getElementById('spotifyClientSecretInput').value.trim();
            
            if (!clientId || !clientSecret) {
                alert('Please enter both Client ID and Client Secret');
                return;
            }
            
            localStorage.setItem('spotifyClientId', clientId);
            localStorage.setItem('spotifyClientSecret', clientSecret);
            
            // Clear cached token so it refreshes with new credentials
            spotifyAccessToken = null;
            spotifyTokenExpiry = null;
            
            alert('Spotify settings saved! You can now search for songs.');
            document.querySelector('.modal').remove();
        };
        
        // Clear Spotify settings
        window.clearSpotifySettings = function() {
            if (confirm('Are you sure you want to remove your Spotify API credentials?')) {
                localStorage.removeItem('spotifyClientId');
                localStorage.removeItem('spotifyClientSecret');
                spotifyAccessToken = null;
                spotifyTokenExpiry = null;
                alert('Spotify settings cleared');
                document.querySelector('.modal').remove();
            }
        };
        
        // Display Spotify search results
        function displaySpotifyResults(tracks) {
            const resultsDiv = document.getElementById('spotifyResults');
            
            if (!tracks || tracks.length === 0) {
                resultsDiv.innerHTML = '<div style="padding: 15px; text-align: center; color: #999;">No results found. Try a different search term.</div>';
                return;
            }
            
            const html = tracks.map(track => {
                const artists = track.artists.map(a => a.name).join(', ');
                const album = track.album.name;
                const duration = millisToMinutes(track.duration_ms);
                const imageUrl = track.album.images[2]?.url || track.album.images[0]?.url || '';
                const releaseYear = track.album.release_date ? track.album.release_date.split('-')[0] : '';
                
                return `
                    <div style="display: flex; align-items: center; gap: 12px; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(30, 215, 96, 0.3); border-radius: 6px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s;" 
                         onclick='selectSpotifyTrack(${JSON.stringify({
                             artist: artists,
                             song: track.name,
                             album: album,
                             duration: duration,
                             year: releaseYear,
                             link: track.external_urls.spotify
                         })})' 
                         onmouseover="this.style.background='rgba(30, 215, 96, 0.2)'; this.style.borderColor='rgba(30, 215, 96, 0.5)'"
                         onmouseout="this.style.background='rgba(0,0,0,0.3)'; this.style.borderColor='rgba(30, 215, 96, 0.3)'">
                        ${imageUrl ? `<img src="${imageUrl}" alt="Album art" style="width: 50px; height: 50px; border-radius: 4px;">` : '<div style="width: 50px; height: 50px; background: rgba(255,255,255,0.1); border-radius: 4px;"></div>'}
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: #e0e0e0; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(track.name)}</div>
                            <div style="font-size: 13px; color: #999; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(artists)}</div>
                            <div style="font-size: 12px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(album)}${releaseYear ? ` ‚Ä¢ ${releaseYear}` : ''} ‚Ä¢ ${duration}</div>
                        </div>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#1ED760" stroke-width="2">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </div>
                `;
            }).join('');
            
            resultsDiv.innerHTML = html;
        }
        
        // Convert milliseconds to mm:ss format
        function millisToMinutes(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Select a Spotify track and populate the form
        window.selectSpotifyTrack = function(trackData) {
            document.getElementById('artist').value = trackData.artist;
            document.getElementById('song').value = trackData.song;
            document.getElementById('album').value = trackData.album;
            document.getElementById('duration').value = trackData.duration;
            document.getElementById('year').value = trackData.year;
            document.getElementById('link').value = trackData.link;
            
            // Hide results and clear search
            document.getElementById('spotifyResults').style.display = 'none';
            document.getElementById('spotifySearchInput').value = '';
            
            // Show success message
            const resultsDiv = document.getElementById('spotifyResults');
            resultsDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: #1ED760; background: rgba(30, 215, 96, 0.1); border-radius: 6px; margin-top: 10px;">‚úì Song details loaded from Spotify!</div>';
            resultsDiv.style.display = 'block';
            setTimeout(() => {
                resultsDiv.style.display = 'none';
            }, 2000);
            
            // Focus on the first empty field or the save button
            const firstEmptyField = document.querySelector('#songForm input:not([value]), #songForm input[value=""]');
            if (firstEmptyField) {
                firstEmptyField.focus();
            }
        };
        
        // Allow Enter key to search Spotify
        document.addEventListener('DOMContentLoaded', () => {
            const spotifyInput = document.getElementById('spotifySearchInput');
            if (spotifyInput) {
                spotifyInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        searchSpotify();
                    }
                });
            }
        });

        // Toggle left sidebar
        function toggleLeftSidebar() {
            const sidebar = document.querySelector('.left-sidebar');
            sidebar.classList.toggle('collapsed');
            localStorage.setItem('leftSidebarCollapsed', sidebar.classList.contains('collapsed'));
        }

        // Load data on page load
        window.onload = function() {
            // Theme already loaded by inline script below
            loadWatermark(); // Load watermark preference
            loadColumnVisibility(); // Load column visibility preferences
            loadDensity(); // Load table density preference
            loadSavedFilters(); // Load saved filters
            loadStatsPreferences(); // Load stats widget preferences
            loadSongs();
            loadTrash(); // Load trash
            applyDefaultSort(); // Sort by Artist ‚Üí Album ‚Üí Song
            applyFilters();
            updateStats();
            updateBulkActionsFooter();
            initColumnResizing(); // Initialize column resizing
            initColumnCheckboxes(); // Populate column visibility checkboxes
            syncMobileBandFilter(); // Populate mobile band filter
            
            // Ensure save indicator is hidden on page load
            const saveIndicator = document.getElementById('saveIndicator');
            if (saveIndicator) {
                saveIndicator.classList.remove('show', 'saved');
            }
            
            // Load left sidebar collapse state
            const leftSidebarCollapsed = localStorage.getItem('leftSidebarCollapsed') === 'true';
            if (leftSidebarCollapsed) {
                document.querySelector('.left-sidebar').classList.add('collapsed');
            }
            
            // Check for pending CSV import from Mobile Guide Wizard
            checkPendingImport();
            
            // Check for URL parameters (like ?action=backup)
            checkUrlParameters();
            
            // Enable drag-to-scroll on the table
            enableDragScroll();
            
            // Check if we need to search for a song from setlist manager
            const editSongSearch = localStorage.getItem('editSongSearch');
            if (editSongSearch) {
                try {
                    const { artist, song } = JSON.parse(editSongSearch);
                    // Set the search term
                    document.getElementById('searchBox').value = `${artist} ${song}`;
                    searchTerm = `${artist} ${song}`;
                    applyFilters();
                    // Clear the localStorage item
                    localStorage.removeItem('editSongSearch');
                    // Show a toast
                    showToast(`üîç Showing results for: ${artist} - ${song}`);
                } catch (e) {
                    console.error('Error parsing editSongSearch:', e);
                    localStorage.removeItem('editSongSearch');
                }
            }
            
            // Performance: Debounced resize handler
            const handleResize = debounce(() => {
                // Handle any resize-dependent logic here
                // Currently minimal impact, but prevents issues if expanded later
                console.log('Window resized');
            }, 150);
            window.addEventListener('resize', handleResize);
        };
        
        // Check for pending CSV import from Mobile Guide Wizard
        function checkPendingImport() {
            const pendingCSV = localStorage.getItem('pendingCSVImport');
            const pendingFilename = localStorage.getItem('pendingCSVFilename');
            
            if (pendingCSV) {
                // Clear the pending import
                localStorage.removeItem('pendingCSVImport');
                localStorage.removeItem('pendingCSVFilename');
                
                // Show notification
                const filename = pendingFilename || 'file';
                showToast(`üì• Importing ${filename} from Mobile Guide...`, 'info');
                
                // Parse and import the CSV
                setTimeout(() => {
                    parseCSV(pendingCSV);
                }, 500);
            }
        }
        
        // Check URL parameters for actions
        function checkUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const action = urlParams.get('action');
            
            if (action === 'backup') {
                // Trigger backup after a short delay
                setTimeout(() => {
                    exportAllData();
                    showToast('üíæ Creating backup...', 'info');
                }, 1000);
            }
        }
        
        // Enable drag-to-scroll on center pane (desktop) - Horizontal only, fully optimized
        function enableDragScroll() {
            const centerPane = document.querySelector('.center-pane');
            if (!centerPane) return;
            
            let isDragging = false;
            let startX = 0;
            let scrollLeft = 0;
            
            function stopDragging() {
                isDragging = false;
                centerPane.classList.remove('dragging');
                document.body.style.userSelect = '';
            }
            
            centerPane.addEventListener('mousedown', (e) => {
                // Only enable drag on the container itself or on non-interactive elements
                const target = e.target;
                if (
                    target.tagName === 'BUTTON' ||
                    target.tagName === 'INPUT' ||
                    target.tagName === 'A' ||
                    target.tagName === 'SELECT' ||
                    target.closest('button') ||
                    target.closest('a') ||
                    target.closest('input') ||
                    target.closest('select') ||
                    target.closest('.sortable')
                ) {
                    return;
                }
                
                isDragging = true;
                centerPane.classList.add('dragging');
                document.body.style.userSelect = 'none';
                
                // Use clientX which is relative to viewport (more reliable)
                startX = e.clientX;
                scrollLeft = centerPane.scrollLeft;
            });
            
            // Use window-level events to catch mouse activity outside the element
            window.addEventListener('mouseup', () => {
                if (isDragging) {
                    stopDragging();
                }
            });
            
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                
                // Use clientX for viewport-relative position (no offset calculations needed)
                const x = e.clientX;
                const walk = (x - startX);
                
                // Direct scroll update - simple and fast
                centerPane.scrollLeft = scrollLeft - walk;
            });
            
            // Also handle when mouse leaves the entire window/document
            document.addEventListener('mouseleave', () => {
                if (isDragging) {
                    stopDragging();
                }
            });
        }

        // Load and apply watermark preference
        function loadWatermark() {
            const watermark = localStorage.getItem('watermark') || 'guitar';
            
            // Remove all watermark classes
            document.body.classList.remove('drum-watermark', 'blackdoubt-watermark');
            
            // Apply appropriate class and styles
            if (watermark === 'drum') {
                document.body.classList.add('drum-watermark');
                updateIconStyles('drum');
                updateFavicon('drum');
            } else if (watermark === 'blackdoubt') {
                document.body.classList.add('blackdoubt-watermark');
                updateIconStyles('blackdoubt');
                updateFavicon('blackdoubt');
            } else {
                // Guitar is default
                updateIconStyles('guitar');
                updateFavicon('guitar');
            }
        }

        // Switch watermark
        function switchWatermark(type) {
            localStorage.setItem('watermark', type);
            
            // Remove all watermark classes
            document.body.classList.remove('drum-watermark', 'blackdoubt-watermark');
            
            // Add appropriate class
            if (type === 'drum') {
                document.body.classList.add('drum-watermark');
            } else if (type === 'blackdoubt') {
                document.body.classList.add('blackdoubt-watermark');
            }
            // 'guitar' is default - no class needed
            
            updateIconStyles(type);
            updateFavicon(type);
        }

        // Update favicon to match watermark
        function updateFavicon(type) {
            const currentTheme = localStorage.getItem('bandOrganizerTheme') || 'grey';
            updateFaviconForTheme(currentTheme);
        }

        // Update icon styles to show which is active
        function updateIconStyles(activeType) {
            const guitarIcon = document.getElementById('guitarIcon');
            const drumIcon = document.getElementById('drumIcon');
            const blackdoubtIcon = document.getElementById('blackDoubtIcon');
            
            // Reset all icons to inactive state
            if (guitarIcon) guitarIcon.style.opacity = '0.5';
            if (drumIcon) drumIcon.style.opacity = '0.5';
            if (blackdoubtIcon) blackdoubtIcon.style.opacity = '0.5';
            
            // Highlight active icon
            if (activeType === 'guitar' && guitarIcon) {
                guitarIcon.style.opacity = '1';
            } else if (activeType === 'drum' && drumIcon) {
                drumIcon.style.opacity = '1';
            } else if (activeType === 'blackdoubt' && blackdoubtIcon) {
                blackdoubtIcon.style.opacity = '1';
            }
        }

        // Load songs from localStorage
        function loadSongs() {
            // Try both keys for backward compatibility
            const stored = localStorage.getItem('songDatabase') || localStorage.getItem('bandSongs');
            if (stored) {
                songs = JSON.parse(stored);
                console.log('Loaded', songs.length, 'songs from localStorage');
                
                // Migration: Add chordChart field if it doesn't exist
                let migrated = false;
                songs = songs.map(song => {
                    if (!song.hasOwnProperty('chordChart')) {
                        migrated = true;
                        return { ...song, chordChart: null };
                    }
                    return song;
                });
                
                if (migrated) {
                    console.log('Migrated songs to include chordChart field');
                    saveSongs();
                }
            } else {
                console.log('No songs found in localStorage');
                // No existing data - load demo data for first-time users
                loadDemoData();
            }
        }
        
        // Load demo data for first-time users
        function loadDemoData() {
            // Create a sample chord chart for "Let It Be"
            const demoChordChart = {
                capo: '',
                tuning: '',
                components: [
                    {
                        type: 'section',
                        name: 'Verse 1',
                        lyrics: 'C               G\nWhen I find myself in times of trouble\nAm              F\nMother Mary comes to me\nC                 G              F    C\nSpeaking words of wisdom, let it be'
                    },
                    {
                        type: 'section',
                        name: 'Chorus',
                        lyrics: 'C           G           Am          F\nLet it be, let it be, let it be, let it be\nC              G              F    C\nWhisper words of wisdom, let it be'
                    },
                    {
                        type: 'section',
                        name: 'Bridge',
                        lyrics: 'Am         G          F           C\nAnd when the broken-hearted people\nAm         G             F         C\nLiving in the world agree\nC                G              F    C\nThere will be an answer, let it be'
                    }
                ]
            };
            
            songs = [
                {
                    id: generateId(),
                    artist: 'The Beatles',
                    song: 'Let It Be',
                    album: 'Let It Be',
                    year: '1970',
                    genre: 'Rock',
                    key: 'C',
                    tempo: '76',
                    duration: '4:03',
                    bands: 'Demo Band',
                    notes: 'Classic ballad - great for acoustic sets',
                    chordChart: demoChordChart
                },
                {
                    id: generateId(),
                    artist: 'Eagles',
                    song: 'Hotel California',
                    album: 'Hotel California',
                    year: '1976',
                    genre: 'Rock',
                    key: 'Bm',
                    tempo: '74',
                    duration: '6:30',
                    bands: 'Demo Band',
                    notes: 'Iconic guitar solo',
                    chordChart: null
                },
                {
                    id: generateId(),
                    artist: 'Queen',
                    song: 'Bohemian Rhapsody',
                    album: 'A Night at the Opera',
                    year: '1975',
                    genre: 'Rock',
                    key: 'Bb',
                    tempo: '72',
                    duration: '5:55',
                    bands: 'Demo Band',
                    notes: 'Epic multi-section masterpiece',
                    chordChart: null
                }
            ];
            
            // Save demo songs
            saveSongs();
            console.log('Demo data loaded:', songs.length, 'songs');
        }

        // Save songs to localStorage
        function saveSongs() {
            localStorage.setItem('songDatabase', JSON.stringify(songs));
            localStorage.setItem('bandSongs', JSON.stringify(songs)); // Keep backup copy
            
            // Invalidate filter cache when songs change
            invalidateFilterCache();
            
            // Performance: Invalidate stats cache
            invalidateStatsCache();
            
            showSaveIndicator();
            
            // Check for BlackDoubt band after saving
            checkForBlackDoubt();
        }

        // Render songs table
        function renderSongs(filteredSongs = null) {
            const tbody = document.getElementById('songTableBody');
            const displaySongs = filteredSongs || songs;

            // Update column visibility in headers (cache the lookup)
            const columns = ['checkbox', 'actions', 'link', 'artist', 'song', 'album', 'duration', 'practiceStatus', 'tuning', 'bands', 'tags', 'key', 'firstNote', 'lastNote', 'chordChart', 'playCount'];
            columns.forEach(col => {
                const headers = document.querySelectorAll(`.col-${col}`);
                const shouldHide = hiddenColumns.has(col);
                headers.forEach(header => {
                    header.classList.toggle('hidden-col', shouldHide);
                });
            });

            if (displaySongs.length === 0) {
                tbody.innerHTML = `<tr><td colspan="${columns.length - hiddenColumns.size}" class="no-data">No songs yet. Add your first song or import from CSV!</td></tr>`;
                return;
            }

            // Helper function to get practice status badge (cached)
            const badges = {
                'learning': '<span style="background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">üéì Learning</span>',
                'practicing': '<span style="background: #f59e0b; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">üéµ Practicing</span>',
                'ready': '<span style="background: #10b981; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">‚úì Ready</span>',
                'mastered': '<span style="background: #8b5cf6; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">‚≠ê Mastered</span>'
            };
            const getPracticeStatusBadge = (status) => badges[status] || '-';

            // Pre-compute hidden column classes (avoid repeated lookups)
            const colClasses = {};
            columns.forEach(col => {
                colClasses[col] = hiddenColumns.has(col) ? 'hidden-col' : '';
            });

            // Use array for faster string concatenation than .map().join()
            const rows = [];
            const len = displaySongs.length;
            
            for (let i = 0; i < len; i++) {
                const song = displaySongs[i];
                const originalIndex = song.originalIndex !== undefined ? song.originalIndex : i;
                const isSelected = selectedSongIndices.has(originalIndex);
                
                rows.push(`
                <tr>
                    <td class="col-checkbox ${colClasses.checkbox}">
                        <input type="checkbox" class="song-checkbox" ${isSelected ? 'checked' : ''} onchange="toggleSongSelection(${originalIndex}, event)" title="Select song">
                    </td>
                    <td class="col-actions ${colClasses.actions}">
                        <div class="action-buttons">
                            <button class="btn-secondary btn-small" onclick="editSong(${originalIndex})" title="Edit">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                </svg>
                            </button>
                            <button class="btn-danger btn-small" onclick="deleteSong(${originalIndex})" title="Delete">‚úï</button>
                        </div>
                    </td>
                    <td class="col-link ${colClasses.link}">${song.link ? `<a href="${escapeHtml(song.link)}" target="_blank" class="link-icon">üîó</a>` : '-'}</td>
                    <td class="col-artist ${colClasses.artist}">${escapeHtml(song.artist)}</td>
                    <td class="col-song ${colClasses.song}">${escapeHtml(song.song)}</td>
                    <td class="col-album ${colClasses.album}">${escapeHtml(song.album || '-')}</td>
                    <td class="col-duration ${colClasses.duration}">${escapeHtml(song.duration || '-')}</td>
                    <td class="col-practiceStatus ${colClasses.practiceStatus}">${getPracticeStatusBadge(song.practiceStatus)}</td>
                    <td class="col-tuning ${colClasses.tuning}">${escapeHtml(song.tuning || '-')}</td>
                    <td class="col-bands ${colClasses.bands}">${escapeHtml(song.bands || '-')}</td>
                    <td class="col-tags ${colClasses.tags}">${escapeHtml(song.tags || '-')}</td>
                    <td class="col-key ${colClasses.key}">${escapeHtml(song.key || '-')}</td>
                    <td class="col-firstNote ${colClasses.firstNote}">${escapeHtml(song.firstNote || '-')}</td>
                    <td class="col-lastNote ${colClasses.lastNote}">${escapeHtml(song.lastNote || '-')}</td>
                    <td class="col-chordChart ${colClasses.chordChart}">${song.chordChart ? `<a href="chord-chart-editor.html?songId=${originalIndex}" target="_blank" title="Edit Chord Chart" style="color: var(--primary-light); text-decoration: none; display: inline-flex; align-items: center; gap: 4px;"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg> Edit</a>` : `<a href="chord-chart-editor.html?songId=${originalIndex}" target="_blank" title="Create Chord Chart" style="color: var(--text-tertiary); text-decoration: none; display: inline-flex; align-items: center; gap: 4px;"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add</a>`}</td>
                    <td class="col-playCount ${colClasses.playCount}">${song.playCount || 0}</td>
                </tr>`);
            }
            
            tbody.innerHTML = rows.join('');
            updateBulkActionsBar();
        }

        // Update statistics (with memoization)
        function updateStats() {
            // Performance: Generate cache key from songs array
            const cacheKey = `${songs.length}-${songs.map(s => s.artist + s.bands).join(',')}`;
            
            // Return cached result if available
            if (statsCache && statsCacheKey === cacheKey) {
                // Update old stats (with null checks)
                const totalSongsEl = document.getElementById('totalSongs');
                const totalArtistsEl = document.getElementById('totalArtists');
                const totalBandsEl = document.getElementById('totalBands');
                const totalTagsEl = document.getElementById('totalTags');
                const avgDurationEl = document.getElementById('avgDuration');
                const mostPlayedEl = document.getElementById('mostPlayed');
                const readySongsEl = document.getElementById('readySongs');
                
                if (totalSongsEl) totalSongsEl.textContent = statsCache.totalSongs;
                if (totalArtistsEl) totalArtistsEl.textContent = statsCache.totalArtists;
                if (totalBandsEl) totalBandsEl.textContent = statsCache.totalBands;
                
                const totalTagsStat = document.querySelector('[data-stat="totalTags"]');
                if (totalTagsEl && totalTagsStat && totalTagsStat.style.display !== 'none') {
                    totalTagsEl.textContent = statsCache.totalTags;
                }
                
                const avgDurationStat = document.querySelector('[data-stat="avgDuration"]');
                if (avgDurationEl && avgDurationStat && avgDurationStat.style.display !== 'none') {
                    avgDurationEl.textContent = statsCache.avgDuration;
                }
                
                const mostPlayedStat = document.querySelector('[data-stat="mostPlayed"]');
                if (mostPlayedEl && mostPlayedStat && mostPlayedStat.style.display !== 'none') {
                    mostPlayedEl.textContent = statsCache.mostPlayed;
                }
                
                const readySongsStat = document.querySelector('[data-stat="readySongs"]');
                if (readySongsEl && readySongsStat && readySongsStat.style.display !== 'none') {
                    readySongsEl.textContent = statsCache.readySongs;
                }
                
                // Update compact header stats (always present in new design)
                const compactSongs = document.getElementById('compactTotalSongs');
                const compactArtists = document.getElementById('compactTotalArtists');
                const compactBands = document.getElementById('compactTotalBands');
                if (compactSongs) compactSongs.textContent = statsCache.totalSongs;
                if (compactArtists) compactArtists.textContent = statsCache.totalArtists;
                if (compactBands) compactBands.textContent = statsCache.totalBands;
                
                return;
            }
            
            // Calculate basic stats
            const totalSongs = songs.length;
            
            const uniqueArtists = new Set(songs.map(s => s.artist.toLowerCase()));
            const totalArtists = uniqueArtists.size;
            
            const uniqueBands = new Set();
            songs.forEach(s => {
                if (s.bands) {
                    s.bands.split(',').forEach(b => uniqueBands.add(b.trim().toLowerCase()));
                }
            });
            const totalBands = uniqueBands.size;
            
            // Calculate additional stats
            const uniqueTags = new Set();
            songs.forEach(s => {
                if (s.tags) {
                    s.tags.split(',').forEach(t => uniqueTags.add(t.trim().toLowerCase()));
                }
            });
            const totalTags = uniqueTags.size;
            
            // Calculate average duration
            let avgDuration = '-';
            const songsWithDuration = songs.filter(s => s.duration);
            if (songsWithDuration.length > 0) {
                const totalSeconds = songsWithDuration.reduce((sum, s) => {
                    const [min, sec] = s.duration.split(':').map(Number);
                    return sum + (min * 60) + (sec || 0);
                }, 0);
                const avgSeconds = Math.round(totalSeconds / songsWithDuration.length);
                const min = Math.floor(avgSeconds / 60);
                const sec = (avgSeconds % 60).toString().padStart(2, '0');
                avgDuration = `${min}:${sec}`;
            }
            
            // Find most played song
            let mostPlayed = '-';
            const maxPlays = Math.max(...songs.map(s => s.playCount || 0), 0);
            if (maxPlays > 0) {
                const topSong = songs.find(s => (s.playCount || 0) === maxPlays);
                if (topSong) {
                    mostPlayed = `${topSong.song} (${maxPlays}x)`;
                }
            }
            
            // Count ready/mastered songs
            const readySongs = songs.filter(s => s.practiceStatus === 'ready' || s.practiceStatus === 'mastered').length;
            
            // Cache the results
            statsCache = { totalSongs, totalArtists, totalBands, totalTags, avgDuration, mostPlayed, readySongs };
            statsCacheKey = cacheKey;
            
            // Update DOM (old stats - with null checks)
            const totalSongsEl = document.getElementById('totalSongs');
            const totalArtistsEl = document.getElementById('totalArtists');
            const totalBandsEl = document.getElementById('totalBands');
            const totalTagsEl = document.getElementById('totalTags');
            const avgDurationEl = document.getElementById('avgDuration');
            const mostPlayedEl = document.getElementById('mostPlayed');
            const readySongsEl = document.getElementById('readySongs');
            
            if (totalSongsEl) totalSongsEl.textContent = totalSongs;
            if (totalArtistsEl) totalArtistsEl.textContent = totalArtists;
            if (totalBandsEl) totalBandsEl.textContent = totalBands;
            if (totalTagsEl) totalTagsEl.textContent = totalTags;
            if (avgDurationEl) avgDurationEl.textContent = avgDuration;
            if (mostPlayedEl) mostPlayedEl.textContent = mostPlayed;
            if (readySongsEl) readySongsEl.textContent = readySongs;
            
            // Update compact header stats (always present in new design)
            const compactSongs = document.getElementById('compactTotalSongs');
            const compactArtists = document.getElementById('compactTotalArtists');
            const compactBands = document.getElementById('compactTotalBands');
            if (compactSongs) compactSongs.textContent = totalSongs;
            if (compactArtists) compactArtists.textContent = totalArtists;
            if (compactBands) compactBands.textContent = totalBands;
        }
        
        // Performance: Invalidate stats cache when songs change
        function invalidateStatsCache() {
            statsCache = null;
            statsCacheKey = null;
        }

        // Show/hide bulk actions footer based on selection
        function updateBulkActionsFooter() {
            const footer = document.getElementById('bulkActionsFooter');
            const count = document.getElementById('selectedCount');
            const selectedCount = selectedSongIndices.size;
            
            if (selectedCount > 0) {
                footer.style.display = 'flex';
                count.textContent = `${selectedCount} song${selectedCount !== 1 ? 's' : ''} selected`;
            } else {
                footer.style.display = 'none';
            }
        }

        // Stats Customizer Functions
        function toggleStatsCustomizer() {
            const panel = document.getElementById('statsCustomizer');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function toggleStat(statName) {
            const statCard = document.querySelector(`[data-stat="${statName}"]`);
            const checkbox = document.getElementById(`stat-${statName}`);
            
            if (checkbox.checked) {
                statCard.style.display = 'flex';
            } else {
                statCard.style.display = 'none';
            }
            
            // Save preference
            saveStatsPreferences();
        }

        function saveStatsPreferences() {
            const preferences = {
                totalSongs: document.getElementById('stat-totalSongs').checked,
                totalArtists: document.getElementById('stat-totalArtists').checked,
                totalBands: document.getElementById('stat-totalBands').checked,
                totalTags: document.getElementById('stat-totalTags').checked,
                avgDuration: document.getElementById('stat-avgDuration').checked,
                mostPlayed: document.getElementById('stat-mostPlayed').checked,
                readySongs: document.getElementById('stat-readySongs').checked
            };
            localStorage.setItem('statsPreferences', JSON.stringify(preferences));
        }

        function loadStatsPreferences() {
            const saved = localStorage.getItem('statsPreferences');
            if (!saved) return;
            
            try {
                const preferences = JSON.parse(saved);
                Object.keys(preferences).forEach(statName => {
                    const checkbox = document.getElementById(`stat-${statName}`);
                    const statCard = document.querySelector(`[data-stat="${statName}"]`);
                    if (checkbox && statCard) {
                        checkbox.checked = preferences[statName];
                        statCard.style.display = preferences[statName] ? 'flex' : 'none';
                    }
                });
            } catch (e) {
                console.error('Error loading stats preferences:', e);
            }
        }

        // Close stats customizer when clicking outside
        document.addEventListener('click', function(e) {
            const panel = document.getElementById('statsCustomizer');
            const btn = e.target.closest('button[onclick*="toggleStatsCustomizer"]');
            if (panel && panel.style.display !== 'none' && !panel.contains(e.target) && !btn) {
                panel.style.display = 'none';
            }
            
            // Close search help when clicking outside
            const helpPanel = document.getElementById('searchHelp');
            const helpBtn = e.target.closest('button[onclick*="toggleSearchHelp"]');
            if (helpPanel && helpPanel.style.display !== 'none' && !helpPanel.contains(e.target) && !helpBtn) {
                helpPanel.style.display = 'none';
            }
        });

        // Column Resizing
        let resizingColumn = null;
        let startX = 0;
        let startWidth = 0;
        const columnWidths = JSON.parse(localStorage.getItem('columnWidths') || '{}');

        function initColumnResizing() {
            const headers = document.querySelectorAll('#songTable th');
            headers.forEach((header, index) => {
                // Skip checkbox and actions columns
                if (header.classList.contains('col-checkbox') || header.classList.contains('col-actions')) {
                    return;
                }

                // Apply saved width if exists
                const columnClass = Array.from(header.classList).find(cls => cls.startsWith('col-'));
                if (columnClass && columnWidths[columnClass]) {
                    header.style.width = columnWidths[columnClass] + 'px';
                    header.style.minWidth = columnWidths[columnClass] + 'px';
                }

                // Create resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                header.appendChild(resizeHandle);

                resizeHandle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    resizingColumn = header;
                    startX = e.pageX;
                    startWidth = header.offsetWidth;
                    resizeHandle.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });

            document.addEventListener('mousemove', function(e) {
                if (!resizingColumn) return;

                const diff = e.pageX - startX;
                const newWidth = Math.max(50, startWidth + diff); // Minimum 50px
                resizingColumn.style.width = newWidth + 'px';
                resizingColumn.style.minWidth = newWidth + 'px';

                // Also update all cells in this column
                const columnClass = Array.from(resizingColumn.classList).find(cls => cls.startsWith('col-'));
                if (columnClass) {
                    const cells = document.querySelectorAll(`#songTable .${columnClass}`);
                    cells.forEach(cell => {
                        cell.style.width = newWidth + 'px';
                        cell.style.minWidth = newWidth + 'px';
                    });
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (!resizingColumn) return;

                // Save the new width
                const columnClass = Array.from(resizingColumn.classList).find(cls => cls.startsWith('col-'));
                if (columnClass) {
                    columnWidths[columnClass] = resizingColumn.offsetWidth;
                    localStorage.setItem('columnWidths', JSON.stringify(columnWidths));
                }

                // Clean up
                const handle = resizingColumn.querySelector('.resize-handle');
                if (handle) handle.classList.remove('resizing');
                resizingColumn = null;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            });
        }

        // Search Help Toggle
        function toggleSearchHelp() {
            const panel = document.getElementById('searchHelp');
            if (panel) {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Advanced Search Parser
        function parseAdvancedSearch(searchTerm) {
            // Handle empty search
            if (!searchTerm.trim()) return null;

            // Parse the search query into a structured format
            const tokens = [];
            let currentToken = '';
            let inQuotes = false;
            let inField = false;
            let fieldName = '';

            for (let i = 0; i < searchTerm.length; i++) {
                const char = searchTerm[i];
                const nextChar = searchTerm[i + 1];

                if (char === '"') {
                    inQuotes = !inQuotes;
                    currentToken += char;
                } else if (char === ':' && !inQuotes && currentToken) {
                    // Field specifier
                    fieldName = currentToken.toLowerCase();
                    currentToken = '';
                    inField = true;
                } else if (char === ' ' && !inQuotes) {
                    if (currentToken) {
                        const upperToken = currentToken.toUpperCase();
                        if (upperToken === 'AND' || upperToken === 'OR' || upperToken === 'NOT') {
                            tokens.push({ type: 'operator', value: upperToken });
                        } else {
                            tokens.push({
                                type: 'term',
                                value: currentToken,
                                field: fieldName || null,
                                negative: currentToken.startsWith('-')
                            });
                            fieldName = '';
                        }
                        currentToken = '';
                        inField = false;
                    }
                } else if (char === '(' || char === ')') {
                    if (currentToken) {
                        tokens.push({
                            type: 'term',
                            value: currentToken,
                            field: fieldName || null,
                            negative: currentToken.startsWith('-')
                        });
                        currentToken = '';
                        fieldName = '';
                    }
                    tokens.push({ type: char === '(' ? 'open' : 'close' });
                } else {
                    currentToken += char;
                }
            }

            // Add final token
            if (currentToken) {
                const upperToken = currentToken.toUpperCase();
                if (upperToken === 'AND' || upperToken === 'OR' || upperToken === 'NOT') {
                    tokens.push({ type: 'operator', value: upperToken });
                } else {
                    tokens.push({
                        type: 'term',
                        value: currentToken,
                        field: fieldName || null,
                        negative: currentToken.startsWith('-')
                    });
                }
            }

            return tokens;
        }

        // Evaluate advanced search against a song
        function evaluateAdvancedSearch(song, tokens) {
            if (!tokens || tokens.length === 0) return true;

            // Simple evaluation: process AND, OR, NOT operators
            let result = true;
            let currentOperator = 'AND'; // Default operator
            let pendingNot = false;

            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];

                if (token.type === 'operator') {
                    if (token.value === 'NOT') {
                        pendingNot = true;
                    } else {
                        currentOperator = token.value;
                    }
                } else if (token.type === 'term') {
                    let termValue = token.value.replace(/^-/, '').replace(/"/g, '').toLowerCase();
                    let matchFound = false;

                    // Field-specific search
                    if (token.field) {
                        const fieldValue = (song[token.field] || '').toLowerCase();
                        matchFound = fieldValue.includes(termValue);
                    } else {
                        // Search across all fields
                        matchFound =
                            song.artist.toLowerCase().includes(termValue) ||
                            song.song.toLowerCase().includes(termValue) ||
                            (song.album && song.album.toLowerCase().includes(termValue)) ||
                            (song.bands && song.bands.toLowerCase().includes(termValue)) ||
                            (song.key && song.key.toLowerCase().includes(termValue)) ||
                            (song.tuning && song.tuning.toLowerCase().includes(termValue)) ||
                            (song.tags && song.tags.toLowerCase().includes(termValue)) ||
                            (song.firstNote && song.firstNote.toLowerCase().includes(termValue)) ||
                            (song.lastNote && song.lastNote.toLowerCase().includes(termValue));
                    }

                    // Apply NOT/negative
                    if (token.negative || pendingNot) {
                        matchFound = !matchFound;
                        pendingNot = false;
                    }

                    // Apply operator
                    if (i === 0) {
                        result = matchFound;
                    } else if (currentOperator === 'AND') {
                        result = result && matchFound;
                    } else if (currentOperator === 'OR') {
                        result = result || matchFound;
                    }

                    // Reset to default AND for next term
                    if (i < tokens.length - 1 && tokens[i + 1].type !== 'operator') {
                        currentOperator = 'AND';
                    }
                }
            }

            return result;
        }

        // Inline Editing Functions - DISABLED FOR BETTER DRAG SCROLLING
        // Use the Edit button to modify songs instead
        /*
        let currentEditCell = null;

        function startInlineEdit(cell, index, field) {
            // Prevent multiple edits at once
            if (currentEditCell) {
                cancelInlineEdit();
            }

            currentEditCell = { cell, index, field };
            const song = songs[index];
            const currentValue = song[field] || '';

            // Store original content
            const originalContent = cell.innerHTML;
            cell.classList.add('editing');

            // Special handling for practiceStatus (dropdown)
            if (field === 'practiceStatus') {
                const select = document.createElement('select');
                select.className = 'inline-select';
                select.innerHTML = `
                    <option value="">-</option>
                    <option value="learning" ${currentValue === 'learning' ? 'selected' : ''}>üéì Learning</option>
                    <option value="practicing" ${currentValue === 'practicing' ? 'selected' : ''}>üéµ Practicing</option>
                    <option value="ready" ${currentValue === 'ready' ? 'selected' : ''}>‚úì Ready</option>
                    <option value="mastered" ${currentValue === 'mastered' ? 'selected' : ''}>‚≠ê Mastered</option>
                `;
                cell.innerHTML = '';
                cell.appendChild(select);
                select.focus();

                select.onchange = () => saveInlineEdit(select.value);
                select.onblur = () => setTimeout(() => cancelInlineEdit(), 200);
                select.onkeydown = (e) => {
                    if (e.key === 'Escape') cancelInlineEdit();
                    if (e.key === 'Enter') saveInlineEdit(select.value);
                };
            } else {
                // Regular text input
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'inline-input';
                input.value = currentValue === '-' ? '' : currentValue;
                cell.innerHTML = '';
                cell.appendChild(input);
                input.focus();
                input.select();

                input.onblur = () => setTimeout(() => saveInlineEdit(input.value), 200);
                input.onkeydown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelInlineEdit();
                    }
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveInlineEdit(input.value);
                    }
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        saveInlineEdit(input.value);
                        // Focus next editable cell
                        const nextCell = cell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('editable-cell')) {
                            setTimeout(() => startInlineEdit(nextCell, index, nextCell.className.match(/col-(\w+)/)[1]), 50);
                        }
                    }
                };
            }
        }

        function saveInlineEdit(newValue) {
            if (!currentEditCell) return;

            const { cell, index, field } = currentEditCell;
            const song = songs[index];
            const oldValue = song[field] || '';

            // Trim and clean the value
            newValue = newValue.trim();
            if (newValue === '-') newValue = '';

            // Only save if value changed
            if (newValue !== oldValue) {
                // Store for undo
                actionHistory.push({
                    type: 'edit',
                    index: index,
                    field: field,
                    oldValue: oldValue,
                    newValue: newValue
                });
                updateUndoButton();

                // Update song
                song[field] = newValue;
                saveSongs();
                invalidateStatsCache();
                invalidateFilterCache();
                
                // Show save indicator
                showSaveIndicator();
                showToast(`Updated ${field}`, 'success');
            }

            // Reset cell and re-render
            cell.classList.remove('editing');
            currentEditCell = null;
            
            // Re-render to show updated value
            applyFilters();
        }

        function cancelInlineEdit() {
            if (!currentEditCell) return;

            const { cell } = currentEditCell;
            cell.classList.remove('editing');
            currentEditCell = null;

            // Re-render to restore original content
            applyFilters();
        }
        */


        // Open add modal
        function openAddModal() {
            editIndex = -1;
            document.getElementById('modalTitle').textContent = 'Add Song';
            document.getElementById('songForm').reset();
            document.getElementById('songModal').classList.add('active');
        }

        // Edit song
        function editSong(index) {
            editIndex = index;
            const song = songs[index];
            document.getElementById('modalTitle').textContent = 'Edit Song';
            document.getElementById('artist').value = song.artist;
            document.getElementById('song').value = song.song;
            document.getElementById('album').value = song.album || '';
            document.getElementById('link').value = song.link || '';
            document.getElementById('tuning').value = song.tuning || '';
            document.getElementById('bands').value = song.bands || '';
            document.getElementById('tags').value = song.tags || '';
            document.getElementById('duration').value = song.duration || '';
            document.getElementById('practiceStatus').value = song.practiceStatus || '';
            document.getElementById('key').value = song.key || '';
            document.getElementById('firstNote').value = song.firstNote || '';
            document.getElementById('lastNote').value = song.lastNote || '';
            document.getElementById('songModal').classList.add('active');
        }

        // Close modal
        function closeModal() {
            document.getElementById('songModal').classList.remove('active');
        }

        // Close import modal
        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
            importData = [];
        }

        // Handle form submission
        document.getElementById('songForm').onsubmit = function(e) {
            e.preventDefault();
            
            // Show loading state
            const saveBtn = document.getElementById('saveSongBtn');
            const saveBtnText = document.getElementById('saveBtnText');
            const saveBtnSpinner = document.getElementById('saveBtnSpinner');
            
            saveBtn.disabled = true;
            saveBtnText.style.display = 'none';
            saveBtnSpinner.style.display = 'inline';
            
            const songData = {
                artist: document.getElementById('artist').value.trim(),
                song: document.getElementById('song').value.trim(),
                album: document.getElementById('album').value.trim(),
                link: document.getElementById('link').value.trim(),
                tuning: document.getElementById('tuning').value.trim(),
                bands: document.getElementById('bands').value.trim(),
                tags: document.getElementById('tags').value.trim(),
                duration: document.getElementById('duration').value.trim(),
                practiceStatus: document.getElementById('practiceStatus').value,
                key: document.getElementById('key').value.trim(),
                firstNote: document.getElementById('firstNote').value.trim(),
                lastNote: document.getElementById('lastNote').value.trim(),
                playCount: editIndex >= 0 ? songs[editIndex].playCount || 0 : 0,
                lastPlayed: editIndex >= 0 ? songs[editIndex].lastPlayed : null,
                createdAt: editIndex >= 0 ? songs[editIndex].createdAt : new Date().toISOString(),
                chordChart: editIndex >= 0 ? songs[editIndex].chordChart : null
            };

            // Check for duplicates before saving
            const similarSongs = findSimilarSongs(songData.artist, songData.song);
            
            showDuplicateWarning(similarSongs, (proceed) => {
                if (!proceed) {
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtnText.style.display = 'inline';
                    saveBtnSpinner.style.display = 'none';
                    return;
                }

            if (editIndex >= 0) {
                    saveUndoState('edit', { index: editIndex, oldSong: JSON.parse(JSON.stringify(songs[editIndex])) });
                songs[editIndex] = songData;
                    showToast('Song updated successfully', 'success');
            } else {
                    saveUndoState('add', {});
                songs.push(songData);
                    showToast('Song added successfully', 'success');
            }

            saveSongs();
            applyFilters();
            updateStats();
                
                // Reset button state
                saveBtn.disabled = false;
                saveBtnText.style.display = 'inline';
                saveBtnSpinner.style.display = 'none';
                
            closeModal();
            });
        };

        // Delete song
        function deleteSong(index) {
            const song = songs[index];
            if (confirm(`Move "${song.song}" by ${song.artist} to trash?`)) {
                // Save to undo history so user can recover if needed
                saveUndoState('delete', { index: index, song: JSON.parse(JSON.stringify(song)) });
                
                // Add to trash with timestamp
                trash.push({
                    song: JSON.parse(JSON.stringify(song)),
                    deletedAt: Date.now()
                });
                saveTrash();
                
                // Remove from songs
                songs.splice(index, 1);
                saveSongs();
                applyFilters();
                updateStats();
                showToast('Song moved to trash (2-day retention)', 'success');
            }
        }

        // ===== TRASH SYSTEM FUNCTIONS (Simple & Reliable) =====
        
        function loadTrash() {
            const stored = localStorage.getItem('songTrash');
            if (stored) {
                trash = JSON.parse(stored);
                cleanExpiredTrash();
            }
            updateTrashCount();
        }

        function saveTrash() {
            localStorage.setItem('songTrash', JSON.stringify(trash));
            updateTrashCount();
        }

        function cleanExpiredTrash() {
            const now = Date.now();
            const retentionMs = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000;
            const originalLength = trash.length;
            trash = trash.filter(item => (now - item.deletedAt) < retentionMs);
            if (trash.length < originalLength) {
                saveTrash();
                console.log(`Cleaned ${originalLength - trash.length} expired item(s) from trash`);
            }
        }

        function updateTrashCount() {
            document.getElementById('trashCount').textContent = trash.length;
        }

        function openTrashModal() {
            cleanExpiredTrash();
            renderTrashContent();
            document.getElementById('trashModal').classList.add('active');
        }

        function closeTrashModal() {
            document.getElementById('trashModal').classList.remove('active');
        }

        function renderTrashContent() {
            const container = document.getElementById('trashContent');
            
            if (trash.length === 0) {
                container.innerHTML = '<div class="no-data">Trash is empty</div>';
                return;
            }

            const now = Date.now();
            const html = trash.map((item, index) => {
                const song = item.song;
                const timeLeft = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000 - (now - item.deletedAt);
                const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
                
                return `
                    <div style="background: var(--card-bg); border: 1px solid var(--primary-border); border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div>
                                <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 5px;">
                                    ${song.song || 'Untitled'}
                                </div>
                                <div style="color: var(--text-secondary); font-size: 14px; margin-bottom: 5px;">
                                    by ${song.artist || 'Unknown Artist'}
                                </div>
                                <div style="color: var(--text-tertiary); font-size: 12px;">
                                    ${hoursLeft > 0 ? `Expires in ${hoursLeft} hours` : 'Expires soon'}
                                </div>
                            </div>
                            <div>
                                <button class="btn-success btn-small" onclick="restoreFromTrash(${index})" style="margin-right: 5px;">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                        <path d="M3 7v6h6"/>
                                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                                    </svg>
                                    Restore
                                </button>
                                <button class="btn-danger btn-small" onclick="deleteFromTrashPermanently(${index})">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                        <line x1="18" y1="6" x2="6" y2="18"/>
                                        <line x1="6" y1="6" x2="18" y2="18"/>
                                    </svg>
                                    Delete Forever
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function restoreFromTrash(index) {
            const item = trash[index];
            if (!item || !item.song) {
                showToast('Invalid trash item', 'error');
                return;
            }

            const songName = item.song.song;
            const artistName = item.song.artist;
            
            // Check if already in songs (duplicate check)
            const alreadyExists = songs.find(s => s.song === songName && s.artist === artistName);
            if (alreadyExists) {
                console.warn('Song already exists in songs array!');
                // Just remove from trash and update
                trash.splice(index, 1);
                saveTrash();
                showToast(`‚ö†Ô∏è "${songName}" already in song list - removed from trash`, 'warning');
                setTimeout(() => location.reload(), 800);
                return;
            }

            // Create a deep copy - SAME AS UNDO
            const songCopy = JSON.parse(JSON.stringify(item.song));
            
            // Use splice like undo does - insert at end is fine
            songs.splice(songs.length, 0, songCopy);
            
            // Remove from trash
            trash.splice(index, 1);
            
            // Save - use the SAME functions as everywhere else
            saveSongs();
            saveTrash();
            
            // Show message and reload
            showToast(`‚úÖ Restoring: ${songName} by ${artistName}`, 'success');
            
            setTimeout(() => {
                location.reload();
            }, 800);
        }

        function restoreAllFromTrash() {
            if (trash.length === 0) {
                showToast('Trash is empty', 'info');
                return;
            }

            const count = trash.length;
            
            // Restore all - check for duplicates
            let restored = 0;
            let skipped = 0;
            
            trash.forEach(item => {
                const alreadyExists = songs.find(s => 
                    s.song === item.song.song && s.artist === item.song.artist
                );
                
                if (!alreadyExists) {
                    songs.splice(songs.length, 0, JSON.parse(JSON.stringify(item.song)));
                    restored++;
                } else {
                    skipped++;
                }
            });

            // Clear trash
            trash = [];

            // Save using standard functions
            saveSongs();
            saveTrash();

            // Show message and reload
            const msg = skipped > 0 
                ? `‚úÖ Restored ${restored}, skipped ${skipped} duplicate(s)`
                : `‚úÖ Restored ${restored} song(s)`;
            showToast(msg, 'success');
            
            setTimeout(() => {
                location.reload();
            }, 800);
        }

        function deleteFromTrashPermanently(index) {
            const item = trash[index];
            if (confirm(`Permanently delete "${item.song.song}" by ${item.song.artist}? This cannot be undone!`)) {
                trash.splice(index, 1);
                saveTrash();
                renderTrashContent();
                showToast('Permanently deleted', 'warning');
            }
        }

        function emptyTrash() {
            if (trash.length === 0) {
                showToast('Trash is already empty', 'info');
                return;
            }
            if (confirm(`Permanently delete all ${trash.length} song(s) in trash? This cannot be undone!`)) {
                trash = [];
                saveTrash();
                renderTrashContent();
                showToast('Trash emptied', 'warning');
            }
        }

        // Sort table by column
        function sortTable(column) {
            // Toggle sort direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }

            // Update header classes
            document.querySelectorAll('.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
            });
            
            // Map column names to header text
            const columnMap = {
                'artist': 'artist',
                'song': 'song',
                'album': 'album',
                'tuning': 'tuning',
                'bands': 'bands',
                'key': 'key',
                'firstNote': 'firstnote',
                'lastNote': 'lastnote'
            };
            
            const activeHeader = Array.from(document.querySelectorAll('.sortable')).find(
                th => th.textContent.trim().toLowerCase().replace(/\s/g, '') === columnMap[column]
            );
            if (activeHeader) {
                activeHeader.classList.add(currentSort.direction);
            }

            applyFilters();
        }

        // Update filter suggestions based on selected column
        function updateFilterSuggestions() {
            // Get ALL elements (both PC and mobile)
            const pcColumn = document.getElementById('filterColumn');
            const pcDatalist = document.getElementById('filterSuggestions');
            const pcInput = document.getElementById('filterValue');
            
            const mobileColumn = document.getElementById('mobileFilterColumn');
            const mobileDatalist = document.getElementById('mobileFilterSuggestions');
            const mobileInput = document.getElementById('mobileFilterValue');
            
            // Determine which column was changed (whichever has a value)
            const column = pcColumn?.value || mobileColumn?.value || '';
            
            if (!column) {
                // Clear both datalists
                if (pcDatalist) pcDatalist.innerHTML = '';
                if (mobileDatalist) mobileDatalist.innerHTML = '';
                if (pcInput) pcInput.placeholder = 'Filter value...';
                if (mobileInput) mobileInput.placeholder = 'Enter filter value...';
                return;
            }
            
            // Sync the column selection between PC and mobile
            if (pcColumn && pcColumn.value !== column) pcColumn.value = column;
            if (mobileColumn && mobileColumn.value !== column) mobileColumn.value = column;

            // Get songs filtered by OTHER columns (not the current one)
            // This gives cascading filter behavior
            let availableSongs = songs.map((song, index) => ({
                ...song,
                originalIndex: index
            }));

            // Apply existing filters for OTHER columns only
            const filtersByColumn = {};
            activeFilters.forEach(filter => {
                // Skip filters for the current column being edited
                if (filter.column !== column) {
                    if (!filtersByColumn[filter.column]) {
                        filtersByColumn[filter.column] = [];
                    }
                    filtersByColumn[filter.column].push(filter.value.toLowerCase());
                }
            });

            // Filter songs by other columns
            Object.keys(filtersByColumn).forEach(col => {
                const values = filtersByColumn[col];
                availableSongs = availableSongs.filter(song => {
                    const fieldValue = (song[col] || '').toLowerCase();
                    return values.some(value => {
                        if (value === '(empty)') {
                            return fieldValue === '';
                        }
                        return fieldValue === value;
                    });
                });
            });

            // Get unique values for the selected column from FILTERED songs
            const uniqueValues = new Set();
            let hasEmptyValues = false;
            
            availableSongs.forEach(song => {
                const value = song[column];
                if (value) {
                    // Handle bands/tags fields which might have comma-separated values
                    if ((column === 'bands' || column === 'tags') && value.includes(',')) {
                        value.split(',').forEach(item => {
                            const trimmed = item.trim();
                            if (trimmed) uniqueValues.add(trimmed);
                        });
                    } else {
                        uniqueValues.add(value);
                    }
                } else {
                    hasEmptyValues = true;
                }
            });

            // Sort values
            const sortedValues = Array.from(uniqueValues).sort((a, b) => 
                a.toLowerCase().localeCompare(b.toLowerCase())
            );
            
            // Add (empty) option at the beginning if there are songs with empty values
            if (hasEmptyValues) {
                sortedValues.unshift('(empty)');
            }

            // Populate BOTH datalists with the same values
            const datalistHTML = sortedValues.map(value => 
                `<option value="${escapeHtml(value)}"></option>`
            ).join('');
            
            if (pcDatalist) pcDatalist.innerHTML = datalistHTML;
            if (mobileDatalist) mobileDatalist.innerHTML = datalistHTML;

            const filterCount = activeFilters.length > 0 ? ` (${sortedValues.length} matching)` : '';
            const placeholderText = `Select or type ${formatFieldName(column)}...${filterCount}`;
            
            if (pcInput) pcInput.placeholder = placeholderText;
            if (mobileInput) mobileInput.placeholder = placeholderText;
            
            // Focus the appropriate input (whichever one initiated the change)
            const activeInput = (mobileColumn && mobileColumn === document.activeElement) ? mobileInput : 
                               (pcColumn && pcColumn === document.activeElement) ? pcInput : null;
            
            if (activeInput) {
                activeInput.focus();
                
                // Trigger the datalist to show on mobile browsers
                if (activeInput.value === '') {
                    setTimeout(() => {
                        activeInput.click();
                    }, 10);
                }
            }
        }

        // Add filter
        function addFilter() {
            const column = document.getElementById('filterColumn').value;
            const value = document.getElementById('filterValue').value.trim();

            if (!column || !value) {
                showToast('Please select a column and enter a filter value', 'warning');
                return;
            }

            activeFilters.push({ column, value });
            
            // Clear BOTH PC and mobile inputs
            const pcColumn = document.getElementById('filterColumn');
            const pcValue = document.getElementById('filterValue');
            const pcSuggestions = document.getElementById('filterSuggestions');
            const mobileColumn = document.getElementById('mobileFilterColumn');
            const mobileValue = document.getElementById('mobileFilterValue');
            const mobileSuggestions = document.getElementById('mobileFilterSuggestions');
            
            if (pcColumn) pcColumn.value = '';
            if (pcValue) pcValue.value = '';
            if (pcSuggestions) pcSuggestions.innerHTML = '';
            if (mobileColumn) mobileColumn.value = '';
            if (mobileValue) mobileValue.value = '';
            if (mobileSuggestions) mobileSuggestions.innerHTML = '';
            
            updateFilterTags(); // Update PC filter display
            renderActiveFilters(); // Update mobile filter display
            invalidateFilterCache(); // Clear filter cache
            applyFilters();
            showToast(`Filter added: ${formatFieldName(column)} = ${value}`, 'success', 2000);
        }

        // Remove filter
        function removeFilter(index) {
            activeFilters.splice(index, 1);
            updateFilterTags(); // Update PC filter display
            renderActiveFilters(); // Update mobile filter display
            invalidateFilterCache(); // Clear filter cache
            applyFilters();
            showToast('‚úì Filter removed', 'info', 2000);
        }

        function clearFilters() {
            activeFilters = [];
            updateFilterTags(); // Update PC filter display
            renderActiveFilters(); // Update mobile filter display
            invalidateFilterCache(); // Clear filter cache
            applyFilters();
            showToast('‚úì All filters cleared', 'info', 2000);
        }

        // Clear all filters
        function clearAllFilters() {
            activeFilters = [];
            
            // Clear search box
            const searchBox = document.getElementById('searchBox');
            if (searchBox) searchBox.value = '';
            
            // Clear BOTH PC and mobile filter inputs
            const pcColumn = document.getElementById('filterColumn');
            const pcValue = document.getElementById('filterValue');
            const pcSuggestions = document.getElementById('filterSuggestions');
            const mobileColumn = document.getElementById('mobileFilterColumn');
            const mobileValue = document.getElementById('mobileFilterValue');
            const mobileSuggestions = document.getElementById('mobileFilterSuggestions');
            
            if (pcColumn) pcColumn.value = '';
            if (pcValue) pcValue.value = '';
            if (pcSuggestions) pcSuggestions.innerHTML = '';
            if (mobileColumn) mobileColumn.value = '';
            if (mobileValue) mobileValue.value = '';
            if (mobileSuggestions) mobileSuggestions.innerHTML = '';
            
            updateFilterTags(); // Update PC filter display
            renderActiveFilters(); // Update mobile filter display
            invalidateFilterCache(); // Clear filter cache
            applyFilters();
            showToast('‚úì All filters and search cleared', 'info', 2000);
        }

        // Update filter tags display
        function updateFilterTags() {
            const container = document.getElementById('activeFilters');
            const mobileContainer = document.getElementById('mobileActiveFilters');
            
            if (activeFilters.length === 0) {
                if (container) container.innerHTML = '';
                if (mobileContainer) mobileContainer.innerHTML = '<p style="color: #999; font-size: 13px; font-style: italic;">No active filters</p>';
                return;
            }

            const filtersHTML = activeFilters.map((filter, index) => `
                <div class="filter-tag">
                    <strong>${formatFieldName(filter.column)}:</strong> ${escapeHtml(filter.value)}
                    <span class="filter-tag-remove" onclick="removeFilter(${index})">‚úï</span>
                </div>
            `).join('');
            
            if (container) container.innerHTML = filtersHTML;
            
            // Also update mobile container with styled version
            const mobileFiltersHTML = activeFilters.map((filter, index) => `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: rgba(40, 40, 40, 0.8); border: 2px solid var(--primary-color); border-radius: 6px;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
                    </svg>
                    <span style="flex: 1; font-size: 13px;">
                        <strong style="color: var(--primary-light);">${formatFieldName(filter.column)}:</strong> 
                        ${escapeHtml(filter.value)}
                    </span>
                    <button onclick="removeFilter(${index})" style="background: none; border: none; color: #ff6b6b; cursor: pointer; padding: 2px; display: flex; align-items: center;" title="Remove filter">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            `).join('');
            
            if (mobileContainer) mobileContainer.innerHTML = mobileFiltersHTML;
        }

        // Apply all filters and sorting
        // Helper function to get current search value from either search box
        function getSearchValue() {
            // Try mobile search first (mobile takes precedence if both exist)
            const mobileSearch = document.getElementById('mobileSearchInput');
            if (mobileSearch && mobileSearch.offsetParent !== null) {
                return mobileSearch.value.trim();
            }
            // Fall back to desktop search
            const desktopSearch = document.getElementById('searchBox');
            return desktopSearch ? desktopSearch.value.trim() : '';
        }

        function applyFilters() {
            // Create a cache key from current filter state
            const searchTerm = getSearchValue();
            const filterState = JSON.stringify({
                search: searchTerm,
                filters: activeFilters,
                sort: currentSort,
                songsLength: songs.length
            });
            
            // Return cached results if nothing changed
            if (lastFilterState === filterState && cachedFilteredSongs) {
                renderSongs(cachedFilteredSongs);
                return;
            }
            
            let filtered = songs.map((song, index) => ({
                ...song,
                originalIndex: index
            }));

            // Apply search filter with advanced operators (AND, OR, NOT, field:)
            if (searchTerm) {
                const searchTokens = parseAdvancedSearch(searchTerm);
                
                if (searchTokens && searchTokens.length > 0) {
                    // Use advanced search evaluation
                    filtered = filtered.filter(song => evaluateAdvancedSearch(song, searchTokens));
                } else {
                    // Fallback to simple search with multi-word support
                    const searchTerms = [];
                    const quoteRegex = /"([^"]*)"/g;
                    let remainingText = searchTerm;
                    let match;
                    
                    // Extract quoted phrases
                    while ((match = quoteRegex.exec(searchTerm)) !== null) {
                        searchTerms.push({ text: match[1].toLowerCase(), isPhrase: true });
                        remainingText = remainingText.replace(match[0], '');
                    }
                    
                    // Extract individual words from remaining text
                    const words = remainingText.trim().split(/\s+/).filter(w => w.length > 0);
                    words.forEach(word => {
                        searchTerms.push({ text: word.toLowerCase(), isPhrase: false });
                    });
                    
                    filtered = filtered.filter(song => {
                        // For each song, check if ALL search terms match
                        return searchTerms.every(term => {
                            const searchText = term.text;
                            const matchFound = 
                                song.artist.toLowerCase().includes(searchText) ||
                                song.song.toLowerCase().includes(searchText) ||
                                (song.album && song.album.toLowerCase().includes(searchText)) ||
                                (song.bands && song.bands.toLowerCase().includes(searchText)) ||
                                (song.key && song.key.toLowerCase().includes(searchText)) ||
                                (song.tuning && song.tuning.toLowerCase().includes(searchText)) ||
                                (song.firstNote && song.firstNote.toLowerCase().includes(searchText)) ||
                                (song.lastNote && song.lastNote.toLowerCase().includes(searchText));
                            
                            return matchFound;
                        });
                    });
                }
            }

            // Apply column filters
            // Group filters by column to handle multiple values per column with OR logic
            const filtersByColumn = {};
            activeFilters.forEach(filter => {
                if (!filtersByColumn[filter.column]) {
                    filtersByColumn[filter.column] = [];
                }
                filtersByColumn[filter.column].push(filter.value.toLowerCase());
            });
            
            // Apply each column's filters (OR within column, AND between columns)
            Object.keys(filtersByColumn).forEach(column => {
                const values = filtersByColumn[column];
                filtered = filtered.filter(song => {
                    const fieldValue = (song[column] || '').toLowerCase();
                    // Match if the field value equals ANY of the filter values for this column
                    return values.some(value => {
                        // Handle special "(empty)" filter
                        if (value === '(empty)') {
                            return fieldValue === '';
                        }
                        return fieldValue === value;
                    });
                });
            });

            // Apply sorting
            if (currentSort.column) {
                filtered.sort((a, b) => {
                    const aVal = (a[currentSort.column] || '').toLowerCase();
                    const bVal = (b[currentSort.column] || '').toLowerCase();
                    
                    if (aVal < bVal) return currentSort.direction === 'asc' ? -1 : 1;
                    if (aVal > bVal) return currentSort.direction === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Cache the results
            lastFilterState = filterState;
            cachedFilteredSongs = filtered;

            // Calculate unique artists and bands from filtered results
            const uniqueArtists = new Set(filtered.map(s => s.artist)).size;
            const uniqueBands = new Set(
                filtered.flatMap(s => s.bands ? s.bands.split(',').map(b => b.trim()) : [])
            ).size;

            // Update compact header stats with filtered counts
            const compactSongs = document.getElementById('compactTotalSongs');
            const compactArtists = document.getElementById('compactTotalArtists');
            const compactBands = document.getElementById('compactTotalBands');
            
            if (searchTerm || activeFilters.length > 0) {
                // Show filtered counts
                if (compactSongs) compactSongs.textContent = filtered.length;
                if (compactArtists) compactArtists.textContent = uniqueArtists;
                if (compactBands) compactBands.textContent = uniqueBands;
            } else {
                // Show total counts (call updateStats to get full counts)
                updateStats();
            }

            // Update search results display (only if elements exist - legacy)
            const searchResultsEl = document.getElementById('searchResults');
            const artistResultsEl = document.getElementById('artistResults');
            const bandResultsEl = document.getElementById('bandResults');
            
            if (searchResultsEl && artistResultsEl && bandResultsEl) {
                if (searchTerm || activeFilters.length > 0) {
                    searchResultsEl.textContent = `${filtered.length} found`;
                    searchResultsEl.style.display = 'block';
                    
                    artistResultsEl.textContent = `${uniqueArtists} found`;
                    artistResultsEl.style.display = 'block';
                    
                    bandResultsEl.textContent = `${uniqueBands} found`;
                    bandResultsEl.style.display = 'block';
                } else {
                    searchResultsEl.style.display = 'none';
                    artistResultsEl.style.display = 'none';
                    bandResultsEl.style.display = 'none';
                }
            }

            renderSongs(filtered);
        }

        // Debounced version of applyFilters (300ms delay)
        function debouncedApplyFilters() {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                applyFilters();
            }, 300);
        }

        // Smart Autocomplete Functions
        function handleSearchInput(event) {
            const input = event.target.value;
            
            // Sync desktop and mobile search boxes
            const desktopSearch = document.getElementById('searchBox');
            const mobileSearch = document.getElementById('mobileSearchInput');
            
            if (event.target.id === 'searchBox' && mobileSearch) {
                mobileSearch.value = input;
            } else if (event.target.id === 'mobileSearchInput' && desktopSearch) {
                desktopSearch.value = input;
            }
            
            // Debounce the filter application
            debouncedApplyFilters();
            
            // Show autocomplete suggestions
            if (input.trim().length >= 2) {
                showAutocompleteSuggestions(input.trim());
            } else {
                hideAutocomplete();
            }
        }

        function showAutocompleteSuggestions(searchText) {
            const suggestions = generateSuggestions(searchText);
            
            if (suggestions.length === 0) {
                hideAutocomplete();
                return;
            }
            
            autocompleteSuggestions = suggestions;
            autocompleteSelectedIndex = -1;
            
            const dropdown = document.getElementById('autocompleteDropdown');
            if (!dropdown) return; // Element doesn't exist in new layout
            
            dropdown.innerHTML = suggestions.map((suggestion, index) => `
                <div class="autocomplete-item" data-index="${index}" onclick="selectSuggestion(${index})">
                    <span class="autocomplete-type">${suggestion.type}</span>
                    <span class="autocomplete-text">${escapeHtml(suggestion.text)}</span>
                    <span class="autocomplete-count">${suggestion.count} song${suggestion.count !== 1 ? 's' : ''}</span>
                </div>
            `).join('');
            
            dropdown.style.display = 'block';
        }

        function generateSuggestions(searchText) {
            const lowerSearch = searchText.toLowerCase();
            const suggestions = [];
            const seenValues = new Set();
            const MAX_SUGGESTIONS = 10;
            
            // Helper to add unique suggestions
            function addSuggestion(type, text, matchingCount) {
                const key = `${type}:${text}`;
                if (!seenValues.has(key) && text.toLowerCase().includes(lowerSearch)) {
                    seenValues.add(key);
                    suggestions.push({ type, text, count: matchingCount });
                }
            }
            
            // Count matches for each category
            const artistMatches = new Map();
            const songMatches = new Map();
            const albumMatches = new Map();
            const tagMatches = new Map();
            
            songs.forEach(song => {
                if (song.artist && song.artist.toLowerCase().includes(lowerSearch)) {
                    artistMatches.set(song.artist, (artistMatches.get(song.artist) || 0) + 1);
                }
                if (song.song && song.song.toLowerCase().includes(lowerSearch)) {
                    songMatches.set(song.song, (songMatches.get(song.song) || 0) + 1);
                }
                if (song.album && song.album.toLowerCase().includes(lowerSearch)) {
                    albumMatches.set(song.album, (albumMatches.get(song.album) || 0) + 1);
                }
                if (song.tags) {
                    const tags = song.tags.split(',').map(t => t.trim());
                    tags.forEach(tag => {
                        if (tag.toLowerCase().includes(lowerSearch)) {
                            tagMatches.set(tag, (tagMatches.get(tag) || 0) + 1);
                        }
                    });
                }
            });
            
            // Add artist suggestions (top 3)
            Array.from(artistMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .forEach(([artist, count]) => addSuggestion('Artist', artist, count));
            
            // Add song suggestions (top 3)
            Array.from(songMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .forEach(([song, count]) => addSuggestion('Song', song, count));
            
            // Add album suggestions (top 2)
            Array.from(albumMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2)
                .forEach(([album, count]) => addSuggestion('Album', album, count));
            
            // Add tag suggestions (top 2)
            Array.from(tagMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2)
                .forEach(([tag, count]) => addSuggestion('Tag', tag, count));
            
            return suggestions.slice(0, MAX_SUGGESTIONS);
        }

        function selectSuggestion(index) {
            if (index >= 0 && index < autocompleteSuggestions.length) {
                const suggestion = autocompleteSuggestions[index];
                document.getElementById('searchBox').value = suggestion.text;
                searchTerm = suggestion.text;
                hideAutocomplete();
                applyFilters();
            }
        }

        function handleSearchKeydown(event) {
            const dropdown = document.getElementById('autocompleteDropdown');
            if (!dropdown) return; // Element doesn't exist in new layout
            
            if (dropdown.style.display === 'none') return;
            
            const items = dropdown.querySelectorAll('.autocomplete-item');
            
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, items.length - 1);
                updateAutocompleteSelection(items);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                updateAutocompleteSelection(items);
            } else if (event.key === 'Enter') {
                event.preventDefault();
                if (autocompleteSelectedIndex >= 0) {
                    selectSuggestion(autocompleteSelectedIndex);
                } else {
                    hideAutocomplete();
                }
            } else if (event.key === 'Escape') {
                hideAutocomplete();
            }
        }

        function updateAutocompleteSelection(items) {
            items.forEach((item, index) => {
                if (index === autocompleteSelectedIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function hideAutocomplete() {
            const dropdown = document.getElementById('autocompleteDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
            autocompleteSelectedIndex = -1;
        }

        // Close autocomplete when clicking outside
        document.addEventListener('click', function(event) {
            const searchBox = document.getElementById('searchBox');
            const dropdown = document.getElementById('autocompleteDropdown');
            
            if (searchBox && dropdown && 
                !searchBox.contains(event.target) && 
                !dropdown.contains(event.target)) {
                hideAutocomplete();
            }
        });

        // Handle CSV import
        function handleCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const csv = e.target.result;
                parseCSV(csv);
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Parse CSV
        function parseCSV(csv) {
            const lines = csv.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                showToast('CSV file is empty or invalid!', 'error');
                return;
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const fieldMap = {
                'artist': 'artist',
                'album': 'album',
                'song': 'song',
                'link': 'link',
                'tuning': 'tuning',
                'bands': 'bands',
                'key': 'key',
                'first note': 'firstNote',
                'firstnote': 'firstNote',
                'last note': 'lastNote',
                'lastnote': 'lastNote'
            };

            const headerIndexMap = {};
            headers.forEach((header, index) => {
                const mappedField = fieldMap[header];
                if (mappedField) {
                    headerIndexMap[mappedField] = index;
                }
            });

            if (headerIndexMap.artist === undefined || headerIndexMap.song === undefined) {
                showToast('CSV must have "Artist" and "Song" columns!', 'error');
                return;
            }

            importData = [];
            const csvSongs = [];
            
            // First pass: collect all songs from CSV
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length === 0) continue;

                const newSong = {
                    artist: values[headerIndexMap.artist]?.trim() || '',
                    song: values[headerIndexMap.song]?.trim() || '',
                    album: values[headerIndexMap.album]?.trim() || '',
                    link: values[headerIndexMap.link]?.trim() || '',
                    tuning: values[headerIndexMap.tuning]?.trim() || '',
                    bands: values[headerIndexMap.bands]?.trim() || '',
                    key: values[headerIndexMap.key]?.trim() || '',
                    firstNote: values[headerIndexMap.firstNote]?.trim() || '',
                    lastNote: values[headerIndexMap.lastNote]?.trim() || '',
                    csvLineNumber: i + 1
                };

                if (!newSong.artist || !newSong.song) continue;
                csvSongs.push(newSong);
            }

            // Second pass: process songs and detect duplicates
            const processedKeys = new Set();
            
            for (let csvSong of csvSongs) {
                const key = `${csvSong.artist.toLowerCase()}|||${csvSong.song.toLowerCase()}`;
                
                // Check for duplicate within CSV file
                const csvDuplicates = csvSongs.filter(s => 
                    s.artist.toLowerCase() === csvSong.artist.toLowerCase() &&
                    s.song.toLowerCase() === csvSong.song.toLowerCase()
                );
                
                if (csvDuplicates.length > 1 && !processedKeys.has(key)) {
                    // Multiple entries in CSV for same song
                    processedKeys.add(key);
                    importData.push({
                        type: 'csv-duplicate',
                        duplicates: csvDuplicates,
                        selected: 0, // Index of selected duplicate
                        artist: csvSong.artist,
                        songName: csvSong.song
                    });
                } else if (csvDuplicates.length === 1) {
                    // Single entry in CSV, check against existing songs
                    const existingIndex = songs.findIndex(s => 
                        s.artist.toLowerCase() === csvSong.artist.toLowerCase() &&
                        s.song.toLowerCase() === csvSong.song.toLowerCase()
                    );

                    if (existingIndex >= 0) {
                        const changes = getChanges(songs[existingIndex], csvSong);
                        if (changes.length > 0) {
                            importData.push({
                                type: 'update',
                                index: existingIndex,
                                oldSong: songs[existingIndex],
                                newSong: csvSong,
                                changes: changes,
                                selected: true
                            });
                        }
                    } else {
                        importData.push({
                            type: 'new',
                            newSong: csvSong,
                            selected: true
                        });
                    }
                }
            }

            if (importData.length === 0) {
                showToast('No changes detected in CSV file!', 'info');
                return;
            }

            showImportPreview();
        }

        // Parse CSV line handling quoted values
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);

            return values.map(v => v.trim().replace(/^"|"$/g, ''));
        }

        // Get changes between old and new song
        function getChanges(oldSong, newSong) {
            const changes = [];
            const fields = ['artist', 'song', 'album', 'link', 'tuning', 'bands', 'key', 'firstNote', 'lastNote'];
            
            fields.forEach(field => {
                const oldVal = oldSong[field] || '';
                const newVal = newSong[field] || '';
                if (oldVal !== newVal) {
                    changes.push({
                        field: field,
                        oldValue: oldVal,
                        newValue: newVal
                    });
                }
            });

            return changes;
        }

        // Paste Import Functions
        function openPasteImportModal() {
            document.getElementById('pasteImportModal').classList.add('active');
            document.getElementById('pasteImportText').value = '';
            document.getElementById('pasteImportText').focus();
        }

        function closePasteImportModal() {
            document.getElementById('pasteImportModal').classList.remove('active');
        }

        function processPasteImport() {
            const text = document.getElementById('pasteImportText').value.trim();
            if (!text) {
                showToast('Please paste some song data first!', 'error');
                return;
            }

            // Auto-detect format and parse
            const parsedSongs = parsePastedData(text);
            
            if (parsedSongs.length === 0) {
                showToast('Could not parse the pasted data. Please check the format.', 'error');
                return;
            }

            // Convert to CSV format and use existing CSV import logic
            const csv = convertToCSV(parsedSongs);
            closePasteImportModal();
            parseCSV(csv);
        }

        function parsePastedData(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const songs = [];

            for (const line of lines) {
                let artist = '';
                let song = '';
                let album = '';
                let other = {};

                // Try different delimiters and patterns
                if (line.includes('\t')) {
                    // Tab-separated (from spreadsheets)
                    const parts = line.split('\t').map(p => p.trim());
                    artist = parts[0] || '';
                    song = parts[1] || '';
                    album = parts[2] || '';
                    // Additional columns if present
                    if (parts[3]) other.tuning = parts[3];
                    if (parts[4]) other.bands = parts[4];
                    if (parts[5]) other.key = parts[5];
                } else if (line.includes(' - ')) {
                    // "Artist - Song" format
                    const parts = line.split(' - ');
                    artist = parts[0]?.trim() || '';
                    song = parts.slice(1).join(' - ').trim();
                } else if (line.includes(', ')) {
                    // Comma-separated
                    const parts = line.split(',').map(p => p.trim());
                    artist = parts[0] || '';
                    song = parts[1] || '';
                    album = parts[2] || '';
                    // Additional columns if present
                    if (parts[3]) other.tuning = parts[3];
                    if (parts[4]) other.bands = parts[4];
                    if (parts[5]) other.key = parts[5];
                } else {
                    // Single value - assume it's the song name
                    song = line.trim();
                }

                if (artist || song) {
                    songs.push({
                        artist: artist,
                        song: song,
                        album: album,
                        ...other
                    });
                }
            }

            return songs;
        }

        function convertToCSV(songs) {
            // Build CSV with all detected fields
            const headers = ['Artist', 'Song', 'Album'];
            const hasAdditionalFields = songs.some(s => s.tuning || s.bands || s.key);
            if (hasAdditionalFields) {
                if (songs.some(s => s.tuning)) headers.push('Tuning');
                if (songs.some(s => s.bands)) headers.push('Bands');
                if (songs.some(s => s.key)) headers.push('Key');
            }

            const csvLines = [headers.join(',')];
            
            songs.forEach(song => {
                const row = [
                    escapeCsvValue(song.artist || ''),
                    escapeCsvValue(song.song || ''),
                    escapeCsvValue(song.album || '')
                ];
                if (hasAdditionalFields) {
                    if (headers.includes('Tuning')) row.push(escapeCsvValue(song.tuning || ''));
                    if (headers.includes('Bands')) row.push(escapeCsvValue(song.bands || ''));
                    if (headers.includes('Key')) row.push(escapeCsvValue(song.key || ''));
                }
                csvLines.push(row.join(','));
            });

            return csvLines.join('\n');
        }

        function escapeCsvValue(value) {
            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                return `"${value.replace(/"/g, '""')}"`;
            }
            return value;
        }

        // Show import preview
        function showImportPreview() {
            const preview = document.getElementById('importPreview');
            
            // Sort import data by bands, album, then song
            const sortedData = [...importData].map((item, originalIndex) => ({
                ...item,
                originalIndex: originalIndex
            })).sort((a, b) => {
                const getSongData = (item) => {
                    if (item.type === 'csv-duplicate') {
                        return item.duplicates[item.selected];
                    }
                    return item.newSong;
                };
                
                const songA = getSongData(a);
                const songB = getSongData(b);
                
                const bandsA = (songA.bands || '').toLowerCase();
                const bandsB = (songB.bands || '').toLowerCase();
                if (bandsA !== bandsB) return bandsA.localeCompare(bandsB);
                
                const albumA = (songA.album || '').toLowerCase();
                const albumB = (songB.album || '').toLowerCase();
                if (albumA !== albumB) return albumA.localeCompare(albumB);
                
                const nameA = (songA.song || '').toLowerCase();
                const nameB = (songB.song || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            const duplicateCount = importData.filter(i => i.type === 'csv-duplicate').length;
            
            preview.innerHTML = `
                <div style="margin-bottom: 15px; color: #d84315;">
                    <strong>${importData.filter(i => i.type === 'new').length}</strong> new songs, 
                    <strong>${importData.filter(i => i.type === 'update').length}</strong> updates
                    ${duplicateCount > 0 ? `, <strong style="color: #f59e0b;">${duplicateCount}</strong> duplicates in CSV` : ''}
                </div>
                <table style="width: 100%;">
                    <thead>
                        <tr>
                            <th style="width: 40px; text-align: center;">‚úì</th>
                            <th style="width: 60px;">Status</th>
                            <th>Band</th>
                            <th>Artist</th>
                            <th>Song</th>
                            <th>Album</th>
                            <th>Key</th>
                            <th>Changes</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedData.map((item) => {
                            if (item.type === 'csv-duplicate') {
                                // Special handling for CSV duplicates
                                const statusBadge = '<span style="background: #f59e0b; padding: 4px 8px; border-radius: 4px; font-size: 12px;">‚ö†Ô∏è DUPLICATE</span>';
                                const selectedDup = item.duplicates[item.selected];
                                
                                const duplicateOptions = `
                                    <div style="font-size: 12px;">
                                        <strong style="color: #f59e0b;">Found ${item.duplicates.length} entries in CSV for this song. Select which to import:</strong>
                                        ${item.duplicates.map((dup, dupIndex) => `
                                            <div style="margin: 8px 0; padding: 8px; background: ${dupIndex === item.selected ? 'rgba(216, 67, 21, 0.2)' : 'rgba(50, 50, 50, 0.3)'}; border-radius: 4px; border: ${dupIndex === item.selected ? '2px solid #d84315' : '1px solid #444'};">
                                                <label style="cursor: pointer; display: block;">
                                                    <input type="radio" name="duplicate_${item.originalIndex}" value="${dupIndex}" 
                                                           ${dupIndex === item.selected ? 'checked' : ''} 
                                                           onchange="selectDuplicate(${item.originalIndex}, ${dupIndex})"
                                                           style="margin-right: 8px;">
                                                    CSV Line ${dup.csvLineNumber}:
                                                    <div style="margin-left: 24px; margin-top: 4px;">
                                                        ${dup.album ? `<span style="color: #aaa;">Album: ${escapeHtml(dup.album)}</span><br>` : ''}
                                                        ${dup.bands ? `<span style="color: #aaa;">Bands: ${escapeHtml(dup.bands)}</span><br>` : ''}
                                                        ${dup.key ? `<span style="color: #aaa;">Key: ${escapeHtml(dup.key)}</span>` : ''}
                                                        ${dup.tuning ? ` | Tuning: ${escapeHtml(dup.tuning)}` : ''}
                                                        ${dup.link ? ` | <a href="${escapeHtml(dup.link)}" target="_blank" class="link-icon">üîó</a>` : ''}
                                                    </div>
                                                </label>
                                            </div>
                                        `).join('')}
                                    </div>
                                `;
                                
                                return `
                                    <tr style="border-bottom: 1px solid rgba(216, 67, 21, 0.1); background: rgba(245, 158, 11, 0.05);">
                                        <td style="text-align: center; padding: 8px;">
                                            <input type="checkbox" id="import_${item.originalIndex}" 
                                                   checked
                                                   onchange="toggleImportItem(${item.originalIndex})"
                                                   style="width: 18px; height: 18px; cursor: pointer;">
                                        </td>
                                        <td style="padding: 8px;">${statusBadge}</td>
                                        <td style="padding: 8px;">${escapeHtml(selectedDup.bands || '-')}</td>
                                        <td style="padding: 8px;">${escapeHtml(item.artist)}</td>
                                        <td style="padding: 8px; font-weight: 600;">${escapeHtml(item.songName)}</td>
                                        <td style="padding: 8px;">${escapeHtml(selectedDup.album || '-')}</td>
                                        <td style="padding: 8px;">${escapeHtml(selectedDup.key || '-')}</td>
                                        <td style="padding: 8px;" colspan="1">${duplicateOptions}</td>
                                    </tr>
                                `;
                            }
                            
                            const isUpdate = item.type === 'update';
                            const statusBadge = isUpdate 
                                ? '<span style="background: #f59e0b; padding: 4px 8px; border-radius: 4px; font-size: 12px;">üîÑ UPDATE</span>'
                                : '<span style="background: #10b981; padding: 4px 8px; border-radius: 4px; font-size: 12px;">‚ú® NEW</span>';
                            
                            const changesHtml = isUpdate ? `
                                <div style="font-size: 12px;">
                                    ${item.changes.map(change => `
                                        <div style="margin: 2px 0;">
                                            <strong>${formatFieldName(change.field)}:</strong>
                                            ${change.oldValue ? `<span class="change-old">${escapeHtml(change.oldValue)}</span> ‚Üí ` : ''}
                                            <span class="change-new">${escapeHtml(change.newValue)}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '-';
                            
                            return `
                                <tr style="border-bottom: 1px solid rgba(216, 67, 21, 0.1);">
                                    <td style="text-align: center; padding: 8px;">
                                        <input type="checkbox" id="import_${item.originalIndex}" 
                                               ${item.selected ? 'checked' : ''} 
                                               onchange="toggleImportItem(${item.originalIndex})"
                                               style="width: 18px; height: 18px; cursor: pointer;">
                                    </td>
                                    <td style="padding: 8px;">${statusBadge}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.bands || '-')}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.artist)}</td>
                                    <td style="padding: 8px; font-weight: 600;">${escapeHtml(item.newSong.song)}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.album || '-')}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.key || '-')}</td>
                                    <td style="padding: 8px;">${changesHtml}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            document.getElementById('importModal').classList.add('active');
        }

        // Toggle import item selection
        function toggleImportItem(index) {
            importData[index].selected = document.getElementById(`import_${index}`).checked;
        }

        // Select which duplicate to import
        function selectDuplicate(importIndex, duplicateIndex) {
            importData[importIndex].selected = duplicateIndex;
            // Refresh the preview to show the new selection
            showImportPreview();
        }

        // Confirm import
        function confirmImport() {
            const selectedItems = importData.filter(item => item.selected !== false && item.selected !== undefined);
            if (selectedItems.length === 0) {
                showToast('No items selected for import!', 'warning');
                return;
            }

            selectedItems.forEach(item => {
                if (item.type === 'csv-duplicate') {
                    // Import the selected duplicate
                    const selectedSong = item.duplicates[item.selected];
                    const existingIndex = songs.findIndex(s => 
                        s.artist.toLowerCase() === selectedSong.artist.toLowerCase() &&
                        s.song.toLowerCase() === selectedSong.song.toLowerCase()
                    );
                    
                    if (existingIndex >= 0) {
                        songs[existingIndex] = selectedSong;
                    } else {
                        songs.push(selectedSong);
                    }
                } else if (item.type === 'update') {
                    songs[item.index] = item.newSong;
                } else if (item.type === 'new') {
                    songs.push(item.newSong);
                }
            });

            saveSongs();
            applyFilters();
            updateStats();
            closeImportModal();
            
            // Save undo state for import
            saveUndoState('import', { count: selectedItems.length });
            showToast(`Successfully imported ${selectedItems.length} song(s)!`, 'success');
        }

        // Export to CSV
        function exportCSV() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            const headers = ['Artist', 'Song', 'Album', 'Link', 'Tuning', 'Bands', 'Key', 'First Note', 'Last Note'];
            const csv = [headers.join(',')];

            songs.forEach(song => {
                const row = [
                    escapeCSV(song.artist),
                    escapeCSV(song.song),
                    escapeCSV(song.album || ''),
                    escapeCSV(song.link || ''),
                    escapeCSV(song.tuning || ''),
                    escapeCSV(song.bands || ''),
                    escapeCSV(song.key || ''),
                    escapeCSV(song.firstNote || ''),
                    escapeCSV(song.lastNote || '')
                ];
                csv.push(row.join(','));
            });

            const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `band-songs-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
            showToast(`Exported ${songs.length} songs to CSV`, 'success');
        }

        // Toggle export menu
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }

        // Import Modal Functions
        function openImportModal() {
            document.getElementById('importModal').classList.add('active');
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
        }

        // Toggle import menu dropdown (deprecated, keeping for compatibility)
        function toggleImportMenu() {
            // This function is now replaced by openImportModal but kept for any legacy calls
            openImportModal();
        }

        // Close export menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('exportMenu');
            const btn = document.getElementById('exportMenuBtn');
            
            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });

        // Export as JSON
        function exportJSON() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                totalSongs: songs.length,
                songs: songs.map(song => ({
                    artist: song.artist,
                    song: song.song,
                    album: song.album || '',
                    link: song.link || '',
                    tuning: song.tuning || '',
                    bands: song.bands || '',
                    tags: song.tags || '',
                    key: song.key || '',
                    firstNote: song.firstNote || '',
                    lastNote: song.lastNote || '',
                    duration: song.duration || '',
                    practiceStatus: song.practiceStatus || '',
                    playCount: song.playCount || 0,
                    lastPlayed: song.lastPlayed || null
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `band-songs-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            window.URL.revokeObjectURL(url);
            showToast('JSON exported successfully!', 'success');
        }

        // Export as Excel (XLSX) - using HTML table method
        function exportExcel() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            // Create HTML table
            let html = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">';
            html += '<head><meta charset="utf-8"><style>table { border-collapse: collapse; } th, td { border: 1px solid #ddd; padding: 8px; } th { background-color: #4CAF50; color: white; }</style></head>';
            html += '<body><table>';
            
            // Headers
            html += '<tr><th>Artist</th><th>Song</th><th>Album</th><th>Link</th><th>Tuning</th><th>Bands</th><th>Tags</th><th>Key</th><th>First Note</th><th>Last Note</th><th>Duration</th><th>Practice Status</th></tr>';
            
            // Data rows
            songs.forEach(song => {
                html += '<tr>';
                html += `<td>${escapeHtml(song.artist)}</td>`;
                html += `<td>${escapeHtml(song.song)}</td>`;
                html += `<td>${escapeHtml(song.album || '')}</td>`;
                html += `<td>${escapeHtml(song.link || '')}</td>`;
                html += `<td>${escapeHtml(song.tuning || '')}</td>`;
                html += `<td>${escapeHtml(song.bands || '')}</td>`;
                html += `<td>${escapeHtml(song.tags || '')}</td>`;
                html += `<td>${escapeHtml(song.key || '')}</td>`;
                html += `<td>${escapeHtml(song.firstNote || '')}</td>`;
                html += `<td>${escapeHtml(song.lastNote || '')}</td>`;
                html += `<td>${escapeHtml(song.duration || '')}</td>`;
                html += `<td>${escapeHtml(song.practiceStatus || '')}</td>`;
                html += '</tr>';
            });
            
            html += '</table></body></html>';

            const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `band-songs-${new Date().toISOString().split('T')[0]}.xls`;
            a.click();
            window.URL.revokeObjectURL(url);
            showToast('Excel file exported successfully!', 'success');
        }

        // Export as PDF
        function exportPDF() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            // Create a printable HTML page
            const printWindow = window.open('', '_blank');
            let html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Band Songs - ${new Date().toLocaleDateString()}</title>
    <style>
        @page { size: landscape; margin: 0.5in; }
        body { font-family: Arial, sans-serif; font-size: 10pt; }
        h1 { text-align: center; color: #333; margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 6px; text-align: left; }
        th { background-color: #4CAF50; color: white; font-weight: bold; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .footer { text-align: center; margin-top: 20px; font-size: 9pt; color: #666; }
    <\/style>
<\/head>
<body>
    <h1>üé∏ Band Song Database</h1>
    <p><strong>Export Date:</strong> ${new Date().toLocaleString()}</p>
    <p><strong>Total Songs:</strong> ${songs.length}</p>
    <table>
        <thead>
            <tr>
                <th>#</th>
                <th>Artist</th>
                <th>Song</th>
                <th>Album</th>
                <th>Tuning</th>
                <th>Key</th>
                <th>Duration</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody>
`;

            songs.forEach((song, index) => {
                html += `
            <tr>
                <td>${index + 1}</td>
                <td>${escapeHtml(song.artist)}</td>
                <td>${escapeHtml(song.song)}</td>
                <td>${escapeHtml(song.album || '-')}</td>
                <td>${escapeHtml(song.tuning || '-')}</td>
                <td>${escapeHtml(song.key || '-')}</td>
                <td>${escapeHtml(song.duration || '-')}</td>
                <td>${escapeHtml(song.practiceStatus || '-')}</td>
            </tr>
`;
            });

            html += `
        </tbody>
    </table>
    <div class="footer">
        <p>Generated by Band Practice Manager ‚Ä¢ \${songs.length} songs</p>
    </div>
    <script>
        window.onload = function() {
            window.print();
            // Close after printing (optional)
            // setTimeout(() => window.close(), 1000);
        };
    <\/script>
<\/body>
<\/html>
`;

            printWindow.document.write(html);
            printWindow.document.close();
            showToast('PDF print dialog opened!', 'success');
        }

        // Escape CSV value
        function escapeCSV(value) {
            if (!value) return '';
            const str = String(value);
            if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                return `"${str.replace(/"/g, '""')}"`;
            }
            return str;
        }

        // Escape HTML
        // Escape HTML for display (optimized version)
        const escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        
        function escapeHtml(text) {
            if (!text) return '';
            return String(text).replace(/[&<>"']/g, function(char) {
                return escapeMap[char];
            });
        }

        // Format field name for display
        function formatFieldName(field) {
            const map = {
                'artist': 'Artist',
                'song': 'Song',
                'album': 'Album',
                'link': 'Link',
                'tuning': 'Tuning',
                'bands': 'Bands',
                'key': 'Key',
                'firstNote': 'First Note',
                'lastNote': 'Last Note'
            };
            return map[field] || field;
        }
        
        // ============================================================================
        // PERFORMANCE MONITORING (Admin Page)
        // ============================================================================
        
        function openPerformanceMonitor() {
            const modal = document.getElementById('perfMonitorModal');
            modal.classList.add('active');
            updatePerformanceMetrics();
            
            // Start live monitoring
            window.perfMonitorInterval = setInterval(updatePerformanceMetrics, 1000);
        }
        
        function closePerformanceMonitor() {
            const modal = document.getElementById('perfMonitorModal');
            modal.classList.remove('active');
            
            // Stop live monitoring
            if (window.perfMonitorInterval) {
                clearInterval(window.perfMonitorInterval);
                window.perfMonitorInterval = null;
            }
        }
        
        function updatePerformanceMetrics() {
            const perf = performance;
            const navigation = perf.getEntriesByType('navigation')[0];
            const paint = perf.getEntriesByType('paint');
            
            // Navigation Timing
            if (navigation) {
                document.getElementById('loadTime').textContent = 
                    `${(navigation.loadEventEnd - navigation.fetchStart).toFixed(2)} ms`;
                document.getElementById('domReady').textContent = 
                    `${(navigation.domContentLoadedEventEnd - navigation.fetchStart).toFixed(2)} ms`;
            }
            
            // Paint Timing
            const fcp = paint.find(entry => entry.name === 'first-contentful-paint');
            if (fcp) {
                document.getElementById('fcp').textContent = `${fcp.startTime.toFixed(2)} ms`;
            }
            
            // Memory (if available)
            if (performance.memory) {
                const usedMemory = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                const totalMemory = (performance.memory.totalJSHeapSize / 1048576).toFixed(2);
                document.getElementById('memory').textContent = `${usedMemory} / ${totalMemory} MB`;
            } else {
                document.getElementById('memory').textContent = 'N/A (not supported)';
            }
            
            // LocalStorage Size
            let storageSize = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    storageSize += localStorage[key].length + key.length;
                }
            }
            document.getElementById('storageSize').textContent = 
                `${(storageSize / 1024).toFixed(2)} KB`;
            
            // DOM Stats
            document.getElementById('domNodes').textContent = 
                document.querySelectorAll('*').length;
            document.getElementById('tableRows').textContent = 
                document.querySelectorAll('#songTableBody tr').length;
            
            // Song Stats
            document.getElementById('totalSongsPerf').textContent = songs.length;
            document.getElementById('filterCacheStatus').textContent = 
                cachedFilteredSongs ? 'Active' : 'Empty';
            document.getElementById('statsCacheStatus').textContent = 
                statsCache ? 'Active' : 'Empty';
        }
        
        function logSlowOperations() {
            const originalConsoleLog = console.log;
            const threshold = 100; // ms
            
            // Wrap expensive functions to log if they take > 100ms
            const functionsToMonitor = ['renderSongs', 'applyFilters', 'updateStats'];
            
            functionsToMonitor.forEach(funcName => {
                const originalFunc = window[funcName];
                if (originalFunc) {
                    window[funcName] = function(...args) {
                        const start = performance.now();
                        const result = originalFunc.apply(this, args);
                        const duration = performance.now() - start;
                        
                        if (duration > threshold) {
                            console.warn(`‚ö†Ô∏è SLOW: ${funcName}() took ${duration.toFixed(2)}ms`);
                        }
                        
                        return result;
                    };
                }
            });
            
            console.log('‚úÖ Performance monitoring enabled - slow operations (>100ms) will be logged');
        }
    </script>
    
    <!-- Stats Customizer Panel -->
    <div id="statsCustomizer" style="display: none; position: absolute; top: 60px; left: 20px; background: var(--primary-dark); border: 2px solid var(--primary-border); border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 1000; min-width: 250px;">
        <h3 style="color: var(--primary-light); margin: 0 0 10px 0; font-size: 0.95em; display: flex; align-items: center; gap: 8px;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="flex-shrink: 0;">
                <line x1="18" y1="20" x2="18" y2="10"/>
                <line x1="12" y1="20" x2="12" y2="4"/>
                <line x1="6" y1="20" x2="6" y2="14"/>
            </svg>
            Customize Stats
        </h3>
        <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalSongs" checked onchange="toggleStat('totalSongs')">
                <span>Total Songs</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalArtists" checked onchange="toggleStat('totalArtists')">
                <span>Artists</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalBands" checked onchange="toggleStat('totalBands')">
                <span>Bands</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalTags" onchange="toggleStat('totalTags')">
                <span>Tags</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-avgDuration" onchange="toggleStat('avgDuration')">
                <span>Avg Duration</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-mostPlayed" onchange="toggleStat('mostPlayed')">
                <span>Most Played</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-readySongs" onchange="toggleStat('readySongs')">
                <span>Ready Songs</span>
            </label>
        </div>
        <button class="btn-secondary" onclick="toggleStatsCustomizer()" style="width: 100%; margin-top: 10px; font-size: 0.85em;">Close</button>
    </div>
    
    <!-- Progress Indicator Modal -->
    <div id="progressModal" class="modal" style="z-index: 10000;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="progressTitle">Processing...</h2>
            </div>
            <div style="padding: 20px;">
                <div id="progressMessage" style="color: #ccc; margin-bottom: 15px; text-align: center;"></div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div id="progressStats" style="margin-top: 10px; text-align: center; color: #999; font-size: 0.9em;"></div>
                <div style="margin-top: 20px; text-align: center;">
                    <button id="progressCancelBtn" class="btn-danger" onclick="cancelBulkOperation()" style="display: none;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance Monitor Modal -->
    <div id="perfMonitorModal" class="modal" style="align-items: flex-start; padding-top: 120px;">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closePerformanceMonitor()">&times;</span>
            <h2 style="color: var(--primary-light);">‚ö° Performance Monitor</h2>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 20px;">
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #4caf50;">
                    <h4 style="margin: 0 0 10px 0; color: #4caf50;">‚è±Ô∏è Page Load</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>Load Time: <span id="loadTime" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>DOM Ready: <span id="domReady" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>First Paint: <span id="fcp" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #2196f3;">
                    <h4 style="margin: 0 0 10px 0; color: #2196f3;">üíæ Memory</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>JS Heap: <span id="memory" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>LocalStorage: <span id="storageSize" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #ff9800;">
                    <h4 style="margin: 0 0 10px 0; color: #ff9800;">üî¢ DOM Stats</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>Total Nodes: <span id="domNodes" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>Table Rows: <span id="tableRows" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #9c27b0;">
                    <h4 style="margin: 0 0 10px 0; color: #9c27b0;">‚ö° Cache Status</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>Total Songs: <span id="totalSongsPerf" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>Filter Cache: <span id="filterCacheStatus" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>Stats Cache: <span id="statsCacheStatus" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                <h4 style="color: var(--primary-light); margin: 0 0 10px 0;">üõ†Ô∏è Developer Tools</h4>
                <button class="btn-secondary" onclick="logSlowOperations()" style="margin-right: 10px;">
                    Enable Slow Operation Logging
                </button>
                <button class="btn-secondary" onclick="console.log(performance.getEntries())">
                    Log All Performance Entries
                </button>
            </div>
            
            <div style="margin-top: 15px; font-size: 0.85em; color: var(--text-tertiary);">
                ‚ÑπÔ∏è Metrics update every second while this modal is open. Slow operations (>100ms) are logged to console.
            </div>
        </div>
    </div>

    <!-- Theme Management Script (Inline for file:// compatibility) -->
    <script>
        // Synchronized theme management using localStorage
        function loadTheme() {
            const savedTheme = localStorage.getItem('bandOrganizerTheme') || 'grey';
            applyTheme(savedTheme);
            
            // Sync both desktop and mobile theme selectors
            const themeSelector = document.getElementById('themeSelector');
            if (themeSelector) {
                themeSelector.value = savedTheme;
            }
            const mobileSelector = document.getElementById('mobileThemeSelector');
            if (mobileSelector) {
                mobileSelector.value = savedTheme;
            }
            
            return savedTheme;
        }
        
        function applyTheme(theme) {
            if (theme === 'grey') {
                document.body.removeAttribute('data-theme');
            } else {
                document.body.setAttribute('data-theme', theme);
            }
            updateFaviconForTheme(theme);
        }
        
        function updateFaviconForTheme(theme) {
            const link = document.querySelector("link[rel*='icon']");
            if (!link) return;
            
            // Map themes to colors (hex codes need to be URL encoded with %23)
            const themeColors = {
                'grey': '%23d84315',
                'red': '%23d84315',
                'blue': '%231976d2',
                'green': '%23388e3c',
                'purple': '%237b1fa2',
                'cyan': '%2300838f',
                'amber': '%23f57c00',
                'pink': '%23c2185b',
                'teal': '%2314b8a6',
                'copper': '%23b87333',
                'sunrise': '%23ffb700',
                'sunset': '%23ff8c00',
                'synthwave': '%23a78bfa',
                'prism': '%2314b8a6'
            };
            
            const color = themeColors[theme] || '%23d84315';
            const watermarkType = localStorage.getItem('watermark') || 'guitar';
            
            // Generate appropriate favicon based on watermark type
            if (watermarkType === 'drum') {
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' preserveAspectRatio='xMidYMid meet'><g transform='scale(1.4) translate(-2, -2)'><circle cx='23' cy='17' r='4.5' fill='none' stroke='${color}' stroke-width='2.5'/><line x1='16' y1='21.5' x2='16' y2='2' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='11' y1='5' x2='21' y2='5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='18' y1='8' x2='28' y2='8' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='21' y1='10' x2='26' y2='10' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='7' y1='12.5' x2='18' y2='12.5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='30' y1='12.5' x2='30' y2='2' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='25' y1='5' x2='35' y2='5' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='27' y1='8' x2='33' y2='8' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/><line x1='26' y1='14' x2='31' y2='14' stroke='${color}' stroke-width='2.5' stroke-linecap='round'/></g></svg>`;
            } else if (watermarkType === 'blackdoubt') {
                // BlackDoubt icon favicon
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40' fill='none' stroke='${color}' stroke-width='2' stroke-linecap='round'><path d='M 20 3 L 37 20 L 20 37 L 3 20 Z' stroke='${color}' fill='none' stroke-width='2'/><circle cx='20' cy='20' r='13' stroke='${color}' fill='none' stroke-width='2'/><text x='20' y='20' font-size='20' font-family='serif' text-anchor='middle' dominant-baseline='central' fill='${color}' stroke='none'>ùîÖ</text></svg>`;
            } else {
                // Guitar icon (default)
                link.href = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='${color}' stroke-width='2.5' stroke-linecap='round'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>`;
            }
        }
        
        function changeTheme(theme) {
            localStorage.setItem('bandOrganizerTheme', theme);
            applyTheme(theme);
            // Sync mobile theme selector
            const mobileSelector = document.getElementById('mobileThemeSelector');
            if (mobileSelector && mobileSelector.value !== theme) {
                mobileSelector.value = theme;
            }
            // Sync desktop theme selector
            const desktopSelector = document.getElementById('themeSelector');
            if (desktopSelector && desktopSelector.value !== theme) {
                desktopSelector.value = theme;
            }
        }
        
        // Toggle mobile menu
        function toggleMobileMenu() {
            const menu = document.getElementById('mobileMenu');
            if (menu) {
                menu.classList.toggle('active');
                // Prevent body scroll when menu is open
                if (menu.classList.contains('active')) {
                    document.body.style.overflow = 'hidden';
                } else {
                    document.body.style.overflow = '';
                }
            }
        }
        
        // Open Mobile Guide wizard
        function openMobileGuide() {
            window.open('mobile-guide-wizard.html', '_blank');
        }
        
        // Toggle mobile column visibility section
        function toggleMobileColumnVisibility() {
            const checkboxes = document.getElementById('mobileColumnCheckboxes');
            const chevron = document.getElementById('columnVisibilityChevron');
            
            if (checkboxes.style.display === 'none' || checkboxes.style.display === '') {
                checkboxes.style.display = 'flex';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                checkboxes.style.display = 'none';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Add filter from mobile menu
        function addMobileFilter() {
            const column = document.getElementById('mobileFilterColumn').value;
            const value = document.getElementById('mobileFilterValue').value.trim();
            
            if (!column) {
                alert('Please select a column to filter');
                return;
            }
            
            if (!value) {
                alert('Please enter a filter value');
                return;
            }
            
            // Add to active filters
            activeFilters.push({ column, value });
            
            // Clear BOTH mobile and PC inputs
            const pcColumn = document.getElementById('filterColumn');
            const pcValue = document.getElementById('filterValue');
            const pcSuggestions = document.getElementById('filterSuggestions');
            const mobileColumn = document.getElementById('mobileFilterColumn');
            const mobileValue = document.getElementById('mobileFilterValue');
            const mobileSuggestions = document.getElementById('mobileFilterSuggestions');
            
            if (pcColumn) pcColumn.value = '';
            if (pcValue) pcValue.value = '';
            if (pcSuggestions) pcSuggestions.innerHTML = '';
            if (mobileColumn) mobileColumn.value = '';
            if (mobileValue) mobileValue.value = '';
            if (mobileSuggestions) mobileSuggestions.innerHTML = '';
            
            // Update displays and apply filters - sync both PC and mobile displays
            updateFilterTags(); // Update PC filter display
            renderActiveFilters(); // Update mobile filter display
            invalidateFilterCache(); // Clear filter cache
            applyFilters(); // Apply the same filter logic as PC
            
            showToast(`‚úì Filter added: ${formatFieldName(column)} = ${value}`, 'success', 2000);
        }
        
        // Close mobile menu when clicking outside or pressing escape
        document.addEventListener('DOMContentLoaded', () => {
            const mobileMenu = document.getElementById('mobileMenu');
            if (mobileMenu) {
                // Close on background click
                mobileMenu.addEventListener('click', (e) => {
                    if (e.target === mobileMenu) {
                        toggleMobileMenu();
                    }
                });
                
                // Close on escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && mobileMenu.classList.contains('active')) {
                        toggleMobileMenu();
                    }
                });
            }
            
            // Sync mobile band filter with available bands
            syncMobileBandFilter();
        });
        
        // Sync mobile band filter dropdown with all bands
        function syncMobileBandFilter() {
            const mobileFilter = document.getElementById('mobileBandFilter');
            if (!mobileFilter || !songs) return;
            
            // Get unique bands from songs
            const bands = [...new Set(songs.map(s => s.band).filter(b => b))].sort();
            
            // Clear and repopulate mobile filter
            mobileFilter.innerHTML = '<option value="">All Bands</option>';
            bands.forEach(band => {
                const option = document.createElement('option');
                option.value = band;
                option.textContent = band;
                mobileFilter.appendChild(option);
            });
            
            // Check for BlackDoubt band after updating bands list
            checkForBlackDoubt();
        }
        
        // BlackDoubt Easter Egg: Check if BlackDoubt setlist exists
        function checkForBlackDoubt() {
            // Check if there's a setlist named "BlackDoubt" (faster than checking all songs)
            const setlists = JSON.parse(localStorage.getItem('bandSetlists') || '[]');
            const hasBlackDoubt = setlists.some(setlist => 
                setlist.name && setlist.name.toLowerCase() === 'blackdoubt'
            );
            
            const icon = document.getElementById('blackDoubtIcon');
            if (icon) {
                icon.style.display = hasBlackDoubt ? 'flex' : 'none';
            }
        }
        
        // Filter songs by band
        function filterByBand(band) {
            if (!band) {
                // Show all songs
                renderSongs();
            } else {
                // Filter by selected band
                const filtered = songs.filter(s => s.band === band);
                renderSongs(filtered);
            }
        }
        
        // Load theme immediately
        loadTheme();
    </script>
    
    <!-- Version Management -->
    <script src="./js/version.js"></script>
</body>
</html>

