<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Song Manager</title>
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#d84315">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Band Manager">
    <!-- Performance: Resource Hints -->
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="preconnect" href="//fonts.googleapis.com">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23d84315' stroke-width='2'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #6b7280;
            --primary-light: #9ca3af;
            --primary-lighter: #d1d5db;
            --primary-dark: #374151;
            --primary-darker: #4b5563;
            --primary-glow: rgba(107, 114, 128, 0.3);
            --primary-border: rgba(107, 114, 128, 0.3);
            --primary-bg: rgba(107, 114, 128, 0.15);
            
            /* Text colors */
            --text-primary: #ffffff;
            --text-secondary: #d1d5db;
            --text-tertiary: #9ca3af;
            
            /* Card background */
            --card-bg: #1a1a1a;
        }

        [data-theme="red"] {
            --primary-color: #d84315;
            --primary-light: #ff6b3d;
            --primary-lighter: #ffa580;
            --primary-dark: #5c1d0a;
            --primary-darker: #7a2710;
            --primary-glow: rgba(216, 67, 21, 0.3);
            --primary-border: rgba(216, 67, 21, 0.3);
            --primary-bg: rgba(216, 67, 21, 0.15);
        }

        [data-theme="blue"] {
            --primary-color: #1976d2;
            --primary-light: #42a5f5;
            --primary-lighter: #90caf9;
            --primary-dark: #0d3d6b;
            --primary-darker: #1565c0;
            --primary-glow: rgba(25, 118, 210, 0.3);
            --primary-border: rgba(25, 118, 210, 0.3);
            --primary-bg: rgba(25, 118, 210, 0.15);
        }

        [data-theme="green"] {
            --primary-color: #388e3c;
            --primary-light: #66bb6a;
            --primary-lighter: #a5d6a7;
            --primary-dark: #1b4d1e;
            --primary-darker: #2e7d32;
            --primary-glow: rgba(56, 142, 60, 0.3);
            --primary-border: rgba(56, 142, 60, 0.3);
            --primary-bg: rgba(56, 142, 60, 0.15);
        }

        [data-theme="purple"] {
            --primary-color: #7b1fa2;
            --primary-light: #ab47bc;
            --primary-lighter: #ce93d8;
            --primary-dark: #3d0f51;
            --primary-darker: #6a1b9a;
            --primary-glow: rgba(123, 31, 162, 0.3);
            --primary-border: rgba(123, 31, 162, 0.3);
            --primary-bg: rgba(123, 31, 162, 0.15);
        }

        [data-theme="cyan"] {
            --primary-color: #00838f;
            --primary-light: #00acc1;
            --primary-lighter: #4dd0e1;
            --primary-dark: #004247;
            --primary-darker: #00697c;
            --primary-glow: rgba(0, 131, 143, 0.3);
            --primary-border: rgba(0, 131, 143, 0.3);
            --primary-bg: rgba(0, 131, 143, 0.15);
        }

        [data-theme="amber"] {
            --primary-color: #f57c00;
            --primary-light: #ff9800;
            --primary-lighter: #ffb74d;
            --primary-dark: #7a3e00;
            --primary-darker: #ef6c00;
            --primary-glow: rgba(245, 124, 0, 0.3);
            --primary-border: rgba(245, 124, 0, 0.3);
            --primary-bg: rgba(245, 124, 0, 0.15);
        }

        [data-theme="pink"] {
            --primary-color: #c2185b;
            --primary-light: #e91e63;
            --primary-lighter: #f06292;
            --primary-dark: #610c2d;
            --primary-darker: #ad1457;
            --primary-glow: rgba(194, 24, 91, 0.3);
            --primary-border: rgba(194, 24, 91, 0.3);
            --primary-bg: rgba(194, 24, 91, 0.15);
        }

        [data-theme="teal"] {
            --primary-color: #00897b;
            --primary-light: #26a69a;
            --primary-lighter: #80cbc4;
            --primary-dark: #00443d;
            --primary-darker: #00695c;
            --primary-glow: rgba(0, 137, 123, 0.3);
            --primary-border: rgba(0, 137, 123, 0.3);
            --primary-bg: rgba(0, 137, 123, 0.15);
        }

        [data-theme="copper"] {
            --primary-color: #b87333;
            --primary-light: #d4944e;
            --primary-lighter: #e8b67a;
            --primary-dark: #7a4d22;
            --primary-darker: #8b5a2b;
            --primary-glow: rgba(184, 115, 51, 0.3);
            --primary-border: rgba(184, 115, 51, 0.3);
            --primary-bg: rgba(184, 115, 51, 0.15);
        }

        [data-theme="sunrise"] {
            --primary-color: #ffb700;
            --primary-light: #ffcc33;
            --primary-lighter: #ffdd66;
            --primary-dark: #cc8800;
            --primary-darker: #e69900;
            --primary-glow: rgba(255, 183, 0, 0.3);
            --primary-border: rgba(255, 183, 0, 0.3);
            --primary-bg: rgba(255, 183, 0, 0.15);
        }

        [data-theme="sunset"] {
            --primary-color: #ff8c00;
            --primary-light: #ffa533;
            --primary-lighter: #ffb84d;
            --primary-dark: #b36200;
            --primary-darker: #cc7000;
            --primary-glow: rgba(255, 140, 0, 0.3);
            --primary-border: rgba(255, 140, 0, 0.3);
            --primary-bg: rgba(255, 140, 0, 0.15);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        /* Background watermark - Guitar */
        body::before {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='1' opacity='0.15'%3E%3Ccircle cx='12' cy='17' r='4.5'/%3E%3Cline x1='12' y1='12.5' x2='12' y2='2'/%3E%3Cline x1='9' y1='5' x2='15' y2='5'/%3E%3Cline x1='9' y1='8' x2='15' y2='8'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.3s ease;
        }

        /* Background watermark - Drum (hidden by default) */
        body::after {
            content: '';
            position: fixed;
            top: 0%;
            right: -20%;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' fill='none' stroke='%23ffffff' stroke-width='1.5' opacity='0.15'%3E%3Ccircle cx='23' cy='17' r='4.5'/%3E%3Cline x1='16' y1='21.5' x2='16' y2='2'/%3E%3Cline x1='11' y1='5' x2='21' y2='5'/%3E%3Cline x1='18' y1='8' x2='28' y2='8'/%3E%3Cline x1='21' y1='10' x2='26' y2='10'/%3E%3Cline x1='7' y1='12.5' x2='18' y2='12.5'/%3E%3Cline x1='30' y1='12.5' x2='30' y2='2'/%3E%3Cline x1='25' y1='5' x2='35' y2='5'/%3E%3Cline x1='27' y1='8' x2='33' y2='8'/%3E%3Cline x1='26' y1='14' x2='31' y2='14'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Show drum watermark when active */
        body.drum-watermark::before {
            opacity: 0;
        }

        body.drum-watermark::after {
            opacity: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
            padding: 5px 10px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            position: relative;
            z-index: 1;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            text-shadow: 0 0 20px var(--primary-glow);
            margin: 2px 0;
            font-size: 1.3em;
            letter-spacing: 1px;
        }
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .nav-links {
            text-align: center;
            margin-bottom: 4px;
        }

        .nav-links a {
            color: var(--primary-light);
            text-decoration: none;
            margin: 0 15px;
            padding: 10px 20px;
            border-radius: 8px;
            border: 2px solid var(--primary-border);
            display: inline-block;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-links a:hover {
            background: var(--primary-bg);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .controls {
            background: rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 4px 8px;
            border-radius: 6px;
            margin-bottom: 4px;
            box-shadow: 0 2px 10px var(--primary-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .button-group {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-bottom: 4px;
        }

        button {
            padding: 4px 10px;
            border: none;
            font-size: 0.85em;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: var(--primary-dark);
            color: var(--primary-light);
            border: 2px solid var(--primary-light);
        }

        .btn-primary:hover {
            background: var(--primary-darker);
            color: var(--primary-lighter);
            transform: translateY(-2px);
        }

        .btn-success {
            background: var(--primary-dark);
            color: var(--primary-light);
            border: 2px solid var(--primary-light);
        }

        .btn-success:hover {
            background: var(--primary-darker);
            color: var(--primary-lighter);
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #5c1d0a;
            color: #ff6b3d;
            border: 2px solid #ff6b3d;
        }

        .btn-danger:hover {
            background: #7a2710;
            color: #ffa580;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2a2d33;
            color: #c1c7d0;
            border: 2px solid #c1c7d0;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-border);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 200px;
        }

        .dropdown-menu button {
            display: block;
            width: 100%;
            padding: 12px 16px;
            background: none;
            border: none;
            color: #e0e0e0;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95em;
        }

        .dropdown-menu button:hover {
            background: var(--primary-color);
            color: white;
        }

        .dropdown-menu button:first-child {
            border-radius: 6px 6px 0 0;
        }

        .dropdown-menu button:last-child {
            border-radius: 0 0 6px 6px;
        }

        .dropdown-menu button svg {
            opacity: 0.7;
        }

        .dropdown-menu button:hover svg {
            opacity: 1;
        }

        .btn-secondary:hover {
            background: #3a3e47;
            color: #e5e9f0;
            transform: translateY(-2px);
        }

        input[type="file"] {
            display: none;
        }

        .search-box {
            width: 100%;
            padding: 6px 10px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            font-size: 0.85em;
            color: #e0e0e0;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1a1a1a;
            border: 2px solid var(--primary-border);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background 0.2s ease;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: var(--primary-bg);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-type {
            font-size: 0.75em;
            color: var(--primary-color);
            text-transform: uppercase;
            font-weight: 600;
            margin-right: 8px;
        }

        .autocomplete-text {
            color: #e0e0e0;
        }

        .autocomplete-count {
            float: right;
            font-size: 0.85em;
            color: #999;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .table-container {
            background: 
                radial-gradient(circle at top left, var(--primary-bg) 0%, transparent 40%),
                radial-gradient(circle at top right, var(--primary-bg) 0%, transparent 40%),
                radial-gradient(circle at bottom left, var(--primary-bg) 0%, transparent 40%),
                radial-gradient(circle at bottom right, var(--primary-bg) 0%, transparent 40%),
                rgba(42, 42, 42, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 12px;
            overflow-x: auto;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            box-shadow: 0 4px 20px var(--primary-glow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Performance: Enable GPU acceleration for smooth scrolling */
            will-change: scroll-position;
            transform: translateZ(0);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: transparent;
        }

        thead {
            background: var(--primary-bg);
            border-bottom: 2px solid var(--primary-border);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: var(--primary-color);
            text-shadow: 0 0 8px var(--primary-glow);
        }

        tbody {
            background: transparent;
        }

        tbody tr {
            background: rgba(40, 40, 40, 0.5);
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(60, 60, 60, 0.3);
        }

        /* Table Density Modes */
        .table-compact th {
            padding: 8px 10px;
            font-size: 0.85em;
        }
        
        .table-compact td {
            padding: 6px 10px;
            font-size: 0.9em;
            line-height: 1.3;
        }

        .table-spacious th {
            padding: 18px 20px;
            font-size: 1.05em;
        }
        
        .table-spacious td {
            padding: 16px 20px;
            font-size: 1.05em;
            line-height: 1.8;
        }

        tr:hover {
            background: var(--primary-bg) !important;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 16px;
            min-width: 32px;
        }

        .action-buttons {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #000000;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px var(--primary-glow);
            border: 1px solid var(--primary-border);
        }

        .modal-content.large {
            max-width: 95%;
            width: 95%;
            max-height: 95vh;
            resize: both;
            overflow: auto;
            min-width: 800px;
            min-height: 500px;
            position: relative;
        }

        .modal-content.large::after {
            content: '⇲';
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 20px;
            color: var(--primary-glow);
            pointer-events: none;
            text-shadow: 0 0 5px var(--primary-glow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--primary-border);
        }

        .modal-header h2 {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0a0a0a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 10px var(--primary-glow));
        }

        .close {
            cursor: pointer;
            font-size: 28px;
            color: #e0e0e0;
            transition: all 0.3s ease;
        }

        .close:hover {
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-glow);
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--primary-light);
            font-weight: 500;
        }

        /* Themed select dropdowns */
        select {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: var(--primary-light);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:hover {
            border-color: var(--primary-color);
            background: rgba(255, 107, 61, 0.1);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(255, 107, 61, 0.3);
        }

        select option {
            background: #1a1a1a;
            color: var(--primary-light);
            padding: 10px;
        }

        select option:hover {
            background: var(--primary-bg);
        }

        input[type="text"],
        input[type="url"],
        textarea {
            width: 100%;
            padding: 10px 15px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="url"]:focus,
        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        textarea {
            resize: vertical;
            min-height: 60px;
        }

        .import-preview {
            max-height: 60vh;
            overflow: auto;
            margin-top: 20px;
        }

        .import-preview table {
            min-width: 100%;
            white-space: nowrap;
        }

        .import-preview td, .import-preview th {
            white-space: normal;
        }

        .import-item {
            background: #000000;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
        }

        .import-item.update {
            border-left-color: #f59e0b;
        }

        .import-item.new {
            border-left-color: #10b981;
        }

        .import-item h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .import-changes {
            font-size: 14px;
            margin-top: 10px;
        }

        .change-line {
            padding: 5px;
            margin: 2px 0;
        }

        .change-old {
            color: #ef4444;
            text-decoration: line-through;
        }

        .change-new {
            color: #10b981;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Custom styled checkboxes for column visibility */
        #columnVisibilityPanel input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-color);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            background: transparent;
            transition: all 0.2s;
        }

        #columnVisibilityPanel input[type="checkbox"]:hover {
            background: var(--primary-bg);
        }

        #columnVisibilityPanel input[type="checkbox"]:checked {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        #columnVisibilityPanel input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-size: 14px;
            font-weight: bold;
        }

        #columnVisibilityPanel label {
            color: #e0e0e0;
            transition: color 0.2s;
        }

        #columnVisibilityPanel label:hover {
            color: var(--primary-light);
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #6b7280;
            font-size: 18px;
        }

        .stats {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .stat-card {
            background: #000000;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            border: 1px solid var(--primary-border);
            flex: 1;
            min-width: 130px;
        }

        .stat-card h3 {
            background: linear-gradient(135deg, var(--primary-color) 0%, #4a4a4a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .stat-card p {
            font-size: 20px;
            font-weight: bold;
            color: #e0e0e0;
        }

        /* Inline editing styles */
        .editable-cell {
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .editable-cell:hover {
            background: rgba(255, 255, 255, 0.05);
            outline: 1px solid var(--primary-border);
        }

        .editable-cell.editing {
            padding: 0 !important;
            background: rgba(0, 0, 0, 0.3);
        }

        .inline-input {
            width: 100%;
            background: #1a1a1a;
            border: 2px solid var(--primary-color);
            color: #e0e0e0;
            padding: 8px;
            font-family: inherit;
            font-size: inherit;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .inline-input:focus {
            outline: none;
            border-color: var(--primary-light);
        }

        .inline-select {
            width: 100%;
            background: #1a1a1a;
            border: 2px solid var(--primary-color);
            color: #e0e0e0;
            padding: 8px;
            font-family: inherit;
            font-size: inherit;
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .inline-select:focus {
            outline: none;
            border-color: var(--primary-light);
        }

        /* Column resizing styles */
        th {
            position: relative;
            user-select: none;
        }

        .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 5px;
            cursor: col-resize;
            z-index: 1;
            background: transparent;
            transition: background 0.2s;
        }

        .resize-handle:hover,
        .resize-handle.resizing {
            background: var(--primary-color);
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #000000;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1a1a1a 100%);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, var(--primary-light) 0%, #2a2a2a 100%);
        }

        .link-icon {
            color: var(--primary-light) !important;
            text-decoration: none;
            font-size: 18px;
            text-shadow: 
                0 0 5px var(--primary-glow),
                0 0 10px var(--primary-glow),
                0 0 15px var(--primary-glow);
            transition: all 0.3s ease;
        }

        .link-icon:hover {
            color: var(--primary-lighter) !important;
            text-shadow: 
                0 0 8px var(--primary-glow),
                0 0 15px var(--primary-glow),
                0 0 20px var(--primary-glow);
            transform: scale(1.1);
        }

        .sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 25px !important;
        }

        .sortable:hover {
            color: var(--primary-light);
        }

        .sortable::after {
            content: '⇅';
            position: absolute;
            right: 8px;
            opacity: 0.3;
        }

        .sortable.asc::after {
            content: '↑';
            opacity: 1;
        }

        .sortable.desc::after {
            content: '↓';
            opacity: 1;
        }

        .filter-container {
            margin-top: 10px;
            padding: 12px;
            background: #000000;
            border-radius: 8px;
            border: 1px solid var(--primary-border);
        }

        .filter-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 8px 12px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            min-width: 150px;
        }

        .filter-input {
            padding: 8px 12px;
            background: #000000;
            border: 2px solid var(--primary-border);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 14px;
            flex: 1;
            min-width: 200px;
        }

        .btn-filter {
            padding: 8px 16px;
            font-size: 14px;
        }

        .active-filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .filter-tag {
            background: var(--primary-bg);
            border: 1px solid var(--primary-border);
            padding: 6px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .filter-tag-remove {
            cursor: pointer;
            color: var(--primary-color);
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .filter-tag-remove:hover {
            color: var(--primary-light);
            text-shadow: 0 0 5px var(--primary-glow);
        }

        /* Column visibility classes */
        .hidden-col { display: none; }

        /* Toast notification styles */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }

        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: rgba(40, 40, 40, 0.5);
            border-radius: 15px;
            overflow: hidden;
            border: 2px solid var(--primary-border);
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--primary-light));
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.85em;
            box-shadow: 0 0 10px var(--primary-glow);
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .toast {
            background: var(--primary-dark);
            color: var(--primary-light);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 4px 20px var(--primary-glow);
            border: 2px solid var(--primary-border);
            min-width: 300px;
            max-width: 400px;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.hide {
            opacity: 0;
            transform: translateX(400px);
        }

        .toast-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-weight: 500;
        }

        .toast-close {
            cursor: pointer;
            font-size: 20px;
            opacity: 0.7;
            transition: opacity 0.2s;
            flex-shrink: 0;
        }

        .toast-close:hover {
            opacity: 1;
        }

        .toast.success {
            border-color: #10b981;
            background: #064e3b;
            color: #6ee7b7;
        }

        .toast.error {
            border-color: #ef4444;
            background: #7f1d1d;
            color: #fca5a5;
        }

        .toast.warning {
            border-color: #f59e0b;
            background: #78350f;
            color: #fde68a;
        }

        .toast.info {
            border-color: #3b82f6;
            background: #1e3a8a;
            color: #93c5fd;
        }

        /* Auto-save indicator */
        .save-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 8px;
            background: var(--primary-dark);
            border: 2px solid var(--primary-border);
            color: var(--primary-light);
            font-weight: 600;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 4px 15px var(--primary-glow);
        }

        .save-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }

        .save-indicator.saved {
            background: #064e3b;
            border-color: #10b981;
            color: #6ee7b7;
        }

        /* Custom themed checkboxes */
        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid var(--primary-border);
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.3);
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        input[type="checkbox"]:hover {
            border-color: var(--primary-color);
            background: rgba(255, 107, 61, 0.1);
            box-shadow: 0 0 8px var(--primary-glow);
        }

        input[type="checkbox"]:checked {
            background: var(--primary-color);
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-glow);
        }

        input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        input[type="checkbox"]:indeterminate {
            background: var(--primary-color);
            border-color: var(--primary-color);
            opacity: 0.7;
        }

        input[type="checkbox"]:indeterminate::after {
            content: '−';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
        }

        input[type="checkbox"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Checkbox in table header */
        th input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        /* Checkbox focus state */
        input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 107, 61, 0.3);
        }

        /* Make labels with checkboxes interactive */
        label:has(input[type="checkbox"]) {
            cursor: pointer;
            user-select: none;
        }

        label:has(input[type="checkbox"]):hover {
            color: var(--primary-light);
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Auto-save Indicator -->
    <div class="save-indicator" id="saveIndicator">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
            <polyline points="20 6 9 17 4 12"/>
        </svg>
        Saved ✓
    </div>
    
    <div class="container">
        <h1>
            <svg id="guitarIcon" width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 10px; filter: drop-shadow(0 0 8px var(--primary-glow)); cursor: pointer;" onclick="switchWatermark('guitar')" title="Show Guitar Watermark">
                <!-- Guitar body (hollow circle) -->
                <circle cx="12" cy="17" r="4.5" stroke="var(--primary-color)" fill="none"/>
                <!-- Guitar neck (vertical line from top of circle) -->
                <line x1="12" y1="12.5" x2="12" y2="2" stroke="var(--primary-color)"/>
                <!-- Fret/String lines (horizontal lines through neck) -->
                <line x1="9" y1="5" x2="15" y2="5" stroke="var(--primary-color)"/>
                <line x1="9" y1="8" x2="15" y2="8" stroke="var(--primary-color)"/>
            </svg>
            Song Manager
            <svg id="drumIcon" width="60" height="60" viewBox="0 0 40 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-left: 10px; filter: drop-shadow(0 0 8px var(--primary-glow)); cursor: pointer;" onclick="switchWatermark('drum')" title="Show Drum Watermark">
                <!-- Center drum (bass/floor tom) - shifted right -->
                <circle cx="23" cy="17" r="4.5" fill="none" stroke="var(--primary-color)"/>
                <!-- Left vertical line extended down to bottom of ring -->
                <line x1="16" y1="21.5" x2="16" y2="2" stroke="var(--primary-color)"/>
                <!-- Top line - extended (cymbal) -->
                <line x1="11" y1="5" x2="21" y2="5" stroke="var(--primary-color)"/>
                <line x1="18" y1="8" x2="28" y2="8" stroke="var(--primary-color)"/>
                <!-- Mid tom line reaching right -->
                <line x1="21" y1="10" x2="26" y2="10" stroke="var(--primary-color)"/>
                <!-- Low tom line moved up to top of ring -->
                <line x1="7" y1="12.5" x2="18" y2="12.5" stroke="var(--primary-color)"/>
                
                <!-- Right cymbal stand (no drum) -->
                <line x1="30" y1="12.5" x2="30" y2="2" stroke="var(--primary-color)"/>
                <!-- Right top line - extended (cymbal) -->
                <line x1="25" y1="5" x2="35" y2="5" stroke="var(--primary-color)"/>
                <line x1="27" y1="8" x2="33" y2="8" stroke="var(--primary-color)"/>
                <!-- Snare rim line reaching left -->
                <line x1="26" y1="14" x2="31" y2="14" stroke="var(--primary-color)"/>
            </svg>
        </h1>

        <div class="nav-links">
            <a href="setlist-manager.html">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                    <path d="M9 18V5l12-2v13" fill="currentColor" opacity="0.3"/>
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3" fill="currentColor" opacity="0.5"/>
                    <circle cx="18" cy="16" r="3" fill="currentColor" opacity="0.5"/>
                </svg>
                Setlist Manager
            </a>
        </div>

        <!-- Compact Theme Selector (Top Right) -->
        <div style="position: absolute; top: 15px; right: 20px; display: flex; align-items: center; gap: 8px; font-size: 13px;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity: 0.7;">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.2 4.2l4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.2-4.2l4.2-4.2"/>
            </svg>
            <select id="themeSelector" onchange="changeTheme(this.value)" style="padding: 6px 10px; background: rgba(0,0,0,0.5); border: 1px solid var(--primary-border); border-radius: 4px; color: var(--primary-light); cursor: pointer; font-size: 13px;">
                <option value="grey">Grey</option>
                <option value="red">Red</option>
                <option value="blue">Blue</option>
                <option value="green">Green</option>
                <option value="purple">Purple</option>
                <option value="cyan">Cyan</option>
                <option value="teal">Teal</option>
                <option value="copper">Copper</option>
                <option value="amber">Amber</option>
                <option value="pink">Pink</option>
                <option value="sunrise">Sunrise</option>
                <option value="sunset">Sunset</option>
            </select>
        </div>

        <div class="controls">
            <div class="stats">
                <div style="display: flex; align-items: center; gap: 4px; margin-right: 8px;">
                    <button class="btn-secondary" onclick="toggleStatsCustomizer()" title="Customize stats widgets" style="padding: 4px 8px; font-size: 0.8em;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                            <circle cx="12" cy="12" r="3"/>
                            <path d="M12 1v6m0 6v6m5.2-13.2l-4.2 4.2m0 6l4.2 4.2M23 12h-6m-6 0H1m18.2 5.2l-4.2-4.2m0-6l4.2-4.2"/>
                        </svg>
                    </button>
                </div>
                <div class="stat-card" data-stat="totalSongs">
                    <h3>Total Songs</h3>
                    <p id="totalSongs">0</p>
                    <p id="searchResults" style="font-size: 14px; margin-top: 5px; color: var(--primary-light); display: none;"></p>
                </div>
                <div class="stat-card" data-stat="totalArtists">
                    <h3>Artists</h3>
                    <p id="totalArtists">0</p>
                    <p id="artistResults" style="font-size: 14px; margin-top: 5px; color: var(--primary-light); display: none;"></p>
                </div>
                <div class="stat-card" data-stat="totalBands">
                    <h3>Bands</h3>
                    <p id="totalBands">0</p>
                    <p id="bandResults" style="font-size: 14px; margin-top: 5px; color: var(--primary-light); display: none;"></p>
                </div>
                <div class="stat-card" data-stat="totalTags" style="display: none;">
                    <h3>Tags</h3>
                    <p id="totalTags">0</p>
                </div>
                <div class="stat-card" data-stat="avgDuration" style="display: none;">
                    <h3>Avg Duration</h3>
                    <p id="avgDuration">-</p>
                </div>
                <div class="stat-card" data-stat="mostPlayed" style="display: none;">
                    <h3>Most Played</h3>
                    <p id="mostPlayed" style="font-size: 0.75em;">-</p>
                </div>
                <div class="stat-card" data-stat="readySongs" style="display: none;">
                    <h3>Ready</h3>
                    <p id="readySongs">0</p>
                </div>
            </div>

            <div class="button-group">
                <button class="btn-success" onclick="openAddModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="vertical-align: middle; margin-right: 6px;">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add Song(s)
                </button>
                <button class="btn-secondary" id="undoButton" onclick="undo()" disabled title="Undo last action (Ctrl+Z)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                    </svg>
                    Undo
                </button>
                <button class="btn-success" onclick="document.getElementById('csvFile').click()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7 10 12 15 17 10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                    Import CSV
                </button>
                <div style="position: relative; display: inline-block;">
                    <button class="btn-secondary" onclick="toggleExportMenu()" id="exportMenuBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                        Export ▼
                    </button>
                    <div id="exportMenu" class="dropdown-menu" style="display: none;">
                        <button onclick="exportCSV(); toggleExportMenu();">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10 9 9 9 8 9"/>
                            </svg>
                            Export as CSV
                        </button>
                        <button onclick="exportJSON(); toggleExportMenu();">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <path d="M10 12h4"/>
                                <path d="M10 16h4"/>
                            </svg>
                            Export as JSON
                        </button>
                        <button onclick="exportExcel(); toggleExportMenu();">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <rect x="8" y="12" width="8" height="6"/>
                            </svg>
                            Export as Excel (XLSX)
                        </button>
                        <button onclick="exportPDF(); toggleExportMenu();">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <line x1="10" y1="9" x2="8" y2="9"/>
                            </svg>
                            Export as PDF
                        </button>
                    </div>
                </div>
                <button class="btn-secondary" onclick="openTrashModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Trash (<span id="trashCount">0</span>)
                </button>
                <button class="btn-secondary" onclick="toggleColumnVisibilityPanel()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                        <circle cx="12" cy="12" r="3"/>
                    </svg>
                    Columns
                </button>
                <button class="btn-secondary" onclick="cycleDensity()" id="densityButton" title="Toggle table density">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <line x1="3" y1="6" x2="21" y2="6"/>
                        <line x1="3" y1="12" x2="21" y2="12"/>
                        <line x1="3" y1="18" x2="21" y2="18"/>
                    </svg>
                    <span id="densityLabel">Normal</span>
                </button>
                <button class="btn-danger" onclick="clearAllData()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        <line x1="10" y1="11" x2="10" y2="17"/>
                        <line x1="14" y1="11" x2="14" y2="17"/>
                    </svg>
                    Clear All Data
                </button>
                <input type="file" id="csvFile" accept=".csv" onchange="handleCSVImport(event)">
            </div>

            <!-- Search Row -->
            <div style="margin-bottom: 10px; position: relative;">
                <input type="text" class="search-box" id="searchBox" placeholder="🔍 Search... (Try: rock AND blues, metal OR punk, artist:metallica -live)" oninput="handleSearchInput(event)" onkeydown="handleSearchKeydown(event)" style="width: calc(100% - 30px); margin: 0;">
                <button class="btn-secondary" onclick="toggleSearchHelp()" title="Search Help" style="position: absolute; right: 0; top: 0; bottom: 0; padding: 0 10px; border-radius: 0 4px 4px 0;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                </button>
                <div id="searchHelp" style="display: none; position: absolute; top: 100%; left: 0; right: 0; margin-top: 5px; background: var(--primary-dark); border: 2px solid var(--primary-border); border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 1000; font-size: 0.85em;">
                    <h4 style="color: var(--primary-light); margin: 0 0 10px 0;">🔍 Advanced Search Operators</h4>
                    <div style="display: grid; gap: 8px;">
                        <div><strong style="color: var(--primary-light);">AND</strong> - rock AND blues (both terms)</div>
                        <div><strong style="color: var(--primary-light);">OR</strong> - metal OR punk (either term)</div>
                        <div><strong style="color: var(--primary-light);">NOT / -</strong> - metallica NOT live or metallica -live</div>
                        <div><strong style="color: var(--primary-light);">Field:</strong> - artist:metallica, album:black, song:enter</div>
                        <div><strong style="color: var(--primary-light);">Quotes:</strong> - "black sabbath" (exact phrase)</div>
                        <div><strong style="color: var(--primary-light);">Combine:</strong> - artist:metallica AND (live OR concert) NOT -cover</div>
                    </div>
                </div>
                <div id="autocompleteDropdown" class="autocomplete-dropdown" style="display: none;"></div>
            </div>

            <!-- Saved Filters Row -->
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px; flex-wrap: wrap;">
                <label style="color: var(--primary-light); font-weight: 600; white-space: nowrap; display: flex; align-items: center; gap: 6px;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                        </svg>
                    Saved Filters:
                    </label>
                <select id="savedFiltersDropdown" class="filter-select" onchange="applySavedFilter()" style="flex: 1; min-width: 200px; max-width: 300px;">
                    <option value="">-- Select a saved filter --</option>
                    </select>
                <button class="btn-success btn-small" onclick="openSaveFilterModal()" title="Save current filters">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Current
                </button>
                <button class="btn-secondary btn-small" onclick="openManageFiltersModal()" title="Manage saved filters">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                        <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"/>
                        <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"/>
                    </svg>
                    Manage
                </button>
                </div>

            <!-- Filter Controls Row -->
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                <select id="filterColumn" class="filter-select" onchange="updateFilterSuggestions()" style="width: 180px;">
                    <option value="">Select Column</option>
                    <option value="artist">Artist</option>
                    <option value="song">Song</option>
                    <option value="album">Album</option>
                    <option value="duration">Duration</option>
                    <option value="practiceStatus">Practice Status</option>
                    <option value="tuning">Tuning</option>
                    <option value="bands">Bands</option>
                    <option value="tags">Tags</option>
                    <option value="key">Key</option>
                    <option value="firstNote">First Note</option>
                    <option value="lastNote">Last Note</option>
                </select>
                
                <input type="text" id="filterValue" class="filter-input" placeholder="Filter value..." list="filterSuggestions" onkeypress="if(event.key==='Enter') addFilter()" style="width: 200px;">
                <datalist id="filterSuggestions"></datalist>
                
                <button class="btn-success btn-filter" onclick="addFilter()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="vertical-align: middle; margin-right: 4px;">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add Filter
                </button>
                
                <button class="btn-secondary btn-filter" onclick="clearAllFilters()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="vertical-align: middle; margin-right: 4px;">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                    Clear All
                </button>
            </div>

            <!-- Active Filters -->
            <div id="activeFilters" class="active-filters"></div>
            
            <!-- Column Visibility Panel -->
            <div id="columnVisibilityPanel" style="display: none; margin-top: 10px; margin-bottom: 15px; padding: 12px; background: #000000; border-radius: 8px; border: 1px solid var(--primary-border);">
                <h4 style="margin: 0 0 10px 0; color: var(--primary-color);">Show/Hide Columns</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-artist" checked onchange="toggleColumn('artist')">
                        <span>Artist</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-song" checked onchange="toggleColumn('song')">
                        <span>Song</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-album" checked onchange="toggleColumn('album')">
                        <span>Album</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-duration" checked onchange="toggleColumn('duration')">
                        <span>Duration</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-practiceStatus" checked onchange="toggleColumn('practiceStatus')">
                        <span>Status</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-link" checked onchange="toggleColumn('link')">
                        <span>Link</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-tuning" checked onchange="toggleColumn('tuning')">
                        <span>Tuning</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-bands" checked onchange="toggleColumn('bands')">
                        <span>Bands</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-tags" checked onchange="toggleColumn('tags')">
                        <span>Tags</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-key" checked onchange="toggleColumn('key')">
                        <span>Key</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-firstNote" checked onchange="toggleColumn('firstNote')">
                        <span>First Note</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-lastNote" checked onchange="toggleColumn('lastNote')">
                        <span>Last Note</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-playCount" checked onchange="toggleColumn('playCount')">
                        <span>Plays</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="col-actions" checked onchange="toggleColumn('actions')">
                        <span>Actions</span>
                    </label>
                </div>
            </div>

            <!-- Bulk Actions Bar -->
            <div id="bulkActionsBar" style="display: none; margin-top: 15px; padding: 15px; background: var(--primary-bg); border: 2px solid var(--primary-border); border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="color: var(--primary-light); font-weight: 600;">
                        <span id="selectedCount">0</span> song(s) selected
                    </div>
                    <div class="button-group">
                        <button class="btn-primary btn-small" onclick="openBulkEditModal()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                        </svg>
                            Bulk Edit
                    </button>
                        <button class="btn-danger btn-small" onclick="bulkDelete()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                <polyline points="3 6 5 6 21 6"/>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                            Delete Selected
                    </button>
                        <button class="btn-secondary btn-small" onclick="clearBulkSelection()">Clear Selection</button>
                </div>
                </div>
            </div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th class="col-checkbox" style="width: 40px;">
                            <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()" title="Select All">
                        </th>
                        <th class="col-actions">Actions</th>
                        <th class="col-link">Link</th>
                        <th class="sortable col-artist" onclick="sortTable('artist')">Artist</th>
                        <th class="sortable col-song" onclick="sortTable('song')">Song</th>
                        <th class="sortable col-album" onclick="sortTable('album')">Album</th>
                        <th class="sortable col-duration" onclick="sortTable('duration')">Duration</th>
                        <th class="sortable col-practiceStatus" onclick="sortTable('practiceStatus')">Status</th>
                        <th class="sortable col-tuning" onclick="sortTable('tuning')">Tuning</th>
                        <th class="sortable col-bands" onclick="sortTable('bands')">Bands</th>
                        <th class="sortable col-tags" onclick="sortTable('tags')">Tags</th>
                        <th class="sortable col-key" onclick="sortTable('key')">Key</th>
                        <th class="sortable col-firstNote" onclick="sortTable('firstNote')">First Note</th>
                        <th class="sortable col-lastNote" onclick="sortTable('lastNote')">Last Note</th>
                        <th class="sortable col-playCount" onclick="sortTable('playCount')">Plays</th>
                    </tr>
                </thead>
                <tbody id="songTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Add/Edit Modal -->
    <div id="songModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Add Song</h2>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <form id="songForm">
                <div class="form-group">
                    <label>Artist *</label>
                    <input type="text" id="artist" required>
                </div>
                <div class="form-group">
                    <label>Song *</label>
                    <input type="text" id="song" required>
                </div>
                <div class="form-group">
                    <label>Album</label>
                    <input type="text" id="album">
                </div>
                <div class="form-group">
                    <label>Link</label>
                    <input type="url" id="link">
                </div>
                <div class="form-group">
                    <label>Tuning</label>
                    <input type="text" id="tuning" placeholder="e.g., Standard, Drop D">
                </div>
                <div class="form-group">
                    <label>Bands</label>
                    <input type="text" id="bands" placeholder="Comma-separated band names">
                </div>
                <div class="form-group">
                    <label>Tags</label>
                    <input type="text" id="tags" placeholder="e.g., upbeat, ballad, dance, cover, original">
                    <small style="color: #999; display: block; margin-top: 5px;">Comma-separated tags for flexible organization</small>
                </div>
                <div class="form-group">
                    <label>Duration (mm:ss)</label>
                    <input type="text" id="duration" placeholder="e.g., 3:45" pattern="[0-9]{1,2}:[0-9]{2}">
                </div>
                <div class="form-group">
                    <label>Practice Status</label>
                    <select id="practiceStatus">
                        <option value="">Not set</option>
                        <option value="learning">🎓 Learning</option>
                        <option value="practicing">🎵 Practicing</option>
                        <option value="ready">✓ Ready</option>
                        <option value="mastered">⭐ Mastered</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Key</label>
                    <input type="text" id="key" placeholder="e.g., Am, G">
                </div>
                <div class="form-group">
                    <label>First Note</label>
                    <input type="text" id="firstNote">
                </div>
                <div class="form-group">
                    <label>Last Note</label>
                    <input type="text" id="lastNote">
                </div>
                <div class="button-group">
                    <button type="submit" class="btn-primary" id="saveSongBtn">
                        <span id="saveBtnText">Save</span>
                        <span id="saveBtnSpinner" style="display: none;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; animation: spin 1s linear infinite;">
                                <circle cx="12" cy="12" r="10" stroke-opacity="0.25"/>
                                <path d="M12 2 A10 10 0 0 1 22 12" stroke-opacity="1"/>
                            </svg>
                            Saving...
                        </span>
                    </button>
                    <button type="button" class="btn-secondary" onclick="closeModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Import Preview Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content large">
            <div class="modal-header">
                <h2>Import Preview <span style="font-size: 14px; color: #6b7280; font-weight: normal;">(Drag corner to resize)</span></h2>
                <span class="close" onclick="closeImportModal()">&times;</span>
            </div>
            <div id="importPreview" class="import-preview"></div>
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn-success" onclick="confirmImport()">✓ Confirm Import</button>
                <button class="btn-secondary" onclick="closeImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Trash Modal -->
    <div id="trashModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="color: var(--primary-light); text-align: center;">🗑️ Trash (2-day retention)</h2>
                <span class="close" onclick="closeTrashModal()">&times;</span>
            </div>
            <div id="trashContent" style="max-height: 500px; overflow-y: auto;">
                <!-- Trash items will be rendered here -->
            </div>
            <div class="button-group" style="margin-top: 20px;">
                <button class="btn-primary" onclick="restoreAllFromTrash()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M3 7v6h6"/>
                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                    </svg>
                    Restore All
                </button>
                <button class="btn-danger" onclick="emptyTrash()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <polyline points="3 6 5 6 21 6"/>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                    </svg>
                    Empty Trash
                </button>
                <button class="btn-secondary" onclick="closeTrashModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Save Filter Modal -->
    <div id="saveFilterModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="display: flex; align-items: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Current Filter
                </h2>
                <span class="close" onclick="closeSaveFilterModal()">&times;</span>
            </div>
            <div style="padding: 20px;">
                <p style="color: #999; margin-bottom: 15px;">Save your current search and filter settings for quick access later.</p>
                <div class="form-group">
                    <label>Filter Name *</label>
                    <input type="text" id="filterNameInput" placeholder="e.g., Drop D Songs, Practice Queue" required>
                </div>
                <div style="padding: 15px; background: rgba(40, 40, 40, 0.5); border-radius: 6px; margin-bottom: 15px;">
                    <h4 style="color: var(--primary-color); margin: 0 0 10px 0;">Current Settings:</h4>
                    <div id="currentFilterSummary" style="color: #ccc; font-size: 0.9em;"></div>
                </div>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="saveCurrentFilter()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Save Filter
                </button>
                <button class="btn-secondary" onclick="closeSaveFilterModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Manage Filters Modal -->
    <div id="manageFiltersModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="display: flex; align-items: center; gap: 8px;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"/>
                        <polygon points="18 2 22 6 12 16 8 16 8 12 18 2"/>
                    </svg>
                    Manage Saved Filters
                </h2>
                <span class="close" onclick="closeManageFiltersModal()">&times;</span>
            </div>
            <div id="savedFiltersList" style="padding: 20px; max-height: 400px; overflow-y: auto;"></div>
            <div class="button-group">
                <button class="btn-secondary" onclick="closeManageFiltersModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Bulk Edit Modal -->
    <div id="bulkEditModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Bulk Edit <span id="bulkEditCount" style="color: var(--primary-light);">(0 songs)</span></h2>
                <span class="close" onclick="closeBulkEditModal()">&times;</span>
            </div>
            <form id="bulkEditForm" style="margin-top: 20px;">
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,107,61,0.1); border: 1px solid var(--primary-border); border-radius: 6px;">
                    <p style="color: var(--primary-light); margin-bottom: 10px;">
                        <strong>How bulk edit works:</strong>
                    </p>
                    <ul style="color: #999; font-size: 14px; margin-left: 20px;">
                        <li><strong>Replace:</strong> Overwrites the field with new value</li>
                        <li><strong>Add:</strong> Appends to existing value (for bands/tags)</li>
                        <li><strong>Remove:</strong> Removes specific text from field</li>
                    </ul>
                </div>

                <!-- Tuning -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateTuning">
                        <strong>Update Tuning</strong>
                    </label>
                    <div id="tuningBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkTuning" placeholder="e.g., Drop D, Standard, DADGAD" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkTuningAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- Album -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateAlbum">
                        <strong>Update Album</strong>
                    </label>
                    <div id="albumBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkAlbum" placeholder="e.g., Greatest Hits, Live Album" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkAlbumAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- Duration -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateDuration">
                        <strong>Update Duration</strong>
                    </label>
                    <div id="durationBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkDuration" placeholder="e.g., 3:45, 4:20" pattern="[0-9]{1,2}:[0-9]{2}" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkDurationAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                        <small style="color: #999; display: block; margin-top: 5px;">Format: mm:ss</small>
                    </div>
                </div>

                <!-- Bands -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateBands">
                        <strong>Update Bands</strong>
                    </label>
                    <div id="bandsBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkBands" placeholder="e.g., Rock Band, Jazz Trio" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkBandsAction" style="width: 100%; padding: 8px;">
                            <option value="add">Add to existing bands</option>
                            <option value="replace">Replace all bands</option>
                            <option value="remove">Remove from bands</option>
                        </select>
                    </div>
                </div>

                <!-- Tags -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateTags">
                        <strong>Update Tags</strong>
                    </label>
                    <div id="tagsBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkTags" placeholder="e.g., upbeat, dance, cover" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkTagsAction" style="width: 100%; padding: 8px;">
                            <option value="add">Add to existing tags</option>
                            <option value="replace">Replace all tags</option>
                            <option value="remove">Remove from tags</option>
                        </select>
                    </div>
                </div>

                <!-- Practice Status -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateStatus">
                        <strong>Update Practice Status</strong>
                    </label>
                    <div id="statusBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <select id="bulkPracticeStatus" style="width: 100%; padding: 8px;">
                            <option value="">Not set</option>
                            <option value="learning">🎓 Learning</option>
                            <option value="practicing">🎵 Practicing</option>
                            <option value="ready">✓ Ready</option>
                            <option value="mastered">⭐ Mastered</option>
                        </select>
                    </div>
                </div>

                <!-- Key -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateKey">
                        <strong>Update Key</strong>
                    </label>
                    <div id="keyBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkKey" placeholder="e.g., Am, G, C#m" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkKeyAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- First Note -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateFirstNote">
                        <strong>Update First Note</strong>
                    </label>
                    <div id="firstNoteBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkFirstNote" placeholder="e.g., A, C#, Eb" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkFirstNoteAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <!-- Last Note -->
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="bulkUpdateLastNote">
                        <strong>Update Last Note</strong>
                    </label>
                    <div id="lastNoteBulkOptions" style="display: none; margin-top: 10px; margin-left: 30px;">
                        <input type="text" id="bulkLastNote" placeholder="e.g., E, G, D" style="width: 100%; padding: 8px; margin-bottom: 8px;">
                        <select id="bulkLastNoteAction" style="width: 100%; padding: 8px;">
                            <option value="replace">Replace existing value</option>
                        </select>
                    </div>
                </div>

                <div class="button-group" style="margin-top: 30px;">
                    <button type="submit" class="btn-success">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 6px;">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        Apply Changes
                    </button>
                    <button type="button" class="btn-secondary" onclick="closeBulkEditModal()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        /**
         * Debounce function - delays execution until after specified wait time
         * @param {Function} func - Function to debounce
         * @param {number} wait - Milliseconds to wait
         * @returns {Function} Debounced function
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================
        
        let songs = [];
        let editIndex = -1;
        let importData = [];
        let currentSort = { column: null, direction: 'asc' };
        let activeFilters = [];
        let hiddenColumns = new Set(); // Track hidden columns
        
        // Performance: Memoization caches
        let statsCache = null;
        let statsCacheKey = null;
        let searchDebounceTimer = null; // For debouncing search
        let lastFilterState = null; // Cache last filter state to avoid redundant filtering
        let cachedFilteredSongs = null; // Cache filtered results
        
        // Autocomplete system
        let autocompleteSelectedIndex = -1;
        let autocompleteSuggestions = [];
        
        // Undo system
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 10;
        
        // Trash system - Simple version that works
        let trash = [];
        const TRASH_RETENTION_DAYS = 2;
        
        // Bulk edit system
        let selectedSongIndices = new Set();

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '✓',
                error: '✕',
                warning: '⚠',
                info: 'ℹ'
            };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-message">${message}</div>
                <div class="toast-close" onclick="this.parentElement.remove()">✕</div>
            `;
            
            container.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('hide');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // Auto-save indicator
        function showSaveIndicator() {
            const indicator = document.getElementById('saveIndicator');
            indicator.classList.add('show', 'saved');
            
            setTimeout(() => {
                indicator.classList.remove('show');
                setTimeout(() => {
                    indicator.classList.remove('saved');
                }, 300);
            }, 1500);
        }

        // Undo system functions
        function saveUndoState(action, data) {
            undoHistory.push({
                action: action,
                data: JSON.parse(JSON.stringify(data)), // Deep clone
                timestamp: Date.now()
            });
            
            // Limit history size
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }

        function undo() {
            if (undoHistory.length === 0) return;
            
            const lastAction = undoHistory.pop();
            console.log('Undoing action:', lastAction.action, lastAction.data);
            
            switch (lastAction.action) {
                case 'delete':
                    // Restore deleted song
                    songs.splice(lastAction.data.index, 0, lastAction.data.song);
                    
                    // IMPORTANT: Also remove from trash if it's there
                    const songToRemove = lastAction.data.song;
                    trash = trash.filter(item => 
                        !(item.song.song === songToRemove.song && item.song.artist === songToRemove.artist)
                    );
                    saveTrash();
                    
                    showToast(`Restored: ${lastAction.data.song.song} by ${lastAction.data.song.artist}`, 'success');
                    break;
                    
                case 'bulkDelete':
                    // Restore multiple deleted songs
                    if (lastAction.data.songs && Array.isArray(lastAction.data.songs)) {
                        lastAction.data.songs.forEach(item => {
                            songs.splice(item.index, 0, item.song);
                            
                            // Also remove from trash
                            trash = trash.filter(trashItem => 
                                !(trashItem.song.song === item.song.song && trashItem.song.artist === item.song.artist)
                            );
                        });
                        saveTrash();
                        showToast(`Restored ${lastAction.data.songs.length} song(s)`, 'success');
                    }
                    break;
                    
                case 'add':
                    // Remove added song
                    songs.pop();
                    showToast('Add song undone', 'info');
                    break;
                    
                case 'edit':
                    // Restore old song data
                    songs[lastAction.data.index] = lastAction.data.oldSong;
                    showToast('Edit undone', 'info');
                    break;
                    
                case 'clearAll':
                    // Restore all songs
                    songs = lastAction.data.songs;
                    showToast(`Restored ${songs.length} song(s)`, 'success');
                    break;
                    
                case 'import':
                    // Remove imported songs
                    songs.splice(songs.length - lastAction.data.count, lastAction.data.count);
                    showToast(`Import of ${lastAction.data.count} song(s) undone`, 'info');
                    break;
                    
                default:
                    console.warn('Unknown undo action:', lastAction.action);
                    showToast('Cannot undo this action', 'warning');
                    return;
            }
            
            saveSongs();
            applyFilters();
            updateStats();
            updateUndoButton();
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoButton');
            if (undoBtn) {
                undoBtn.disabled = undoHistory.length === 0;
                if (undoHistory.length > 0) {
                    const lastAction = undoHistory[undoHistory.length - 1];
                    const actionNames = {
                        'delete': 'Undo delete',
                        'add': 'Undo add',
                        'edit': 'Undo edit',
                        'clearAll': 'Undo clear all',
                        'import': 'Undo import'
                    };
                    undoBtn.title = actionNames[lastAction.action] || 'Undo last action';
                }
            }
        }

        // Keyboard shortcut for undo
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
        });

        // Bulk edit system functions
        function toggleSongSelection(index, event) {
            const checkbox = event.target;
            
            // Sync our Set with the checkbox state
            if (checkbox.checked) {
                selectedSongIndices.add(index);
            } else {
                selectedSongIndices.delete(index);
            }
            
            updateSelectAllCheckbox();
            updateBulkActionsBar();
        }

        function toggleSelectAll() {
            const checkbox = document.getElementById('selectAllCheckbox');
            if (checkbox.checked) {
                // Select all visible songs
                songs.forEach((_, index) => selectedSongIndices.add(index));
            } else {
                selectedSongIndices.clear();
            }
            applyFilters(); // Re-render to update checkboxes
        }

        function updateSelectAllCheckbox() {
            const checkbox = document.getElementById('selectAllCheckbox');
            if (selectedSongIndices.size === 0) {
                checkbox.checked = false;
                checkbox.indeterminate = false;
            } else if (selectedSongIndices.size === songs.length) {
                checkbox.checked = true;
                checkbox.indeterminate = false;
            } else {
                checkbox.checked = false;
                checkbox.indeterminate = true;
            }
        }

        function updateBulkActionsBar() {
            const bar = document.getElementById('bulkActionsBar');
            const count = document.getElementById('selectedCount');
            
            count.textContent = selectedSongIndices.size;
            
            if (selectedSongIndices.size > 0) {
                bar.style.display = 'block';
            } else {
                bar.style.display = 'none';
            }
            
            updateSelectAllCheckbox();
        }

        function clearBulkSelection() {
            selectedSongIndices.clear();
            applyFilters(); // Re-render to update checkboxes
        }

        function openBulkEditModal() {
            if (selectedSongIndices.size === 0) {
                showToast('No songs selected!', 'warning');
                return;
            }
            
            document.getElementById('bulkEditCount').textContent = `(${selectedSongIndices.size} songs)`;
            document.getElementById('bulkEditModal').classList.add('active');
            
            // Set up checkbox toggle handlers
            const checkboxes = [
                'bulkUpdateTuning', 
                'bulkUpdateAlbum', 
                'bulkUpdateDuration', 
                'bulkUpdateBands', 
                'bulkUpdateTags', 
                'bulkUpdateStatus', 
                'bulkUpdateKey',
                'bulkUpdateFirstNote',
                'bulkUpdateLastNote'
            ];
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                const optionsId = id.replace('bulkUpdate', '').toLowerCase() + 'BulkOptions';
                checkbox.onchange = function() {
                    document.getElementById(optionsId).style.display = this.checked ? 'block' : 'none';
                };
            });
        }

        function closeBulkEditModal() {
            document.getElementById('bulkEditModal').classList.remove('active');
            document.getElementById('bulkEditForm').reset();
            // Hide all option divs
            [
                'tuningBulkOptions', 
                'albumBulkOptions', 
                'durationBulkOptions', 
                'bandsBulkOptions', 
                'tagsBulkOptions', 
                'statusBulkOptions', 
                'keyBulkOptions',
                'firstNoteBulkOptions',
                'lastNoteBulkOptions'
            ].forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
        }

        // Progress indicator variables
        let progressCancelRequested = false;

        function showProgress(title, message) {
            progressCancelRequested = false;
            document.getElementById('progressTitle').textContent = title;
            document.getElementById('progressMessage').textContent = message;
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            document.getElementById('progressStats').textContent = '';
            document.getElementById('progressCancelBtn').style.display = 'inline-block';
            document.getElementById('progressModal').classList.add('active');
        }

        function updateProgress(current, total, message = '') {
            const percent = Math.round((current / total) * 100);
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressBar').textContent = percent + '%';
            if (message) {
                document.getElementById('progressMessage').textContent = message;
            }
            document.getElementById('progressStats').textContent = `${current} of ${total} completed`;
        }

        function hideProgress() {
            document.getElementById('progressModal').classList.remove('active');
            progressCancelRequested = false;
        }

        function cancelBulkOperation() {
            progressCancelRequested = true;
            document.getElementById('progressCancelBtn').disabled = true;
            document.getElementById('progressCancelBtn').textContent = 'Cancelling...';
        }

        async function bulkDelete() {
            if (selectedSongIndices.size === 0) {
                showToast('No songs selected!', 'warning');
                return;
            }
            
            if (!confirm(`Move ${selectedSongIndices.size} song(s) to trash?`)) {
                return;
            }
            
            const totalSongs = selectedSongIndices.size;
            showProgress('Deleting Songs', `Preparing to delete ${totalSongs} song(s)...`);
            
            // Save undo state
            const deletedSongs = [];
            selectedSongIndices.forEach(index => {
                deletedSongs.push({ index, song: JSON.parse(JSON.stringify(songs[index])) });
            });
            saveUndoState('bulkDelete', { songs: deletedSongs });
            
            // Move to trash and delete (in reverse order to maintain indices)
            const indicesToDelete = Array.from(selectedSongIndices).sort((a, b) => b - a);
            
            // Process in batches with progress updates
            let processed = 0;
            for (const index of indicesToDelete) {
                if (progressCancelRequested) {
                    hideProgress();
                    showToast('Delete operation cancelled', 'warning');
                    return;
                }
                
                trash.push({
                    song: JSON.parse(JSON.stringify(songs[index])),
                    deletedAt: Date.now()
                });
                songs.splice(index, 1);
                processed++;
                
                updateProgress(processed, totalSongs, `Deleting song ${processed} of ${totalSongs}...`);
                
                // Allow UI to update every 10 songs
                if (processed % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            selectedSongIndices.clear();
            saveSongs();
            saveTrash();
            applyFilters();
            updateStats();
            hideProgress();
            showToast(`${indicesToDelete.length} song(s) moved to trash`, 'success');
        }

        // Handle bulk edit form submission
        document.getElementById('bulkEditForm').onsubmit = async function(e) {
            e.preventDefault();
            
            const totalSongs = selectedSongIndices.size;
            showProgress('Updating Songs', `Preparing to update ${totalSongs} song(s)...`);
            
            let updateCount = 0;
            const updates = [];
            
            // Get selected songs
            const selectedSongs = Array.from(selectedSongIndices).map(i => songs[i]);
            
            let processed = 0;
            for (let idx = 0; idx < selectedSongs.length; idx++) {
                if (progressCancelRequested) {
                    hideProgress();
                    showToast('Update operation cancelled', 'warning');
                    return;
                }
                
                const song = selectedSongs[idx];
                const originalIndex = Array.from(selectedSongIndices)[idx];
                let hasChanges = false;
                
                updateProgress(processed + 1, totalSongs, `Updating song ${processed + 1} of ${totalSongs}...`);
                
                // Tuning
                if (document.getElementById('bulkUpdateTuning').checked) {
                    const value = document.getElementById('bulkTuning').value.trim();
                    if (value) {
                        song.tuning = value;
                        hasChanges = true;
                    }
                }
                
                // Album
                if (document.getElementById('bulkUpdateAlbum').checked) {
                    const value = document.getElementById('bulkAlbum').value.trim();
                    if (value) {
                        song.album = value;
                        hasChanges = true;
                    }
                }
                
                // Duration
                if (document.getElementById('bulkUpdateDuration').checked) {
                    const value = document.getElementById('bulkDuration').value.trim();
                    if (value) {
                        song.duration = value;
                        hasChanges = true;
                    }
                }
                
                // Bands
                if (document.getElementById('bulkUpdateBands').checked) {
                    const value = document.getElementById('bulkBands').value.trim();
                    const action = document.getElementById('bulkBandsAction').value;
                    if (value) {
                        if (action === 'replace') {
                            song.bands = value;
                            hasChanges = true;
                        } else if (action === 'add') {
                            const existing = song.bands ? song.bands.split(',').map(b => b.trim()) : [];
                            const newBands = value.split(',').map(b => b.trim());
                            const combined = [...new Set([...existing, ...newBands])];
                            song.bands = combined.join(', ');
                            hasChanges = true;
                        } else if (action === 'remove') {
                            const existing = song.bands ? song.bands.split(',').map(b => b.trim()) : [];
                            const toRemove = value.split(',').map(b => b.trim());
                            const filtered = existing.filter(b => !toRemove.includes(b));
                            song.bands = filtered.join(', ');
                            hasChanges = true;
                        }
                    }
                }
                
                // Tags
                if (document.getElementById('bulkUpdateTags').checked) {
                    const value = document.getElementById('bulkTags').value.trim();
                    const action = document.getElementById('bulkTagsAction').value;
                    if (value) {
                        if (action === 'replace') {
                            song.tags = value;
                            hasChanges = true;
                        } else if (action === 'add') {
                            const existing = song.tags ? song.tags.split(',').map(t => t.trim()) : [];
                            const newTags = value.split(',').map(t => t.trim());
                            const combined = [...new Set([...existing, ...newTags])];
                            song.tags = combined.join(', ');
                            hasChanges = true;
                        } else if (action === 'remove') {
                            const existing = song.tags ? song.tags.split(',').map(t => t.trim()) : [];
                            const toRemove = value.split(',').map(t => t.trim());
                            const filtered = existing.filter(t => !toRemove.includes(t));
                            song.tags = filtered.join(', ');
                            hasChanges = true;
                        }
                    }
                }
                
                // Practice Status
                if (document.getElementById('bulkUpdateStatus').checked) {
                    song.practiceStatus = document.getElementById('bulkPracticeStatus').value;
                    hasChanges = true;
                }
                
                // Key
                if (document.getElementById('bulkUpdateKey').checked) {
                    const value = document.getElementById('bulkKey').value.trim();
                    if (value) {
                        song.key = value;
                        hasChanges = true;
                    }
                }
                
                // First Note
                if (document.getElementById('bulkUpdateFirstNote').checked) {
                    const value = document.getElementById('bulkFirstNote').value.trim();
                    if (value) {
                        song.firstNote = value;
                        hasChanges = true;
                    }
                }
                
                // Last Note
                if (document.getElementById('bulkUpdateLastNote').checked) {
                    const value = document.getElementById('bulkLastNote').value.trim();
                    if (value) {
                        song.lastNote = value;
                        hasChanges = true;
                    }
                }
                
                if (hasChanges) {
                    updateCount++;
                    updates.push({ index: originalIndex, song: JSON.parse(JSON.stringify(song)) });
                }
                
                processed++;
                
                // Allow UI to update every 10 songs
                if (processed % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            hideProgress();
            
            if (updateCount === 0) {
                showToast('No changes to apply. Please select at least one field to update.', 'warning');
                return;
            }
            
            // Save undo state
            saveUndoState('bulkEdit', { updates });
            
            // Save and update
            saveSongs();
            applyFilters();
            closeBulkEditModal();
            selectedSongIndices.clear();
            showToast(`Successfully updated ${updateCount} song(s)!`, 'success');
        };

        // Trash system functions
        function loadTrash() {
            const stored = localStorage.getItem('bandSongsTrash');
            if (stored) {
                trash = JSON.parse(stored);
                cleanExpiredTrash();
            }
        }

        function saveTrash() {
            localStorage.setItem('bandSongsTrash', JSON.stringify(trash));
            updateTrashCount();
        }

        // Duplicate detection using Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1, // substitution
                            matrix[i][j - 1] + 1,     // insertion
                            matrix[i - 1][j] + 1      // deletion
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        function findSimilarSongs(artist, song, threshold = 0.8) {
            const similar = [];
            const artistLower = artist.toLowerCase();
            const songLower = song.toLowerCase();

            songs.forEach((existingSong, index) => {
                // Skip the song being edited
                if (editIndex >= 0 && index === editIndex) return;

                const existingArtistLower = existingSong.artist.toLowerCase();
                const existingSongLower = existingSong.song.toLowerCase();

                // Calculate similarity
                const artistDist = levenshteinDistance(artistLower, existingArtistLower);
                const songDist = levenshteinDistance(songLower, existingSongLower);

                const artistSim = 1 - (artistDist / Math.max(artistLower.length, existingArtistLower.length));
                const songSim = 1 - (songDist / Math.max(songLower.length, existingSongLower.length));

                // If both artist and song are very similar, or exact match
                if ((artistSim > threshold && songSim > threshold) || 
                    (artistLower === existingArtistLower && songLower === existingSongLower)) {
                    similar.push({
                        song: existingSong,
                        artistSimilarity: artistSim,
                        songSimilarity: songSim,
                        index: index
                    });
                }
            });

            return similar;
        }

        function showDuplicateWarning(similarSongs, callback) {
            if (similarSongs.length === 0) {
                callback(true);
                return;
            }

            const duplicateList = similarSongs.map(item => 
                `• ${escapeHtml(item.song.song)} by ${escapeHtml(item.song.artist)}`
            ).join('\n');

            const message = `⚠️ Found ${similarSongs.length} similar song(s):\n\n${duplicateList}\n\nDo you want to add this song anyway?`;
            
            if (confirm(message)) {
                callback(true);
            } else {
                callback(false);
            }
        }

        function cleanExpiredTrash() {
            const now = Date.now();
            const retentionMs = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000;
            trash = trash.filter(item => (now - item.deletedAt) < retentionMs);
            saveTrash();
        }

        function moveToTrash(song) {
            trash.push({
                song: JSON.parse(JSON.stringify(song)),
                deletedAt: Date.now()
            });
            saveTrash();
        }

        function restoreFromTrash(index) {
            const item = trash[index];
            if (!item || !item.song) {
                showToast('Invalid trash item', 'error');
                return;
            }
            
            console.log('Restoring:', item.song.song, 'by', item.song.artist);
            
            // Add back to songs
            songs.push(item.song);
            
            // Remove from trash
            trash.splice(index, 1);
            
            // Save
            localStorage.setItem('songDatabase', JSON.stringify(songs));
            localStorage.setItem('songTrash', JSON.stringify(trash));
            
            // Show message and reload page
            showToast(`Restoring song - page will reload...`, 'success');
            setTimeout(() => location.reload(), 800);
        }

        function restoreAllFromTrash() {
            if (trash.length === 0) {
                showToast('Trash is empty', 'info');
                return;
            }
            
            const count = trash.length;
            
            // Add all songs back
            trash.forEach(item => {
                songs.push(item.song);
            });
            
            // Clear trash
            trash = [];
            
            // Save
            localStorage.setItem('songDatabase', JSON.stringify(songs));
            localStorage.setItem('songTrash', JSON.stringify(trash));
            
            // Reload
            showToast(`Restoring ${count} songs - page will reload...`, 'success');
            setTimeout(() => location.reload(), 800);
        }

        function emergencyRecovery() {
            console.log('=== EMERGENCY RECOVERY ===');
            console.log('Current songs count:', songs.length);
            console.log('Current trash count:', trash.length);
            
            // Check localStorage for backup data
            const backupSongs = localStorage.getItem('songDatabase');
            const backupTrash = localStorage.getItem('songTrash');
            
            console.log('LocalStorage songDatabase:', backupSongs ? JSON.parse(backupSongs).length : 0);
            console.log('LocalStorage songTrash:', backupTrash ? JSON.parse(backupTrash).length : 0);
            
            // Show recovery dialog
            const message = `Current State:
- Songs in table: ${songs.length}
- Songs in trash: ${trash.length}
- Songs in localStorage: ${backupSongs ? JSON.parse(backupSongs).length : 0}
- Trash in localStorage: ${backupTrash ? JSON.parse(backupTrash).length : 0}

What would you like to do?
1. Reload from localStorage (may restore lost songs)
2. Export current data to CSV as backup
3. Cancel`;
            
            const choice = prompt(message + '\n\nEnter 1, 2, or 3:');
            
            if (choice === '1') {
                // Reload from localStorage
                songs = backupSongs ? JSON.parse(backupSongs) : [];
                trash = backupTrash ? JSON.parse(backupTrash) : [];
                
                // Clear filters and re-render
                document.getElementById('searchBox').value = '';
                activeFilters = [];
                updateFilterTags();
                renderSongs(songs);
                updateStats();
                renderTrashContent();
                
                showToast(`Reloaded: ${songs.length} songs, ${trash.length} in trash`, 'success');
                console.log('Recovery complete - songs:', songs.length, 'trash:', trash.length);
            } else if (choice === '2') {
                exportToCSV();
            }
        }

        function deleteFromTrashPermanently(index) {
            const item = trash[index];
            if (confirm(`Permanently delete "${item.song.song}" by ${item.song.artist}? This cannot be undone!`)) {
                trash.splice(index, 1);
                saveTrash();
                renderTrashContent();
                showToast('Permanently deleted', 'warning');
            }
        }

        function emptyTrash() {
            if (trash.length === 0) {
                showToast('Trash is already empty', 'info');
                return;
            }
            if (confirm(`Permanently delete all ${trash.length} item(s) in trash? This cannot be undone!`)) {
                trash = [];
                saveTrash();
                renderTrashContent();
                showToast('Trash emptied', 'warning');
            }
        }

        function updateTrashCount() {
            document.getElementById('trashCount').textContent = trash.length;
        }

        function openTrashModal() {
            cleanExpiredTrash();
            renderTrashContent();
            document.getElementById('trashModal').classList.add('active');
        }

        function closeTrashModal() {
            document.getElementById('trashModal').classList.remove('active');
        }

        function renderTrashContent() {
            const container = document.getElementById('trashContent');
            
            if (trash.length === 0) {
                container.innerHTML = '<div class="no-data">Trash is empty</div>';
                return;
            }

            const now = Date.now();
            const retentionMs = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000;

            container.innerHTML = trash.map((item, index) => {
                const timeLeft = retentionMs - (now - item.deletedAt);
                const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
                const daysLeft = Math.floor(hoursLeft / 24);
                const timeLeftStr = daysLeft > 0 
                    ? `${daysLeft} day${daysLeft !== 1 ? 's' : ''} left`
                    : `${hoursLeft} hour${hoursLeft !== 1 ? 's' : ''} left`;

                return `
                    <div class="import-item" style="margin-bottom: 10px;">
                        <h4>${escapeHtml(item.song.song)} - ${escapeHtml(item.song.artist)}</h4>
                        <div style="font-size: 13px; color: #999; margin-top: 5px;">
                            ${item.song.album ? `Album: ${escapeHtml(item.song.album)} • ` : ''}
                            ${item.song.key ? `Key: ${escapeHtml(item.song.key)} • ` : ''}
                            <span style="color: #f59e0b;">${timeLeftStr}</span>
                        </div>
                        <div class="button-group" style="margin-top: 10px;">
                            <button class="btn-success btn-small" onclick="restoreFromTrash(${index})">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                    <path d="M3 7v6h6"/>
                                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                                </svg>
                                Restore
                            </button>
                            <button class="btn-danger btn-small" onclick="deleteFromTrashPermanently(${index})">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                    <line x1="18" y1="6" x2="6" y2="18"/>
                                    <line x1="6" y1="6" x2="18" y2="18"/>
                                </svg>
                                Delete Permanently
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Theme Management
        function loadTheme() {
            const savedTheme = localStorage.getItem('bandOrganizerTheme') || 'grey';
            applyTheme(savedTheme);
            const themeSelector = document.getElementById('themeSelector');
            if (themeSelector) {
                themeSelector.value = savedTheme;
            }
        }

        function applyTheme(theme) {
            // Remove all theme data attributes
            document.body.removeAttribute('data-theme');
            
            // Apply new theme (only if not default grey)
            if (theme !== 'grey') {
                document.body.setAttribute('data-theme', theme);
            }
        }

        function changeTheme(theme) {
            localStorage.setItem('bandOrganizerTheme', theme);
            applyTheme(theme);
        }

        // Column Visibility Management
        function toggleColumnVisibilityPanel() {
            const panel = document.getElementById('columnVisibilityPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function toggleColumn(columnName) {
            const checkbox = document.getElementById(`col-${columnName}`);
            if (checkbox.checked) {
                hiddenColumns.delete(columnName);
            } else {
                hiddenColumns.add(columnName);
            }
            
            // Save to localStorage
            localStorage.setItem('hiddenColumns', JSON.stringify([...hiddenColumns]));
            
            // Re-render the table
            applyFilters();
        }

        function loadColumnVisibility() {
            const saved = localStorage.getItem('hiddenColumns');
            if (saved) {
                hiddenColumns = new Set(JSON.parse(saved));
                // Update checkboxes
                hiddenColumns.forEach(col => {
                    const checkbox = document.getElementById(`col-${col}`);
                    if (checkbox) checkbox.checked = false;
                });
            }
        }

        // Table Density Management
        let currentDensity = 'normal'; // normal, compact, spacious
        const densityModes = ['compact', 'normal', 'spacious'];

        function cycleDensity() {
            const currentIndex = densityModes.indexOf(currentDensity);
            const nextIndex = (currentIndex + 1) % densityModes.length;
            currentDensity = densityModes[nextIndex];
            
            applyDensity();
            saveDensity();
        }

        function applyDensity() {
            const table = document.querySelector('table');
            
            // Remove all density classes
            table.classList.remove('table-compact', 'table-spacious');
            
            // Apply current density class
            if (currentDensity === 'compact') {
                table.classList.add('table-compact');
            } else if (currentDensity === 'spacious') {
                table.classList.add('table-spacious');
            }
            
            // Update button label
            const label = document.getElementById('densityLabel');
            label.textContent = currentDensity.charAt(0).toUpperCase() + currentDensity.slice(1);
        }

        function saveDensity() {
            localStorage.setItem('tableDensity', currentDensity);
        }

        function loadDensity() {
            const saved = localStorage.getItem('tableDensity');
            if (saved && densityModes.includes(saved)) {
                currentDensity = saved;
                applyDensity();
            }
        }

        // Saved Filters Management
        let savedFilters = [];

        function loadSavedFilters() {
            const saved = localStorage.getItem('savedFilters');
            if (saved) {
                savedFilters = JSON.parse(saved);
                updateSavedFiltersDropdown();
            }
        }

        function saveSavedFilters() {
            localStorage.setItem('savedFilters', JSON.stringify(savedFilters));
        }

        function updateSavedFiltersDropdown() {
            const dropdown = document.getElementById('savedFiltersDropdown');
            dropdown.innerHTML = '<option value="">-- Select a saved filter --</option>';
            
            savedFilters.forEach((filter, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = filter.name;
                dropdown.appendChild(option);
            });
        }

        function openSaveFilterModal() {
            // Show current filter settings
            const summary = [];
            
            if (searchTerm) {
                summary.push(`Search: "${searchTerm}"`);
            }
            
            if (activeFilters.length > 0) {
                summary.push(`Active Filters: ${activeFilters.length}`);
                activeFilters.forEach(f => {
                    summary.push(`  - ${f.column}: ${f.value}`);
                });
            }
            
            if (currentSort.column) {
                summary.push(`Sort: ${currentSort.column} (${currentSort.direction})`);
            }
            
            if (summary.length === 0) {
                summary.push('No filters or search active');
            }
            
            document.getElementById('currentFilterSummary').innerHTML = summary.join('<br>');
            document.getElementById('filterNameInput').value = '';
            document.getElementById('saveFilterModal').classList.add('active');
            setTimeout(() => document.getElementById('filterNameInput').focus(), 100);
        }

        function closeSaveFilterModal() {
            document.getElementById('saveFilterModal').classList.remove('active');
        }

        function saveCurrentFilter() {
            const name = document.getElementById('filterNameInput').value.trim();
            
            if (!name) {
                showToast('⚠️ Please enter a filter name', 'error');
                return;
            }
            
            // Check if name already exists
            if (savedFilters.some(f => f.name === name)) {
                if (!confirm(`A filter named "${name}" already exists. Overwrite it?`)) {
                    return;
                }
                // Remove existing filter
                savedFilters = savedFilters.filter(f => f.name !== name);
            }
            
            // Save current state
            const filterState = {
                name: name,
                searchTerm: searchTerm,
                activeFilters: JSON.parse(JSON.stringify(activeFilters)),
                sort: JSON.parse(JSON.stringify(currentSort)),
                timestamp: new Date().toISOString()
            };
            
            savedFilters.push(filterState);
            saveSavedFilters();
            updateSavedFiltersDropdown();
            closeSaveFilterModal();
            
            showToast(`✓ Saved filter: "${name}"`);
        }

        function applySavedFilter() {
            const dropdown = document.getElementById('savedFiltersDropdown');
            const selectedIndex = dropdown.value;
            
            if (selectedIndex === '') return;
            
            const filter = savedFilters[parseInt(selectedIndex)];
            
            // Apply search term
            searchTerm = filter.searchTerm || '';
            document.getElementById('searchBox').value = searchTerm;
            
            // Clear and apply filters
            activeFilters = JSON.parse(JSON.stringify(filter.activeFilters || []));
            
            // Apply sort
            if (filter.sort && filter.sort.column) {
                currentSort = JSON.parse(JSON.stringify(filter.sort));
            }
            
            // Re-render
            invalidateFilterCache();
            applyFilters();
            
            showToast(`✓ Applied filter: "${filter.name}"`);
        }

        function openManageFiltersModal() {
            renderSavedFiltersList();
            document.getElementById('manageFiltersModal').classList.add('active');
        }

        function closeManageFiltersModal() {
            document.getElementById('manageFiltersModal').classList.remove('active');
        }

        function renderSavedFiltersList() {
            const container = document.getElementById('savedFiltersList');
            
            if (savedFilters.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px 20px;">No saved filters yet. Save your current search and filters to quickly access them later!</p>';
                return;
            }
            
            container.innerHTML = savedFilters.map((filter, index) => `
                <div style="background: rgba(40, 40, 40, 0.5); padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 1px solid rgba(255, 255, 255, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 5px 0; color: var(--primary-color);">${escapeHtml(filter.name)}</h3>
                            <p style="margin: 0; font-size: 0.85em; color: #999;">
                                Saved: ${new Date(filter.timestamp).toLocaleDateString()}
                            </p>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn-success btn-small" onclick="applySavedFilterByIndex(${index}); closeManageFiltersModal();" title="Apply this filter">
                                ✓ Apply
                            </button>
                            <button class="btn-danger btn-small" onclick="deleteSavedFilter(${index})" title="Delete this filter">
                                🗑️
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 0.9em; color: #ccc;">
                        ${filter.searchTerm ? `<div>🔍 Search: "${escapeHtml(filter.searchTerm)}"</div>` : ''}
                        ${filter.activeFilters && filter.activeFilters.length > 0 ? `<div>🎯 Filters: ${filter.activeFilters.length} active</div>` : ''}
                        ${filter.sort && filter.sort.column ? `<div>↕️ Sort: ${filter.sort.column} (${filter.sort.direction})</div>` : ''}
                    </div>
                </div>
            `).join('');
        }

        function applySavedFilterByIndex(index) {
            document.getElementById('savedFiltersDropdown').value = index;
            applySavedFilter();
        }

        function deleteSavedFilter(index) {
            const filter = savedFilters[index];
            
            if (!confirm(`Delete saved filter "${filter.name}"?`)) {
                return;
            }
            
            savedFilters.splice(index, 1);
            saveSavedFilters();
            updateSavedFiltersDropdown();
            renderSavedFiltersList();
            
            showToast(`✓ Deleted filter: "${filter.name}"`);
        }

        // Apply default sort (Artist → Album → Song)
        function applyDefaultSort() {
            songs.sort((a, b) => {
                // Sort by Artist first
                const artistA = (a.artist || '').toLowerCase();
                const artistB = (b.artist || '').toLowerCase();
                if (artistA < artistB) return -1;
                if (artistA > artistB) return 1;
                
                // If artists are the same, sort by Album
                const albumA = (a.album || '').toLowerCase();
                const albumB = (b.album || '').toLowerCase();
                if (albumA < albumB) return -1;
                if (albumA > albumB) return 1;
                
                // If albums are the same, sort by Song
                const songA = (a.song || '').toLowerCase();
                const songB = (b.song || '').toLowerCase();
                if (songA < songB) return -1;
                if (songA > songB) return 1;
                
                return 0;
            });
            
            // Save the sorted order
            saveSongs();
        }

        // Load data on page load
        window.onload = function() {
            loadTheme(); // Load theme first
            loadWatermark(); // Load watermark preference
            loadColumnVisibility(); // Load column visibility preferences
            loadDensity(); // Load table density preference
            loadSavedFilters(); // Load saved filters
            loadStatsPreferences(); // Load stats widget preferences
            loadSongs();
            loadTrash(); // Load trash
            applyDefaultSort(); // Sort by Artist → Album → Song
            applyFilters();
            updateStats();
            initColumnResizing(); // Initialize column resizing
            
            // Check if we need to search for a song from setlist manager
            const editSongSearch = localStorage.getItem('editSongSearch');
            if (editSongSearch) {
                try {
                    const { artist, song } = JSON.parse(editSongSearch);
                    // Set the search term
                    document.getElementById('searchBox').value = `${artist} ${song}`;
                    searchTerm = `${artist} ${song}`;
                    applyFilters();
                    // Clear the localStorage item
                    localStorage.removeItem('editSongSearch');
                    // Show a toast
                    showToast(`🔍 Showing results for: ${artist} - ${song}`);
                } catch (e) {
                    console.error('Error parsing editSongSearch:', e);
                    localStorage.removeItem('editSongSearch');
                }
            }
            
            // Performance: Debounced resize handler
            const handleResize = debounce(() => {
                // Handle any resize-dependent logic here
                // Currently minimal impact, but prevents issues if expanded later
                console.log('Window resized');
            }, 150);
            window.addEventListener('resize', handleResize);
            
            // Performance: Smooth scrolling with requestAnimationFrame
            const tableContainer = document.querySelector('.table-container');
            let ticking = false;
            
            tableContainer.addEventListener('scroll', () => {
                if (!ticking) {
                    window.requestAnimationFrame(() => {
                        // Handle scroll-dependent updates here
                        // Currently passive - just ensures smooth rendering
                        ticking = false;
                    });
                    ticking = true;
                }
            }, { passive: true });
            
            // Performance: Register Service Worker for PWA capabilities
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('[PWA] Service Worker registered:', registration.scope);
                        
                        // Check for updates periodically
                        setInterval(() => {
                            registration.update();
                        }, 60000); // Check every minute
                    })
                    .catch((error) => {
                        console.error('[PWA] Service Worker registration failed:', error);
                    });
            }
        };

        // Load and apply watermark preference
        function loadWatermark() {
            const watermark = localStorage.getItem('watermark') || 'guitar';
            if (watermark === 'drum') {
                document.body.classList.add('drum-watermark');
                updateIconStyles('drum');
                updateFavicon('drum');
            } else {
                document.body.classList.remove('drum-watermark');
                updateIconStyles('guitar');
                updateFavicon('guitar');
            }
        }

        // Switch watermark
        function switchWatermark(type) {
            localStorage.setItem('watermark', type);
            if (type === 'drum') {
                document.body.classList.add('drum-watermark');
            } else {
                document.body.classList.remove('drum-watermark');
            }
            updateIconStyles(type);
            updateFavicon(type);
        }

        // Update favicon to match watermark
        function updateFavicon(type) {
            const link = document.querySelector("link[rel*='icon']");
            if (!link) return;

            if (type === 'drum') {
                // Drum icon favicon - adjusted viewBox for better sizing and bolder strokes
                link.href = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 24' preserveAspectRatio='xMidYMid meet'><g transform='scale(1.4) translate(-2, -2)'><circle cx='23' cy='17' r='4.5' fill='none' stroke='%23d84315' stroke-width='2'/><line x1='16' y1='21.5' x2='16' y2='2' stroke='%23d84315' stroke-width='2'/><line x1='11' y1='5' x2='21' y2='5' stroke='%23d84315' stroke-width='2'/><line x1='18' y1='8' x2='28' y2='8' stroke='%23d84315' stroke-width='2'/><line x1='21' y1='10' x2='26' y2='10' stroke='%23d84315' stroke-width='2'/><line x1='7' y1='12.5' x2='18' y2='12.5' stroke='%23d84315' stroke-width='2'/><line x1='30' y1='12.5' x2='30' y2='2' stroke='%23d84315' stroke-width='2'/><line x1='25' y1='5' x2='35' y2='5' stroke='%23d84315' stroke-width='2'/><line x1='27' y1='8' x2='33' y2='8' stroke='%23d84315' stroke-width='2'/><line x1='26' y1='14' x2='31' y2='14' stroke='%23d84315' stroke-width='2'/></g></svg>";
            } else {
                // Guitar icon favicon
                link.href = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23d84315' stroke-width='2'><circle cx='12' cy='17' r='4.5'/><line x1='12' y1='12.5' x2='12' y2='2'/><line x1='9' y1='5' x2='15' y2='5'/><line x1='9' y1='8' x2='15' y2='8'/></svg>";
            }
        }

        // Update icon styles to show which is active
        function updateIconStyles(activeType) {
            const guitarIcon = document.getElementById('guitarIcon');
            const drumIcon = document.getElementById('drumIcon');
            
            if (activeType === 'guitar') {
                guitarIcon.style.opacity = '1';
                drumIcon.style.opacity = '0.5';
            } else {
                guitarIcon.style.opacity = '0.5';
                drumIcon.style.opacity = '1';
            }
        }

        // Load songs from localStorage
        function loadSongs() {
            // Try both keys for backward compatibility
            const stored = localStorage.getItem('songDatabase') || localStorage.getItem('bandSongs');
            if (stored) {
                songs = JSON.parse(stored);
                console.log('Loaded', songs.length, 'songs from localStorage');
            } else {
                console.log('No songs found in localStorage');
            }
        }

        // Save songs to localStorage
        function saveSongs() {
            localStorage.setItem('songDatabase', JSON.stringify(songs));
            localStorage.setItem('bandSongs', JSON.stringify(songs)); // Keep backup copy
            
            // Invalidate filter cache when songs change
            lastFilterState = null;
            cachedFilteredSongs = null;
            
            // Performance: Invalidate stats cache
            invalidateStatsCache();
            
            showSaveIndicator();
        }

        // Render songs table
        function renderSongs(filteredSongs = null) {
            const tbody = document.getElementById('songTableBody');
            const displaySongs = filteredSongs || songs;

            // Update column visibility in headers (cache the lookup)
            const columns = ['checkbox', 'actions', 'link', 'artist', 'song', 'album', 'duration', 'practiceStatus', 'tuning', 'bands', 'tags', 'key', 'firstNote', 'lastNote', 'playCount'];
            columns.forEach(col => {
                const headers = document.querySelectorAll(`.col-${col}`);
                const shouldHide = hiddenColumns.has(col);
                headers.forEach(header => {
                    header.classList.toggle('hidden-col', shouldHide);
                });
            });

            if (displaySongs.length === 0) {
                tbody.innerHTML = `<tr><td colspan="${columns.length - hiddenColumns.size}" class="no-data">No songs yet. Add your first song or import from CSV!</td></tr>`;
                return;
            }

            // Helper function to get practice status badge (cached)
            const badges = {
                'learning': '<span style="background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">🎓 Learning</span>',
                'practicing': '<span style="background: #f59e0b; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">🎵 Practicing</span>',
                'ready': '<span style="background: #10b981; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">✓ Ready</span>',
                'mastered': '<span style="background: #8b5cf6; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px;">⭐ Mastered</span>'
            };
            const getPracticeStatusBadge = (status) => badges[status] || '-';

            // Pre-compute hidden column classes (avoid repeated lookups)
            const colClasses = {};
            columns.forEach(col => {
                colClasses[col] = hiddenColumns.has(col) ? 'hidden-col' : '';
            });

            // Use array for faster string concatenation than .map().join()
            const rows = [];
            const len = displaySongs.length;
            
            for (let i = 0; i < len; i++) {
                const song = displaySongs[i];
                const originalIndex = song.originalIndex !== undefined ? song.originalIndex : i;
                const isSelected = selectedSongIndices.has(originalIndex);
                
                rows.push(`
                <tr>
                    <td class="col-checkbox ${colClasses.checkbox}">
                        <input type="checkbox" class="song-checkbox" ${isSelected ? 'checked' : ''} onchange="toggleSongSelection(${originalIndex}, event)" title="Select song">
                    </td>
                    <td class="col-actions ${colClasses.actions}">
                        <div class="action-buttons">
                            <button class="btn-secondary btn-small" onclick="editSong(${originalIndex})" title="Edit">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                </svg>
                            </button>
                            <button class="btn-danger btn-small" onclick="deleteSong(${originalIndex})" title="Delete">✕</button>
                        </div>
                    </td>
                    <td class="col-link ${colClasses.link}">${song.link ? `<a href="${escapeHtml(song.link)}" target="_blank" class="link-icon">🔗</a>` : '-'}</td>
                    <td class="col-artist editable-cell ${colClasses.artist}" ondblclick="startInlineEdit(this, ${originalIndex}, 'artist')" title="Double-click to edit">${escapeHtml(song.artist)}</td>
                    <td class="col-song editable-cell ${colClasses.song}" ondblclick="startInlineEdit(this, ${originalIndex}, 'song')" title="Double-click to edit">${escapeHtml(song.song)}</td>
                    <td class="col-album editable-cell ${colClasses.album}" ondblclick="startInlineEdit(this, ${originalIndex}, 'album')" title="Double-click to edit">${escapeHtml(song.album || '-')}</td>
                    <td class="col-duration editable-cell ${colClasses.duration}" ondblclick="startInlineEdit(this, ${originalIndex}, 'duration')" title="Double-click to edit">${escapeHtml(song.duration || '-')}</td>
                    <td class="col-practiceStatus editable-cell ${colClasses.practiceStatus}" ondblclick="startInlineEdit(this, ${originalIndex}, 'practiceStatus')" title="Double-click to edit">${getPracticeStatusBadge(song.practiceStatus)}</td>
                    <td class="col-tuning editable-cell ${colClasses.tuning}" ondblclick="startInlineEdit(this, ${originalIndex}, 'tuning')" title="Double-click to edit">${escapeHtml(song.tuning || '-')}</td>
                    <td class="col-bands editable-cell ${colClasses.bands}" ondblclick="startInlineEdit(this, ${originalIndex}, 'bands')" title="Double-click to edit">${escapeHtml(song.bands || '-')}</td>
                    <td class="col-tags editable-cell ${colClasses.tags}" ondblclick="startInlineEdit(this, ${originalIndex}, 'tags')" title="Double-click to edit">${escapeHtml(song.tags || '-')}</td>
                    <td class="col-key editable-cell ${colClasses.key}" ondblclick="startInlineEdit(this, ${originalIndex}, 'key')" title="Double-click to edit">${escapeHtml(song.key || '-')}</td>
                    <td class="col-firstNote editable-cell ${colClasses.firstNote}" ondblclick="startInlineEdit(this, ${originalIndex}, 'firstNote')" title="Double-click to edit">${escapeHtml(song.firstNote || '-')}</td>
                    <td class="col-lastNote editable-cell ${colClasses.lastNote}" ondblclick="startInlineEdit(this, ${originalIndex}, 'lastNote')" title="Double-click to edit">${escapeHtml(song.lastNote || '-')}</td>
                    <td class="col-playCount ${colClasses.playCount}">${song.playCount || 0}</td>
                </tr>`);
            }
            
            tbody.innerHTML = rows.join('');
            updateBulkActionsBar();
        }

        // Update statistics (with memoization)
        function updateStats() {
            // Performance: Generate cache key from songs array
            const cacheKey = `${songs.length}-${songs.map(s => s.artist + s.bands).join(',')}`;
            
            // Return cached result if available
            if (statsCache && statsCacheKey === cacheKey) {
                document.getElementById('totalSongs').textContent = statsCache.totalSongs;
                document.getElementById('totalArtists').textContent = statsCache.totalArtists;
                document.getElementById('totalBands').textContent = statsCache.totalBands;
                if (document.querySelector('[data-stat="totalTags"]').style.display !== 'none') {
                    document.getElementById('totalTags').textContent = statsCache.totalTags;
                }
                if (document.querySelector('[data-stat="avgDuration"]').style.display !== 'none') {
                    document.getElementById('avgDuration').textContent = statsCache.avgDuration;
                }
                if (document.querySelector('[data-stat="mostPlayed"]').style.display !== 'none') {
                    document.getElementById('mostPlayed').textContent = statsCache.mostPlayed;
                }
                if (document.querySelector('[data-stat="readySongs"]').style.display !== 'none') {
                    document.getElementById('readySongs').textContent = statsCache.readySongs;
                }
                return;
            }
            
            // Calculate basic stats
            const totalSongs = songs.length;
            
            const uniqueArtists = new Set(songs.map(s => s.artist.toLowerCase()));
            const totalArtists = uniqueArtists.size;
            
            const uniqueBands = new Set();
            songs.forEach(s => {
                if (s.bands) {
                    s.bands.split(',').forEach(b => uniqueBands.add(b.trim().toLowerCase()));
                }
            });
            const totalBands = uniqueBands.size;
            
            // Calculate additional stats
            const uniqueTags = new Set();
            songs.forEach(s => {
                if (s.tags) {
                    s.tags.split(',').forEach(t => uniqueTags.add(t.trim().toLowerCase()));
                }
            });
            const totalTags = uniqueTags.size;
            
            // Calculate average duration
            let avgDuration = '-';
            const songsWithDuration = songs.filter(s => s.duration);
            if (songsWithDuration.length > 0) {
                const totalSeconds = songsWithDuration.reduce((sum, s) => {
                    const [min, sec] = s.duration.split(':').map(Number);
                    return sum + (min * 60) + (sec || 0);
                }, 0);
                const avgSeconds = Math.round(totalSeconds / songsWithDuration.length);
                const min = Math.floor(avgSeconds / 60);
                const sec = (avgSeconds % 60).toString().padStart(2, '0');
                avgDuration = `${min}:${sec}`;
            }
            
            // Find most played song
            let mostPlayed = '-';
            const maxPlays = Math.max(...songs.map(s => s.playCount || 0), 0);
            if (maxPlays > 0) {
                const topSong = songs.find(s => (s.playCount || 0) === maxPlays);
                if (topSong) {
                    mostPlayed = `${topSong.song} (${maxPlays}x)`;
                }
            }
            
            // Count ready/mastered songs
            const readySongs = songs.filter(s => s.practiceStatus === 'ready' || s.practiceStatus === 'mastered').length;
            
            // Cache the results
            statsCache = { totalSongs, totalArtists, totalBands, totalTags, avgDuration, mostPlayed, readySongs };
            statsCacheKey = cacheKey;
            
            // Update DOM
            document.getElementById('totalSongs').textContent = totalSongs;
            document.getElementById('totalArtists').textContent = totalArtists;
            document.getElementById('totalBands').textContent = totalBands;
            document.getElementById('totalTags').textContent = totalTags;
            document.getElementById('avgDuration').textContent = avgDuration;
            document.getElementById('mostPlayed').textContent = mostPlayed;
            document.getElementById('readySongs').textContent = readySongs;
        }
        
        // Performance: Invalidate stats cache when songs change
        function invalidateStatsCache() {
            statsCache = null;
            statsCacheKey = null;
        }

        // Stats Customizer Functions
        function toggleStatsCustomizer() {
            const panel = document.getElementById('statsCustomizer');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function toggleStat(statName) {
            const statCard = document.querySelector(`[data-stat="${statName}"]`);
            const checkbox = document.getElementById(`stat-${statName}`);
            
            if (checkbox.checked) {
                statCard.style.display = 'flex';
            } else {
                statCard.style.display = 'none';
            }
            
            // Save preference
            saveStatsPreferences();
        }

        function saveStatsPreferences() {
            const preferences = {
                totalSongs: document.getElementById('stat-totalSongs').checked,
                totalArtists: document.getElementById('stat-totalArtists').checked,
                totalBands: document.getElementById('stat-totalBands').checked,
                totalTags: document.getElementById('stat-totalTags').checked,
                avgDuration: document.getElementById('stat-avgDuration').checked,
                mostPlayed: document.getElementById('stat-mostPlayed').checked,
                readySongs: document.getElementById('stat-readySongs').checked
            };
            localStorage.setItem('statsPreferences', JSON.stringify(preferences));
        }

        function loadStatsPreferences() {
            const saved = localStorage.getItem('statsPreferences');
            if (!saved) return;
            
            try {
                const preferences = JSON.parse(saved);
                Object.keys(preferences).forEach(statName => {
                    const checkbox = document.getElementById(`stat-${statName}`);
                    const statCard = document.querySelector(`[data-stat="${statName}"]`);
                    if (checkbox && statCard) {
                        checkbox.checked = preferences[statName];
                        statCard.style.display = preferences[statName] ? 'flex' : 'none';
                    }
                });
            } catch (e) {
                console.error('Error loading stats preferences:', e);
            }
        }

        // Close stats customizer when clicking outside
        document.addEventListener('click', function(e) {
            const panel = document.getElementById('statsCustomizer');
            const btn = e.target.closest('button[onclick*="toggleStatsCustomizer"]');
            if (panel && panel.style.display !== 'none' && !panel.contains(e.target) && !btn) {
                panel.style.display = 'none';
            }
            
            // Close search help when clicking outside
            const helpPanel = document.getElementById('searchHelp');
            const helpBtn = e.target.closest('button[onclick*="toggleSearchHelp"]');
            if (helpPanel && helpPanel.style.display !== 'none' && !helpPanel.contains(e.target) && !helpBtn) {
                helpPanel.style.display = 'none';
            }
        });

        // Column Resizing
        let resizingColumn = null;
        let startX = 0;
        let startWidth = 0;
        const columnWidths = JSON.parse(localStorage.getItem('columnWidths') || '{}');

        function initColumnResizing() {
            const headers = document.querySelectorAll('#songTable th');
            headers.forEach((header, index) => {
                // Skip checkbox and actions columns
                if (header.classList.contains('col-checkbox') || header.classList.contains('col-actions')) {
                    return;
                }

                // Apply saved width if exists
                const columnClass = Array.from(header.classList).find(cls => cls.startsWith('col-'));
                if (columnClass && columnWidths[columnClass]) {
                    header.style.width = columnWidths[columnClass] + 'px';
                    header.style.minWidth = columnWidths[columnClass] + 'px';
                }

                // Create resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                header.appendChild(resizeHandle);

                resizeHandle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    resizingColumn = header;
                    startX = e.pageX;
                    startWidth = header.offsetWidth;
                    resizeHandle.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                });
            });

            document.addEventListener('mousemove', function(e) {
                if (!resizingColumn) return;

                const diff = e.pageX - startX;
                const newWidth = Math.max(50, startWidth + diff); // Minimum 50px
                resizingColumn.style.width = newWidth + 'px';
                resizingColumn.style.minWidth = newWidth + 'px';

                // Also update all cells in this column
                const columnClass = Array.from(resizingColumn.classList).find(cls => cls.startsWith('col-'));
                if (columnClass) {
                    const cells = document.querySelectorAll(`#songTable .${columnClass}`);
                    cells.forEach(cell => {
                        cell.style.width = newWidth + 'px';
                        cell.style.minWidth = newWidth + 'px';
                    });
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (!resizingColumn) return;

                // Save the new width
                const columnClass = Array.from(resizingColumn.classList).find(cls => cls.startsWith('col-'));
                if (columnClass) {
                    columnWidths[columnClass] = resizingColumn.offsetWidth;
                    localStorage.setItem('columnWidths', JSON.stringify(columnWidths));
                }

                // Clean up
                const handle = resizingColumn.querySelector('.resize-handle');
                if (handle) handle.classList.remove('resizing');
                resizingColumn = null;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            });
        }

        // Search Help Toggle
        function toggleSearchHelp() {
            const panel = document.getElementById('searchHelp');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        // Advanced Search Parser
        function parseAdvancedSearch(searchTerm) {
            // Handle empty search
            if (!searchTerm.trim()) return null;

            // Parse the search query into a structured format
            const tokens = [];
            let currentToken = '';
            let inQuotes = false;
            let inField = false;
            let fieldName = '';

            for (let i = 0; i < searchTerm.length; i++) {
                const char = searchTerm[i];
                const nextChar = searchTerm[i + 1];

                if (char === '"') {
                    inQuotes = !inQuotes;
                    currentToken += char;
                } else if (char === ':' && !inQuotes && currentToken) {
                    // Field specifier
                    fieldName = currentToken.toLowerCase();
                    currentToken = '';
                    inField = true;
                } else if (char === ' ' && !inQuotes) {
                    if (currentToken) {
                        const upperToken = currentToken.toUpperCase();
                        if (upperToken === 'AND' || upperToken === 'OR' || upperToken === 'NOT') {
                            tokens.push({ type: 'operator', value: upperToken });
                        } else {
                            tokens.push({
                                type: 'term',
                                value: currentToken,
                                field: fieldName || null,
                                negative: currentToken.startsWith('-')
                            });
                            fieldName = '';
                        }
                        currentToken = '';
                        inField = false;
                    }
                } else if (char === '(' || char === ')') {
                    if (currentToken) {
                        tokens.push({
                            type: 'term',
                            value: currentToken,
                            field: fieldName || null,
                            negative: currentToken.startsWith('-')
                        });
                        currentToken = '';
                        fieldName = '';
                    }
                    tokens.push({ type: char === '(' ? 'open' : 'close' });
                } else {
                    currentToken += char;
                }
            }

            // Add final token
            if (currentToken) {
                const upperToken = currentToken.toUpperCase();
                if (upperToken === 'AND' || upperToken === 'OR' || upperToken === 'NOT') {
                    tokens.push({ type: 'operator', value: upperToken });
                } else {
                    tokens.push({
                        type: 'term',
                        value: currentToken,
                        field: fieldName || null,
                        negative: currentToken.startsWith('-')
                    });
                }
            }

            return tokens;
        }

        // Evaluate advanced search against a song
        function evaluateAdvancedSearch(song, tokens) {
            if (!tokens || tokens.length === 0) return true;

            // Simple evaluation: process AND, OR, NOT operators
            let result = true;
            let currentOperator = 'AND'; // Default operator
            let pendingNot = false;

            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];

                if (token.type === 'operator') {
                    if (token.value === 'NOT') {
                        pendingNot = true;
                    } else {
                        currentOperator = token.value;
                    }
                } else if (token.type === 'term') {
                    let termValue = token.value.replace(/^-/, '').replace(/"/g, '').toLowerCase();
                    let matchFound = false;

                    // Field-specific search
                    if (token.field) {
                        const fieldValue = (song[token.field] || '').toLowerCase();
                        matchFound = fieldValue.includes(termValue);
                    } else {
                        // Search across all fields
                        matchFound =
                            song.artist.toLowerCase().includes(termValue) ||
                            song.song.toLowerCase().includes(termValue) ||
                            (song.album && song.album.toLowerCase().includes(termValue)) ||
                            (song.bands && song.bands.toLowerCase().includes(termValue)) ||
                            (song.key && song.key.toLowerCase().includes(termValue)) ||
                            (song.tuning && song.tuning.toLowerCase().includes(termValue)) ||
                            (song.tags && song.tags.toLowerCase().includes(termValue)) ||
                            (song.firstNote && song.firstNote.toLowerCase().includes(termValue)) ||
                            (song.lastNote && song.lastNote.toLowerCase().includes(termValue));
                    }

                    // Apply NOT/negative
                    if (token.negative || pendingNot) {
                        matchFound = !matchFound;
                        pendingNot = false;
                    }

                    // Apply operator
                    if (i === 0) {
                        result = matchFound;
                    } else if (currentOperator === 'AND') {
                        result = result && matchFound;
                    } else if (currentOperator === 'OR') {
                        result = result || matchFound;
                    }

                    // Reset to default AND for next term
                    if (i < tokens.length - 1 && tokens[i + 1].type !== 'operator') {
                        currentOperator = 'AND';
                    }
                }
            }

            return result;
        }

        // Inline Editing Functions
        let currentEditCell = null;

        function startInlineEdit(cell, index, field) {
            // Prevent multiple edits at once
            if (currentEditCell) {
                cancelInlineEdit();
            }

            currentEditCell = { cell, index, field };
            const song = songs[index];
            const currentValue = song[field] || '';

            // Store original content
            const originalContent = cell.innerHTML;
            cell.classList.add('editing');

            // Special handling for practiceStatus (dropdown)
            if (field === 'practiceStatus') {
                const select = document.createElement('select');
                select.className = 'inline-select';
                select.innerHTML = `
                    <option value="">-</option>
                    <option value="learning" ${currentValue === 'learning' ? 'selected' : ''}>🎓 Learning</option>
                    <option value="practicing" ${currentValue === 'practicing' ? 'selected' : ''}>🎵 Practicing</option>
                    <option value="ready" ${currentValue === 'ready' ? 'selected' : ''}>✓ Ready</option>
                    <option value="mastered" ${currentValue === 'mastered' ? 'selected' : ''}>⭐ Mastered</option>
                `;
                cell.innerHTML = '';
                cell.appendChild(select);
                select.focus();

                select.onchange = () => saveInlineEdit(select.value);
                select.onblur = () => setTimeout(() => cancelInlineEdit(), 200);
                select.onkeydown = (e) => {
                    if (e.key === 'Escape') cancelInlineEdit();
                    if (e.key === 'Enter') saveInlineEdit(select.value);
                };
            } else {
                // Regular text input
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'inline-input';
                input.value = currentValue === '-' ? '' : currentValue;
                cell.innerHTML = '';
                cell.appendChild(input);
                input.focus();
                input.select();

                input.onblur = () => setTimeout(() => saveInlineEdit(input.value), 200);
                input.onkeydown = (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelInlineEdit();
                    }
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveInlineEdit(input.value);
                    }
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        saveInlineEdit(input.value);
                        // Focus next editable cell
                        const nextCell = cell.nextElementSibling;
                        if (nextCell && nextCell.classList.contains('editable-cell')) {
                            setTimeout(() => startInlineEdit(nextCell, index, nextCell.className.match(/col-(\w+)/)[1]), 50);
                        }
                    }
                };
            }
        }

        function saveInlineEdit(newValue) {
            if (!currentEditCell) return;

            const { cell, index, field } = currentEditCell;
            const song = songs[index];
            const oldValue = song[field] || '';

            // Trim and clean the value
            newValue = newValue.trim();
            if (newValue === '-') newValue = '';

            // Only save if value changed
            if (newValue !== oldValue) {
                // Store for undo
                actionHistory.push({
                    type: 'edit',
                    index: index,
                    field: field,
                    oldValue: oldValue,
                    newValue: newValue
                });
                updateUndoButton();

                // Update song
                song[field] = newValue;
                saveSongs();
                invalidateStatsCache();
                invalidateFilterCache();
                
                // Show save indicator
                showSaveIndicator();
                showToast(`Updated ${field}`, 'success');
            }

            // Reset cell and re-render
            cell.classList.remove('editing');
            currentEditCell = null;
            
            // Re-render to show updated value
            applyFilters();
        }

        function cancelInlineEdit() {
            if (!currentEditCell) return;

            const { cell } = currentEditCell;
            cell.classList.remove('editing');
            currentEditCell = null;

            // Re-render to restore original content
            applyFilters();
        }

        // Open add modal
        function openAddModal() {
            editIndex = -1;
            document.getElementById('modalTitle').textContent = 'Add Song';
            document.getElementById('songForm').reset();
            document.getElementById('songModal').classList.add('active');
        }

        // Edit song
        function editSong(index) {
            editIndex = index;
            const song = songs[index];
            document.getElementById('modalTitle').textContent = 'Edit Song';
            document.getElementById('artist').value = song.artist;
            document.getElementById('song').value = song.song;
            document.getElementById('album').value = song.album || '';
            document.getElementById('link').value = song.link || '';
            document.getElementById('tuning').value = song.tuning || '';
            document.getElementById('bands').value = song.bands || '';
            document.getElementById('tags').value = song.tags || '';
            document.getElementById('duration').value = song.duration || '';
            document.getElementById('practiceStatus').value = song.practiceStatus || '';
            document.getElementById('key').value = song.key || '';
            document.getElementById('firstNote').value = song.firstNote || '';
            document.getElementById('lastNote').value = song.lastNote || '';
            document.getElementById('songModal').classList.add('active');
        }

        // Close modal
        function closeModal() {
            document.getElementById('songModal').classList.remove('active');
        }

        // Close import modal
        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
            importData = [];
        }

        // Handle form submission
        document.getElementById('songForm').onsubmit = function(e) {
            e.preventDefault();
            
            // Show loading state
            const saveBtn = document.getElementById('saveSongBtn');
            const saveBtnText = document.getElementById('saveBtnText');
            const saveBtnSpinner = document.getElementById('saveBtnSpinner');
            
            saveBtn.disabled = true;
            saveBtnText.style.display = 'none';
            saveBtnSpinner.style.display = 'inline';
            
            const songData = {
                artist: document.getElementById('artist').value.trim(),
                song: document.getElementById('song').value.trim(),
                album: document.getElementById('album').value.trim(),
                link: document.getElementById('link').value.trim(),
                tuning: document.getElementById('tuning').value.trim(),
                bands: document.getElementById('bands').value.trim(),
                tags: document.getElementById('tags').value.trim(),
                duration: document.getElementById('duration').value.trim(),
                practiceStatus: document.getElementById('practiceStatus').value,
                key: document.getElementById('key').value.trim(),
                firstNote: document.getElementById('firstNote').value.trim(),
                lastNote: document.getElementById('lastNote').value.trim(),
                playCount: editIndex >= 0 ? songs[editIndex].playCount || 0 : 0,
                lastPlayed: editIndex >= 0 ? songs[editIndex].lastPlayed : null,
                createdAt: editIndex >= 0 ? songs[editIndex].createdAt : new Date().toISOString()
            };

            // Check for duplicates before saving
            const similarSongs = findSimilarSongs(songData.artist, songData.song);
            
            showDuplicateWarning(similarSongs, (proceed) => {
                if (!proceed) {
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtnText.style.display = 'inline';
                    saveBtnSpinner.style.display = 'none';
                    return;
                }

            if (editIndex >= 0) {
                    saveUndoState('edit', { index: editIndex, oldSong: JSON.parse(JSON.stringify(songs[editIndex])) });
                songs[editIndex] = songData;
                    showToast('Song updated successfully', 'success');
            } else {
                    saveUndoState('add', {});
                songs.push(songData);
                    showToast('Song added successfully', 'success');
            }

            saveSongs();
            applyFilters();
            updateStats();
                
                // Reset button state
                saveBtn.disabled = false;
                saveBtnText.style.display = 'inline';
                saveBtnSpinner.style.display = 'none';
                
            closeModal();
            });
        };

        // Delete song
        function deleteSong(index) {
            const song = songs[index];
            if (confirm(`Move "${song.song}" by ${song.artist} to trash?`)) {
                // Save to undo history so user can recover if needed
                saveUndoState('delete', { index: index, song: JSON.parse(JSON.stringify(song)) });
                
                // Add to trash with timestamp
                trash.push({
                    song: JSON.parse(JSON.stringify(song)),
                    deletedAt: Date.now()
                });
                saveTrash();
                
                // Remove from songs
                songs.splice(index, 1);
                saveSongs();
                applyFilters();
                updateStats();
                showToast('Song moved to trash (2-day retention)', 'success');
            }
        }

        // Clear all data
        function clearAllData() {
            if (confirm('Are you sure you want to delete ALL songs? This cannot be undone!')) {
                saveUndoState('clearAll', { songs: JSON.parse(JSON.stringify(songs)) });
                songs = [];
                activeFilters = [];
                currentSort = { column: null, direction: 'asc' };
                saveSongs();
                updateFilterTags();
                applyFilters();
                updateStats();
                showToast('All songs cleared', 'warning');
            }
        }

        // ===== TRASH SYSTEM FUNCTIONS (Simple & Reliable) =====
        
        function loadTrash() {
            const stored = localStorage.getItem('songTrash');
            if (stored) {
                trash = JSON.parse(stored);
                cleanExpiredTrash();
            }
            updateTrashCount();
        }

        function saveTrash() {
            localStorage.setItem('songTrash', JSON.stringify(trash));
            updateTrashCount();
        }

        function cleanExpiredTrash() {
            const now = Date.now();
            const retentionMs = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000;
            const originalLength = trash.length;
            trash = trash.filter(item => (now - item.deletedAt) < retentionMs);
            if (trash.length < originalLength) {
                saveTrash();
                console.log(`Cleaned ${originalLength - trash.length} expired item(s) from trash`);
            }
        }

        function updateTrashCount() {
            document.getElementById('trashCount').textContent = trash.length;
        }

        function openTrashModal() {
            cleanExpiredTrash();
            renderTrashContent();
            document.getElementById('trashModal').classList.add('active');
        }

        function closeTrashModal() {
            document.getElementById('trashModal').classList.remove('active');
        }

        function renderTrashContent() {
            const container = document.getElementById('trashContent');
            
            if (trash.length === 0) {
                container.innerHTML = '<div class="no-data">Trash is empty</div>';
                return;
            }

            const now = Date.now();
            const html = trash.map((item, index) => {
                const song = item.song;
                const timeLeft = TRASH_RETENTION_DAYS * 24 * 60 * 60 * 1000 - (now - item.deletedAt);
                const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
                
                return `
                    <div style="background: var(--card-bg); border: 1px solid var(--primary-border); border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div>
                                <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); margin-bottom: 5px;">
                                    ${song.song || 'Untitled'}
                                </div>
                                <div style="color: var(--text-secondary); font-size: 14px; margin-bottom: 5px;">
                                    by ${song.artist || 'Unknown Artist'}
                                </div>
                                <div style="color: var(--text-tertiary); font-size: 12px;">
                                    ${hoursLeft > 0 ? `Expires in ${hoursLeft} hours` : 'Expires soon'}
                                </div>
                            </div>
                            <div>
                                <button class="btn-success btn-small" onclick="restoreFromTrash(${index})" style="margin-right: 5px;">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                                        <path d="M3 7v6h6"/>
                                        <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                                    </svg>
                                    Restore
                                </button>
                                <button class="btn-danger btn-small" onclick="deleteFromTrashPermanently(${index})">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                                        <line x1="18" y1="6" x2="6" y2="18"/>
                                        <line x1="6" y1="6" x2="18" y2="18"/>
                                    </svg>
                                    Delete Forever
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function restoreFromTrash(index) {
            const item = trash[index];
            if (!item || !item.song) {
                showToast('Invalid trash item', 'error');
                return;
            }

            const songName = item.song.song;
            const artistName = item.song.artist;
            
            // Check if already in songs (duplicate check)
            const alreadyExists = songs.find(s => s.song === songName && s.artist === artistName);
            if (alreadyExists) {
                console.warn('Song already exists in songs array!');
                // Just remove from trash and update
                trash.splice(index, 1);
                saveTrash();
                showToast(`⚠️ "${songName}" already in song list - removed from trash`, 'warning');
                setTimeout(() => location.reload(), 800);
                return;
            }

            // Create a deep copy - SAME AS UNDO
            const songCopy = JSON.parse(JSON.stringify(item.song));
            
            // Use splice like undo does - insert at end is fine
            songs.splice(songs.length, 0, songCopy);
            
            // Remove from trash
            trash.splice(index, 1);
            
            // Save - use the SAME functions as everywhere else
            saveSongs();
            saveTrash();
            
            // Show message and reload
            showToast(`✅ Restoring: ${songName} by ${artistName}`, 'success');
            
            setTimeout(() => {
                location.reload();
            }, 800);
        }

        function restoreAllFromTrash() {
            if (trash.length === 0) {
                showToast('Trash is empty', 'info');
                return;
            }

            const count = trash.length;
            
            // Restore all - check for duplicates
            let restored = 0;
            let skipped = 0;
            
            trash.forEach(item => {
                const alreadyExists = songs.find(s => 
                    s.song === item.song.song && s.artist === item.song.artist
                );
                
                if (!alreadyExists) {
                    songs.splice(songs.length, 0, JSON.parse(JSON.stringify(item.song)));
                    restored++;
                } else {
                    skipped++;
                }
            });

            // Clear trash
            trash = [];

            // Save using standard functions
            saveSongs();
            saveTrash();

            // Show message and reload
            const msg = skipped > 0 
                ? `✅ Restored ${restored}, skipped ${skipped} duplicate(s)`
                : `✅ Restored ${restored} song(s)`;
            showToast(msg, 'success');
            
            setTimeout(() => {
                location.reload();
            }, 800);
        }

        function deleteFromTrashPermanently(index) {
            const item = trash[index];
            if (confirm(`Permanently delete "${item.song.song}" by ${item.song.artist}? This cannot be undone!`)) {
                trash.splice(index, 1);
                saveTrash();
                renderTrashContent();
                showToast('Permanently deleted', 'warning');
            }
        }

        function emptyTrash() {
            if (trash.length === 0) {
                showToast('Trash is already empty', 'info');
                return;
            }
            if (confirm(`Permanently delete all ${trash.length} song(s) in trash? This cannot be undone!`)) {
                trash = [];
                saveTrash();
                renderTrashContent();
                showToast('Trash emptied', 'warning');
            }
        }

        // Sort table by column
        function sortTable(column) {
            // Toggle sort direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'asc';
            }

            // Update header classes
            document.querySelectorAll('.sortable').forEach(th => {
                th.classList.remove('asc', 'desc');
            });
            
            // Map column names to header text
            const columnMap = {
                'artist': 'artist',
                'song': 'song',
                'album': 'album',
                'tuning': 'tuning',
                'bands': 'bands',
                'key': 'key',
                'firstNote': 'firstnote',
                'lastNote': 'lastnote'
            };
            
            const activeHeader = Array.from(document.querySelectorAll('.sortable')).find(
                th => th.textContent.trim().toLowerCase().replace(/\s/g, '') === columnMap[column]
            );
            if (activeHeader) {
                activeHeader.classList.add(currentSort.direction);
            }

            applyFilters();
        }

        // Update filter suggestions based on selected column
        function updateFilterSuggestions() {
            const column = document.getElementById('filterColumn').value;
            const datalist = document.getElementById('filterSuggestions');
            const filterInput = document.getElementById('filterValue');
            
            if (!column) {
                datalist.innerHTML = '';
                filterInput.placeholder = 'Filter value...';
                return;
            }

            // Get songs filtered by OTHER columns (not the current one)
            // This gives cascading filter behavior
            let availableSongs = songs.map((song, index) => ({
                ...song,
                originalIndex: index
            }));

            // Apply existing filters for OTHER columns only
            const filtersByColumn = {};
            activeFilters.forEach(filter => {
                // Skip filters for the current column being edited
                if (filter.column !== column) {
                    if (!filtersByColumn[filter.column]) {
                        filtersByColumn[filter.column] = [];
                    }
                    filtersByColumn[filter.column].push(filter.value.toLowerCase());
                }
            });

            // Filter songs by other columns
            Object.keys(filtersByColumn).forEach(col => {
                const values = filtersByColumn[col];
                availableSongs = availableSongs.filter(song => {
                    const fieldValue = (song[col] || '').toLowerCase();
                    return values.some(value => {
                        if (value === '(empty)') {
                            return fieldValue === '';
                        }
                        return fieldValue === value;
                    });
                });
            });

            // Get unique values for the selected column from FILTERED songs
            const uniqueValues = new Set();
            let hasEmptyValues = false;
            
            availableSongs.forEach(song => {
                const value = song[column];
                if (value) {
                    // Handle bands/tags fields which might have comma-separated values
                    if ((column === 'bands' || column === 'tags') && value.includes(',')) {
                        value.split(',').forEach(item => {
                            const trimmed = item.trim();
                            if (trimmed) uniqueValues.add(trimmed);
                        });
                    } else {
                        uniqueValues.add(value);
                    }
                } else {
                    hasEmptyValues = true;
                }
            });

            // Sort values
            const sortedValues = Array.from(uniqueValues).sort((a, b) => 
                a.toLowerCase().localeCompare(b.toLowerCase())
            );
            
            // Add (empty) option at the beginning if there are songs with empty values
            if (hasEmptyValues) {
                sortedValues.unshift('(empty)');
            }

            // Populate datalist
            datalist.innerHTML = sortedValues.map(value => 
                `<option value="${escapeHtml(value)}"></option>`
            ).join('');

            const filterCount = activeFilters.length > 0 ? ` (${sortedValues.length} matching)` : '';
            filterInput.placeholder = `Select or type ${formatFieldName(column)}...${filterCount}`;
            filterInput.focus();
        }

        // Add filter
        function addFilter() {
            const column = document.getElementById('filterColumn').value;
            const value = document.getElementById('filterValue').value.trim();

            if (!column || !value) {
                showToast('Please select a column and enter a filter value', 'warning');
                return;
            }

            activeFilters.push({ column, value });
            document.getElementById('filterColumn').value = '';
            document.getElementById('filterValue').value = '';
            document.getElementById('filterSuggestions').innerHTML = '';
            
            updateFilterTags();
            applyFilters();
            showToast(`Filter added: ${formatFieldName(column)} = ${value}`, 'success', 2000);
        }

        // Remove filter
        function removeFilter(index) {
            activeFilters.splice(index, 1);
            updateFilterTags();
            applyFilters();
        }

        // Clear all filters
        function clearAllFilters() {
            activeFilters = [];
            document.getElementById('searchBox').value = '';
            document.getElementById('filterColumn').value = '';
            document.getElementById('filterValue').value = '';
            document.getElementById('filterSuggestions').innerHTML = '';
            updateFilterTags();
            applyFilters();
        }

        // Update filter tags display
        function updateFilterTags() {
            const container = document.getElementById('activeFilters');
            if (activeFilters.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = activeFilters.map((filter, index) => `
                <div class="filter-tag">
                    <strong>${formatFieldName(filter.column)}:</strong> ${escapeHtml(filter.value)}
                    <span class="filter-tag-remove" onclick="removeFilter(${index})">✕</span>
                </div>
            `).join('');
        }

        // Apply all filters and sorting
        function applyFilters() {
            // Create a cache key from current filter state
            const searchTerm = document.getElementById('searchBox').value.trim();
            const filterState = JSON.stringify({
                search: searchTerm,
                filters: activeFilters,
                sort: currentSort,
                songsLength: songs.length
            });
            
            // Return cached results if nothing changed
            if (lastFilterState === filterState && cachedFilteredSongs) {
                renderSongs(cachedFilteredSongs);
                return;
            }
            
            let filtered = songs.map((song, index) => ({
                ...song,
                originalIndex: index
            }));

            // Apply search filter with advanced operators (AND, OR, NOT, field:)
            if (searchTerm) {
                const searchTokens = parseAdvancedSearch(searchTerm);
                
                if (searchTokens && searchTokens.length > 0) {
                    // Use advanced search evaluation
                    filtered = filtered.filter(song => evaluateAdvancedSearch(song, searchTokens));
                } else {
                    // Fallback to simple search with multi-word support
                    const searchTerms = [];
                    const quoteRegex = /"([^"]*)"/g;
                    let remainingText = searchTerm;
                    let match;
                    
                    // Extract quoted phrases
                    while ((match = quoteRegex.exec(searchTerm)) !== null) {
                        searchTerms.push({ text: match[1].toLowerCase(), isPhrase: true });
                        remainingText = remainingText.replace(match[0], '');
                    }
                    
                    // Extract individual words from remaining text
                    const words = remainingText.trim().split(/\s+/).filter(w => w.length > 0);
                    words.forEach(word => {
                        searchTerms.push({ text: word.toLowerCase(), isPhrase: false });
                    });
                    
                    filtered = filtered.filter(song => {
                        // For each song, check if ALL search terms match
                        return searchTerms.every(term => {
                            const searchText = term.text;
                            const matchFound = 
                                song.artist.toLowerCase().includes(searchText) ||
                                song.song.toLowerCase().includes(searchText) ||
                                (song.album && song.album.toLowerCase().includes(searchText)) ||
                                (song.bands && song.bands.toLowerCase().includes(searchText)) ||
                                (song.key && song.key.toLowerCase().includes(searchText)) ||
                                (song.tuning && song.tuning.toLowerCase().includes(searchText)) ||
                                (song.firstNote && song.firstNote.toLowerCase().includes(searchText)) ||
                                (song.lastNote && song.lastNote.toLowerCase().includes(searchText));
                            
                            return matchFound;
                        });
                    });
                }
            }

            // Apply column filters
            // Group filters by column to handle multiple values per column with OR logic
            const filtersByColumn = {};
            activeFilters.forEach(filter => {
                if (!filtersByColumn[filter.column]) {
                    filtersByColumn[filter.column] = [];
                }
                filtersByColumn[filter.column].push(filter.value.toLowerCase());
            });
            
            // Apply each column's filters (OR within column, AND between columns)
            Object.keys(filtersByColumn).forEach(column => {
                const values = filtersByColumn[column];
                filtered = filtered.filter(song => {
                    const fieldValue = (song[column] || '').toLowerCase();
                    // Match if the field value equals ANY of the filter values for this column
                    return values.some(value => {
                        // Handle special "(empty)" filter
                        if (value === '(empty)') {
                            return fieldValue === '';
                        }
                        return fieldValue === value;
                    });
                });
            });

            // Apply sorting
            if (currentSort.column) {
                filtered.sort((a, b) => {
                    const aVal = (a[currentSort.column] || '').toLowerCase();
                    const bVal = (b[currentSort.column] || '').toLowerCase();
                    
                    if (aVal < bVal) return currentSort.direction === 'asc' ? -1 : 1;
                    if (aVal > bVal) return currentSort.direction === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Cache the results
            lastFilterState = filterState;
            cachedFilteredSongs = filtered;

            // Calculate unique artists and bands from filtered results
            const uniqueArtists = new Set(filtered.map(s => s.artist)).size;
            const uniqueBands = new Set(
                filtered.flatMap(s => s.bands ? s.bands.split(',').map(b => b.trim()) : [])
            ).size;

            // Update search results display
            const searchResultsEl = document.getElementById('searchResults');
            const artistResultsEl = document.getElementById('artistResults');
            const bandResultsEl = document.getElementById('bandResults');
            
            if (searchTerm || activeFilters.length > 0) {
                searchResultsEl.textContent = `${filtered.length} found`;
                searchResultsEl.style.display = 'block';
                
                artistResultsEl.textContent = `${uniqueArtists} found`;
                artistResultsEl.style.display = 'block';
                
                bandResultsEl.textContent = `${uniqueBands} found`;
                bandResultsEl.style.display = 'block';
            } else {
                searchResultsEl.style.display = 'none';
                artistResultsEl.style.display = 'none';
                bandResultsEl.style.display = 'none';
            }

            renderSongs(filtered);
        }

        // Debounced version of applyFilters (300ms delay)
        function debouncedApplyFilters() {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                applyFilters();
            }, 300);
        }

        // Smart Autocomplete Functions
        function handleSearchInput(event) {
            const input = event.target.value;
            
            // Debounce the filter application
            debouncedApplyFilters();
            
            // Show autocomplete suggestions
            if (input.trim().length >= 2) {
                showAutocompleteSuggestions(input.trim());
            } else {
                hideAutocomplete();
            }
        }

        function showAutocompleteSuggestions(searchText) {
            const suggestions = generateSuggestions(searchText);
            
            if (suggestions.length === 0) {
                hideAutocomplete();
                return;
            }
            
            autocompleteSuggestions = suggestions;
            autocompleteSelectedIndex = -1;
            
            const dropdown = document.getElementById('autocompleteDropdown');
            dropdown.innerHTML = suggestions.map((suggestion, index) => `
                <div class="autocomplete-item" data-index="${index}" onclick="selectSuggestion(${index})">
                    <span class="autocomplete-type">${suggestion.type}</span>
                    <span class="autocomplete-text">${escapeHtml(suggestion.text)}</span>
                    <span class="autocomplete-count">${suggestion.count} song${suggestion.count !== 1 ? 's' : ''}</span>
                </div>
            `).join('');
            
            dropdown.style.display = 'block';
        }

        function generateSuggestions(searchText) {
            const lowerSearch = searchText.toLowerCase();
            const suggestions = [];
            const seenValues = new Set();
            const MAX_SUGGESTIONS = 10;
            
            // Helper to add unique suggestions
            function addSuggestion(type, text, matchingCount) {
                const key = `${type}:${text}`;
                if (!seenValues.has(key) && text.toLowerCase().includes(lowerSearch)) {
                    seenValues.add(key);
                    suggestions.push({ type, text, count: matchingCount });
                }
            }
            
            // Count matches for each category
            const artistMatches = new Map();
            const songMatches = new Map();
            const albumMatches = new Map();
            const tagMatches = new Map();
            
            songs.forEach(song => {
                if (song.artist && song.artist.toLowerCase().includes(lowerSearch)) {
                    artistMatches.set(song.artist, (artistMatches.get(song.artist) || 0) + 1);
                }
                if (song.song && song.song.toLowerCase().includes(lowerSearch)) {
                    songMatches.set(song.song, (songMatches.get(song.song) || 0) + 1);
                }
                if (song.album && song.album.toLowerCase().includes(lowerSearch)) {
                    albumMatches.set(song.album, (albumMatches.get(song.album) || 0) + 1);
                }
                if (song.tags) {
                    const tags = song.tags.split(',').map(t => t.trim());
                    tags.forEach(tag => {
                        if (tag.toLowerCase().includes(lowerSearch)) {
                            tagMatches.set(tag, (tagMatches.get(tag) || 0) + 1);
                        }
                    });
                }
            });
            
            // Add artist suggestions (top 3)
            Array.from(artistMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .forEach(([artist, count]) => addSuggestion('Artist', artist, count));
            
            // Add song suggestions (top 3)
            Array.from(songMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .forEach(([song, count]) => addSuggestion('Song', song, count));
            
            // Add album suggestions (top 2)
            Array.from(albumMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2)
                .forEach(([album, count]) => addSuggestion('Album', album, count));
            
            // Add tag suggestions (top 2)
            Array.from(tagMatches.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2)
                .forEach(([tag, count]) => addSuggestion('Tag', tag, count));
            
            return suggestions.slice(0, MAX_SUGGESTIONS);
        }

        function selectSuggestion(index) {
            if (index >= 0 && index < autocompleteSuggestions.length) {
                const suggestion = autocompleteSuggestions[index];
                document.getElementById('searchBox').value = suggestion.text;
                searchTerm = suggestion.text;
                hideAutocomplete();
                applyFilters();
            }
        }

        function handleSearchKeydown(event) {
            const dropdown = document.getElementById('autocompleteDropdown');
            
            if (dropdown.style.display === 'none') return;
            
            const items = dropdown.querySelectorAll('.autocomplete-item');
            
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                autocompleteSelectedIndex = Math.min(autocompleteSelectedIndex + 1, items.length - 1);
                updateAutocompleteSelection(items);
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                autocompleteSelectedIndex = Math.max(autocompleteSelectedIndex - 1, -1);
                updateAutocompleteSelection(items);
            } else if (event.key === 'Enter') {
                event.preventDefault();
                if (autocompleteSelectedIndex >= 0) {
                    selectSuggestion(autocompleteSelectedIndex);
                } else {
                    hideAutocomplete();
                }
            } else if (event.key === 'Escape') {
                hideAutocomplete();
            }
        }

        function updateAutocompleteSelection(items) {
            items.forEach((item, index) => {
                if (index === autocompleteSelectedIndex) {
                    item.classList.add('selected');
                    item.scrollIntoView({ block: 'nearest' });
                } else {
                    item.classList.remove('selected');
                }
            });
        }

        function hideAutocomplete() {
            document.getElementById('autocompleteDropdown').style.display = 'none';
            autocompleteSelectedIndex = -1;
        }

        // Close autocomplete when clicking outside
        document.addEventListener('click', function(event) {
            const searchBox = document.getElementById('searchBox');
            const dropdown = document.getElementById('autocompleteDropdown');
            
            if (searchBox && dropdown && 
                !searchBox.contains(event.target) && 
                !dropdown.contains(event.target)) {
                hideAutocomplete();
            }
        });

        // Handle CSV import
        function handleCSVImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const csv = e.target.result;
                parseCSV(csv);
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Parse CSV
        function parseCSV(csv) {
            const lines = csv.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                showToast('CSV file is empty or invalid!', 'error');
                return;
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const fieldMap = {
                'artist': 'artist',
                'album': 'album',
                'song': 'song',
                'link': 'link',
                'tuning': 'tuning',
                'bands': 'bands',
                'key': 'key',
                'first note': 'firstNote',
                'firstnote': 'firstNote',
                'last note': 'lastNote',
                'lastnote': 'lastNote'
            };

            const headerIndexMap = {};
            headers.forEach((header, index) => {
                const mappedField = fieldMap[header];
                if (mappedField) {
                    headerIndexMap[mappedField] = index;
                }
            });

            if (headerIndexMap.artist === undefined || headerIndexMap.song === undefined) {
                showToast('CSV must have "Artist" and "Song" columns!', 'error');
                return;
            }

            importData = [];
            const csvSongs = [];
            
            // First pass: collect all songs from CSV
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length === 0) continue;

                const newSong = {
                    artist: values[headerIndexMap.artist]?.trim() || '',
                    song: values[headerIndexMap.song]?.trim() || '',
                    album: values[headerIndexMap.album]?.trim() || '',
                    link: values[headerIndexMap.link]?.trim() || '',
                    tuning: values[headerIndexMap.tuning]?.trim() || '',
                    bands: values[headerIndexMap.bands]?.trim() || '',
                    key: values[headerIndexMap.key]?.trim() || '',
                    firstNote: values[headerIndexMap.firstNote]?.trim() || '',
                    lastNote: values[headerIndexMap.lastNote]?.trim() || '',
                    csvLineNumber: i + 1
                };

                if (!newSong.artist || !newSong.song) continue;
                csvSongs.push(newSong);
            }

            // Second pass: process songs and detect duplicates
            const processedKeys = new Set();
            
            for (let csvSong of csvSongs) {
                const key = `${csvSong.artist.toLowerCase()}|||${csvSong.song.toLowerCase()}`;
                
                // Check for duplicate within CSV file
                const csvDuplicates = csvSongs.filter(s => 
                    s.artist.toLowerCase() === csvSong.artist.toLowerCase() &&
                    s.song.toLowerCase() === csvSong.song.toLowerCase()
                );
                
                if (csvDuplicates.length > 1 && !processedKeys.has(key)) {
                    // Multiple entries in CSV for same song
                    processedKeys.add(key);
                    importData.push({
                        type: 'csv-duplicate',
                        duplicates: csvDuplicates,
                        selected: 0, // Index of selected duplicate
                        artist: csvSong.artist,
                        songName: csvSong.song
                    });
                } else if (csvDuplicates.length === 1) {
                    // Single entry in CSV, check against existing songs
                    const existingIndex = songs.findIndex(s => 
                        s.artist.toLowerCase() === csvSong.artist.toLowerCase() &&
                        s.song.toLowerCase() === csvSong.song.toLowerCase()
                    );

                    if (existingIndex >= 0) {
                        const changes = getChanges(songs[existingIndex], csvSong);
                        if (changes.length > 0) {
                            importData.push({
                                type: 'update',
                                index: existingIndex,
                                oldSong: songs[existingIndex],
                                newSong: csvSong,
                                changes: changes,
                                selected: true
                            });
                        }
                    } else {
                        importData.push({
                            type: 'new',
                            newSong: csvSong,
                            selected: true
                        });
                    }
                }
            }

            if (importData.length === 0) {
                showToast('No changes detected in CSV file!', 'info');
                return;
            }

            showImportPreview();
        }

        // Parse CSV line handling quoted values
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);

            return values.map(v => v.trim().replace(/^"|"$/g, ''));
        }

        // Get changes between old and new song
        function getChanges(oldSong, newSong) {
            const changes = [];
            const fields = ['artist', 'song', 'album', 'link', 'tuning', 'bands', 'key', 'firstNote', 'lastNote'];
            
            fields.forEach(field => {
                const oldVal = oldSong[field] || '';
                const newVal = newSong[field] || '';
                if (oldVal !== newVal) {
                    changes.push({
                        field: field,
                        oldValue: oldVal,
                        newValue: newVal
                    });
                }
            });

            return changes;
        }

        // Show import preview
        function showImportPreview() {
            const preview = document.getElementById('importPreview');
            
            // Sort import data by bands, album, then song
            const sortedData = [...importData].map((item, originalIndex) => ({
                ...item,
                originalIndex: originalIndex
            })).sort((a, b) => {
                const getSongData = (item) => {
                    if (item.type === 'csv-duplicate') {
                        return item.duplicates[item.selected];
                    }
                    return item.newSong;
                };
                
                const songA = getSongData(a);
                const songB = getSongData(b);
                
                const bandsA = (songA.bands || '').toLowerCase();
                const bandsB = (songB.bands || '').toLowerCase();
                if (bandsA !== bandsB) return bandsA.localeCompare(bandsB);
                
                const albumA = (songA.album || '').toLowerCase();
                const albumB = (songB.album || '').toLowerCase();
                if (albumA !== albumB) return albumA.localeCompare(albumB);
                
                const nameA = (songA.song || '').toLowerCase();
                const nameB = (songB.song || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            const duplicateCount = importData.filter(i => i.type === 'csv-duplicate').length;
            
            preview.innerHTML = `
                <div style="margin-bottom: 15px; color: #d84315;">
                    <strong>${importData.filter(i => i.type === 'new').length}</strong> new songs, 
                    <strong>${importData.filter(i => i.type === 'update').length}</strong> updates
                    ${duplicateCount > 0 ? `, <strong style="color: #f59e0b;">${duplicateCount}</strong> duplicates in CSV` : ''}
                </div>
                <table style="width: 100%;">
                    <thead>
                        <tr>
                            <th style="width: 40px; text-align: center;">✓</th>
                            <th style="width: 60px;">Status</th>
                            <th>Band</th>
                            <th>Artist</th>
                            <th>Song</th>
                            <th>Album</th>
                            <th>Key</th>
                            <th>Changes</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedData.map((item) => {
                            if (item.type === 'csv-duplicate') {
                                // Special handling for CSV duplicates
                                const statusBadge = '<span style="background: #f59e0b; padding: 4px 8px; border-radius: 4px; font-size: 12px;">⚠️ DUPLICATE</span>';
                                const selectedDup = item.duplicates[item.selected];
                                
                                const duplicateOptions = `
                                    <div style="font-size: 12px;">
                                        <strong style="color: #f59e0b;">Found ${item.duplicates.length} entries in CSV for this song. Select which to import:</strong>
                                        ${item.duplicates.map((dup, dupIndex) => `
                                            <div style="margin: 8px 0; padding: 8px; background: ${dupIndex === item.selected ? 'rgba(216, 67, 21, 0.2)' : 'rgba(50, 50, 50, 0.3)'}; border-radius: 4px; border: ${dupIndex === item.selected ? '2px solid #d84315' : '1px solid #444'};">
                                                <label style="cursor: pointer; display: block;">
                                                    <input type="radio" name="duplicate_${item.originalIndex}" value="${dupIndex}" 
                                                           ${dupIndex === item.selected ? 'checked' : ''} 
                                                           onchange="selectDuplicate(${item.originalIndex}, ${dupIndex})"
                                                           style="margin-right: 8px;">
                                                    CSV Line ${dup.csvLineNumber}:
                                                    <div style="margin-left: 24px; margin-top: 4px;">
                                                        ${dup.album ? `<span style="color: #aaa;">Album: ${escapeHtml(dup.album)}</span><br>` : ''}
                                                        ${dup.bands ? `<span style="color: #aaa;">Bands: ${escapeHtml(dup.bands)}</span><br>` : ''}
                                                        ${dup.key ? `<span style="color: #aaa;">Key: ${escapeHtml(dup.key)}</span>` : ''}
                                                        ${dup.tuning ? ` | Tuning: ${escapeHtml(dup.tuning)}` : ''}
                                                        ${dup.link ? ` | <a href="${escapeHtml(dup.link)}" target="_blank" class="link-icon">🔗</a>` : ''}
                                                    </div>
                                                </label>
                                            </div>
                                        `).join('')}
                                    </div>
                                `;
                                
                                return `
                                    <tr style="border-bottom: 1px solid rgba(216, 67, 21, 0.1); background: rgba(245, 158, 11, 0.05);">
                                        <td style="text-align: center; padding: 8px;">
                                            <input type="checkbox" id="import_${item.originalIndex}" 
                                                   checked
                                                   onchange="toggleImportItem(${item.originalIndex})"
                                                   style="width: 18px; height: 18px; cursor: pointer;">
                                        </td>
                                        <td style="padding: 8px;">${statusBadge}</td>
                                        <td style="padding: 8px;">${escapeHtml(selectedDup.bands || '-')}</td>
                                        <td style="padding: 8px;">${escapeHtml(item.artist)}</td>
                                        <td style="padding: 8px; font-weight: 600;">${escapeHtml(item.songName)}</td>
                                        <td style="padding: 8px;">${escapeHtml(selectedDup.album || '-')}</td>
                                        <td style="padding: 8px;">${escapeHtml(selectedDup.key || '-')}</td>
                                        <td style="padding: 8px;" colspan="1">${duplicateOptions}</td>
                                    </tr>
                                `;
                            }
                            
                            const isUpdate = item.type === 'update';
                            const statusBadge = isUpdate 
                                ? '<span style="background: #f59e0b; padding: 4px 8px; border-radius: 4px; font-size: 12px;">🔄 UPDATE</span>'
                                : '<span style="background: #10b981; padding: 4px 8px; border-radius: 4px; font-size: 12px;">✨ NEW</span>';
                            
                            const changesHtml = isUpdate ? `
                                <div style="font-size: 12px;">
                                    ${item.changes.map(change => `
                                        <div style="margin: 2px 0;">
                                            <strong>${formatFieldName(change.field)}:</strong>
                                            ${change.oldValue ? `<span class="change-old">${escapeHtml(change.oldValue)}</span> → ` : ''}
                                            <span class="change-new">${escapeHtml(change.newValue)}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : '-';
                            
                            return `
                                <tr style="border-bottom: 1px solid rgba(216, 67, 21, 0.1);">
                                    <td style="text-align: center; padding: 8px;">
                                        <input type="checkbox" id="import_${item.originalIndex}" 
                                               ${item.selected ? 'checked' : ''} 
                                               onchange="toggleImportItem(${item.originalIndex})"
                                               style="width: 18px; height: 18px; cursor: pointer;">
                                    </td>
                                    <td style="padding: 8px;">${statusBadge}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.bands || '-')}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.artist)}</td>
                                    <td style="padding: 8px; font-weight: 600;">${escapeHtml(item.newSong.song)}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.album || '-')}</td>
                                    <td style="padding: 8px;">${escapeHtml(item.newSong.key || '-')}</td>
                                    <td style="padding: 8px;">${changesHtml}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            document.getElementById('importModal').classList.add('active');
        }

        // Toggle import item selection
        function toggleImportItem(index) {
            importData[index].selected = document.getElementById(`import_${index}`).checked;
        }

        // Select which duplicate to import
        function selectDuplicate(importIndex, duplicateIndex) {
            importData[importIndex].selected = duplicateIndex;
            // Refresh the preview to show the new selection
            showImportPreview();
        }

        // Confirm import
        function confirmImport() {
            const selectedItems = importData.filter(item => item.selected !== false && item.selected !== undefined);
            if (selectedItems.length === 0) {
                showToast('No items selected for import!', 'warning');
                return;
            }

            selectedItems.forEach(item => {
                if (item.type === 'csv-duplicate') {
                    // Import the selected duplicate
                    const selectedSong = item.duplicates[item.selected];
                    const existingIndex = songs.findIndex(s => 
                        s.artist.toLowerCase() === selectedSong.artist.toLowerCase() &&
                        s.song.toLowerCase() === selectedSong.song.toLowerCase()
                    );
                    
                    if (existingIndex >= 0) {
                        songs[existingIndex] = selectedSong;
                    } else {
                        songs.push(selectedSong);
                    }
                } else if (item.type === 'update') {
                    songs[item.index] = item.newSong;
                } else if (item.type === 'new') {
                    songs.push(item.newSong);
                }
            });

            saveSongs();
            applyFilters();
            updateStats();
            closeImportModal();
            
            // Save undo state for import
            saveUndoState('import', { count: selectedItems.length });
            showToast(`Successfully imported ${selectedItems.length} song(s)!`, 'success');
        }

        // Export to CSV
        function exportCSV() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            const headers = ['Artist', 'Song', 'Album', 'Link', 'Tuning', 'Bands', 'Key', 'First Note', 'Last Note'];
            const csv = [headers.join(',')];

            songs.forEach(song => {
                const row = [
                    escapeCSV(song.artist),
                    escapeCSV(song.song),
                    escapeCSV(song.album || ''),
                    escapeCSV(song.link || ''),
                    escapeCSV(song.tuning || ''),
                    escapeCSV(song.bands || ''),
                    escapeCSV(song.key || ''),
                    escapeCSV(song.firstNote || ''),
                    escapeCSV(song.lastNote || '')
                ];
                csv.push(row.join(','));
            });

            const blob = new Blob([csv.join('\n')], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `band-songs-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
            showToast(`Exported ${songs.length} songs to CSV`, 'success');
        }

        // Toggle export menu
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }

        // Close export menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('exportMenu');
            const btn = document.getElementById('exportMenuBtn');
            if (menu && btn && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });

        // Export as JSON
        function exportJSON() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                totalSongs: songs.length,
                songs: songs.map(song => ({
                    artist: song.artist,
                    song: song.song,
                    album: song.album || '',
                    link: song.link || '',
                    tuning: song.tuning || '',
                    bands: song.bands || '',
                    tags: song.tags || '',
                    key: song.key || '',
                    firstNote: song.firstNote || '',
                    lastNote: song.lastNote || '',
                    duration: song.duration || '',
                    practiceStatus: song.practiceStatus || '',
                    playCount: song.playCount || 0,
                    lastPlayed: song.lastPlayed || null
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `band-songs-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            window.URL.revokeObjectURL(url);
            showToast('JSON exported successfully!', 'success');
        }

        // Export as Excel (XLSX) - using HTML table method
        function exportExcel() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            // Create HTML table
            let html = '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">';
            html += '<head><meta charset="utf-8"><style>table { border-collapse: collapse; } th, td { border: 1px solid #ddd; padding: 8px; } th { background-color: #4CAF50; color: white; }</style></head>';
            html += '<body><table>';
            
            // Headers
            html += '<tr><th>Artist</th><th>Song</th><th>Album</th><th>Link</th><th>Tuning</th><th>Bands</th><th>Tags</th><th>Key</th><th>First Note</th><th>Last Note</th><th>Duration</th><th>Practice Status</th></tr>';
            
            // Data rows
            songs.forEach(song => {
                html += '<tr>';
                html += `<td>${escapeHtml(song.artist)}</td>`;
                html += `<td>${escapeHtml(song.song)}</td>`;
                html += `<td>${escapeHtml(song.album || '')}</td>`;
                html += `<td>${escapeHtml(song.link || '')}</td>`;
                html += `<td>${escapeHtml(song.tuning || '')}</td>`;
                html += `<td>${escapeHtml(song.bands || '')}</td>`;
                html += `<td>${escapeHtml(song.tags || '')}</td>`;
                html += `<td>${escapeHtml(song.key || '')}</td>`;
                html += `<td>${escapeHtml(song.firstNote || '')}</td>`;
                html += `<td>${escapeHtml(song.lastNote || '')}</td>`;
                html += `<td>${escapeHtml(song.duration || '')}</td>`;
                html += `<td>${escapeHtml(song.practiceStatus || '')}</td>`;
                html += '</tr>';
            });
            
            html += '</table></body></html>';

            const blob = new Blob([html], { type: 'application/vnd.ms-excel' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `band-songs-${new Date().toISOString().split('T')[0]}.xls`;
            a.click();
            window.URL.revokeObjectURL(url);
            showToast('Excel file exported successfully!', 'success');
        }

        // Export as PDF
        function exportPDF() {
            if (songs.length === 0) {
                showToast('No songs to export!', 'warning');
                return;
            }

            // Create a printable HTML page
            const printWindow = window.open('', '_blank');
            let html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Band Songs - ${new Date().toLocaleDateString()}</title>
    <style>
        @page { size: landscape; margin: 0.5in; }
        body { font-family: Arial, sans-serif; font-size: 10pt; }
        h1 { text-align: center; color: #333; margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 6px; text-align: left; }
        th { background-color: #4CAF50; color: white; font-weight: bold; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .footer { text-align: center; margin-top: 20px; font-size: 9pt; color: #666; }
    <\/style>
<\/head>
<body>
    <h1>🎸 Band Song Database</h1>
    <p><strong>Export Date:</strong> ${new Date().toLocaleString()}</p>
    <p><strong>Total Songs:</strong> ${songs.length}</p>
    <table>
        <thead>
            <tr>
                <th>#</th>
                <th>Artist</th>
                <th>Song</th>
                <th>Album</th>
                <th>Tuning</th>
                <th>Key</th>
                <th>Duration</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody>
`;

            songs.forEach((song, index) => {
                html += `
            <tr>
                <td>${index + 1}</td>
                <td>${escapeHtml(song.artist)}</td>
                <td>${escapeHtml(song.song)}</td>
                <td>${escapeHtml(song.album || '-')}</td>
                <td>${escapeHtml(song.tuning || '-')}</td>
                <td>${escapeHtml(song.key || '-')}</td>
                <td>${escapeHtml(song.duration || '-')}</td>
                <td>${escapeHtml(song.practiceStatus || '-')}</td>
            </tr>
`;
            });

            html += `
        </tbody>
    </table>
    <div class="footer">
        <p>Generated by Band Practice Manager • \${songs.length} songs</p>
    </div>
    <script>
        window.onload = function() {
            window.print();
            // Close after printing (optional)
            // setTimeout(() => window.close(), 1000);
        };
    <\/script>
<\/body>
<\/html>
`;

            printWindow.document.write(html);
            printWindow.document.close();
            showToast('PDF print dialog opened!', 'success');
        }

        // Escape CSV value
        function escapeCSV(value) {
            if (!value) return '';
            const str = String(value);
            if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                return `"${str.replace(/"/g, '""')}"`;
            }
            return str;
        }

        // Escape HTML
        // Escape HTML for display (optimized version)
        const escapeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        
        function escapeHtml(text) {
            if (!text) return '';
            return String(text).replace(/[&<>"']/g, function(char) {
                return escapeMap[char];
            });
        }

        // Format field name for display
        function formatFieldName(field) {
            const map = {
                'artist': 'Artist',
                'song': 'Song',
                'album': 'Album',
                'link': 'Link',
                'tuning': 'Tuning',
                'bands': 'Bands',
                'key': 'Key',
                'firstNote': 'First Note',
                'lastNote': 'Last Note'
            };
            return map[field] || field;
        }
        
        // ============================================================================
        // PERFORMANCE MONITORING (Admin Page)
        // ============================================================================
        
        function openPerformanceMonitor() {
            const modal = document.getElementById('perfMonitorModal');
            modal.classList.add('active');
            updatePerformanceMetrics();
            
            // Start live monitoring
            window.perfMonitorInterval = setInterval(updatePerformanceMetrics, 1000);
        }
        
        function closePerformanceMonitor() {
            const modal = document.getElementById('perfMonitorModal');
            modal.classList.remove('active');
            
            // Stop live monitoring
            if (window.perfMonitorInterval) {
                clearInterval(window.perfMonitorInterval);
                window.perfMonitorInterval = null;
            }
        }
        
        function updatePerformanceMetrics() {
            const perf = performance;
            const navigation = perf.getEntriesByType('navigation')[0];
            const paint = perf.getEntriesByType('paint');
            
            // Navigation Timing
            if (navigation) {
                document.getElementById('loadTime').textContent = 
                    `${(navigation.loadEventEnd - navigation.fetchStart).toFixed(2)} ms`;
                document.getElementById('domReady').textContent = 
                    `${(navigation.domContentLoadedEventEnd - navigation.fetchStart).toFixed(2)} ms`;
            }
            
            // Paint Timing
            const fcp = paint.find(entry => entry.name === 'first-contentful-paint');
            if (fcp) {
                document.getElementById('fcp').textContent = `${fcp.startTime.toFixed(2)} ms`;
            }
            
            // Memory (if available)
            if (performance.memory) {
                const usedMemory = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                const totalMemory = (performance.memory.totalJSHeapSize / 1048576).toFixed(2);
                document.getElementById('memory').textContent = `${usedMemory} / ${totalMemory} MB`;
            } else {
                document.getElementById('memory').textContent = 'N/A (not supported)';
            }
            
            // LocalStorage Size
            let storageSize = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    storageSize += localStorage[key].length + key.length;
                }
            }
            document.getElementById('storageSize').textContent = 
                `${(storageSize / 1024).toFixed(2)} KB`;
            
            // DOM Stats
            document.getElementById('domNodes').textContent = 
                document.querySelectorAll('*').length;
            document.getElementById('tableRows').textContent = 
                document.querySelectorAll('#songTableBody tr').length;
            
            // Song Stats
            document.getElementById('totalSongsPerf').textContent = songs.length;
            document.getElementById('filterCacheStatus').textContent = 
                cachedFilteredSongs ? 'Active' : 'Empty';
            document.getElementById('statsCacheStatus').textContent = 
                statsCache ? 'Active' : 'Empty';
        }
        
        function logSlowOperations() {
            const originalConsoleLog = console.log;
            const threshold = 100; // ms
            
            // Wrap expensive functions to log if they take > 100ms
            const functionsToMonitor = ['renderSongs', 'applyFilters', 'updateStats'];
            
            functionsToMonitor.forEach(funcName => {
                const originalFunc = window[funcName];
                if (originalFunc) {
                    window[funcName] = function(...args) {
                        const start = performance.now();
                        const result = originalFunc.apply(this, args);
                        const duration = performance.now() - start;
                        
                        if (duration > threshold) {
                            console.warn(`⚠️ SLOW: ${funcName}() took ${duration.toFixed(2)}ms`);
                        }
                        
                        return result;
                    };
                }
            });
            
            console.log('✅ Performance monitoring enabled - slow operations (>100ms) will be logged');
        }
    </script>
    
    <!-- Stats Customizer Panel -->
    <div id="statsCustomizer" style="display: none; position: absolute; top: 60px; left: 20px; background: var(--primary-dark); border: 2px solid var(--primary-border); border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); z-index: 1000; min-width: 250px;">
        <h3 style="color: var(--primary-light); margin: 0 0 10px 0; font-size: 0.95em; display: flex; align-items: center; gap: 8px;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="flex-shrink: 0;">
                <line x1="18" y1="20" x2="18" y2="10"/>
                <line x1="12" y1="20" x2="12" y2="4"/>
                <line x1="6" y1="20" x2="6" y2="14"/>
            </svg>
            Customize Stats
        </h3>
        <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalSongs" checked onchange="toggleStat('totalSongs')">
                <span>Total Songs</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalArtists" checked onchange="toggleStat('totalArtists')">
                <span>Artists</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalBands" checked onchange="toggleStat('totalBands')">
                <span>Bands</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-totalTags" onchange="toggleStat('totalTags')">
                <span>Tags</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-avgDuration" onchange="toggleStat('avgDuration')">
                <span>Avg Duration</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-mostPlayed" onchange="toggleStat('mostPlayed')">
                <span>Most Played</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                <input type="checkbox" id="stat-readySongs" onchange="toggleStat('readySongs')">
                <span>Ready Songs</span>
            </label>
        </div>
        <button class="btn-secondary" onclick="toggleStatsCustomizer()" style="width: 100%; margin-top: 10px; font-size: 0.85em;">Close</button>
    </div>
    
    <!-- Progress Indicator Modal -->
    <div id="progressModal" class="modal" style="z-index: 10000;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 id="progressTitle">Processing...</h2>
            </div>
            <div style="padding: 20px;">
                <div id="progressMessage" style="color: #ccc; margin-bottom: 15px; text-align: center;"></div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <div id="progressStats" style="margin-top: 10px; text-align: center; color: #999; font-size: 0.9em;"></div>
                <div style="margin-top: 20px; text-align: center;">
                    <button id="progressCancelBtn" class="btn-danger" onclick="cancelBulkOperation()" style="display: none;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance Monitor Modal -->
    <div id="perfMonitorModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closePerformanceMonitor()">&times;</span>
            <h2 style="color: var(--primary-light);">⚡ Performance Monitor</h2>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 20px;">
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #4caf50;">
                    <h4 style="margin: 0 0 10px 0; color: #4caf50;">⏱️ Page Load</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>Load Time: <span id="loadTime" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>DOM Ready: <span id="domReady" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>First Paint: <span id="fcp" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #2196f3;">
                    <h4 style="margin: 0 0 10px 0; color: #2196f3;">💾 Memory</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>JS Heap: <span id="memory" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>LocalStorage: <span id="storageSize" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #ff9800;">
                    <h4 style="margin: 0 0 10px 0; color: #ff9800;">🔢 DOM Stats</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>Total Nodes: <span id="domNodes" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>Table Rows: <span id="tableRows" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; border-left: 3px solid #9c27b0;">
                    <h4 style="margin: 0 0 10px 0; color: #9c27b0;">⚡ Cache Status</h4>
                    <div style="font-size: 0.9em; color: var(--text-secondary);">
                        <div>Total Songs: <span id="totalSongsPerf" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>Filter Cache: <span id="filterCacheStatus" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                        <div>Stats Cache: <span id="statsCacheStatus" style="color: var(--text-primary); font-weight: bold;">-</span></div>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                <h4 style="color: var(--primary-light); margin: 0 0 10px 0;">🛠️ Developer Tools</h4>
                <button class="btn-secondary" onclick="logSlowOperations()" style="margin-right: 10px;">
                    Enable Slow Operation Logging
                </button>
                <button class="btn-secondary" onclick="console.log(performance.getEntries())">
                    Log All Performance Entries
                </button>
            </div>
            
            <div style="margin-top: 15px; font-size: 0.85em; color: var(--text-tertiary);">
                ℹ️ Metrics update every second while this modal is open. Slow operations (>100ms) are logged to console.
            </div>
        </div>
    </div>
    
    <!-- Performance Monitor Link (bottom of page) -->
    <div style="position: fixed; bottom: 10px; right: 10px; font-size: 0.75em; opacity: 0.5; transition: opacity 0.3s; z-index: 1000;" 
         onmouseover="this.style.opacity='1'" 
         onmouseout="this.style.opacity='0.5'">
        <a href="#" onclick="event.preventDefault(); openPerformanceMonitor();" 
           style="color: var(--text-tertiary); text-decoration: none; padding: 5px 10px; background: rgba(0,0,0,0.5); border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
            ⚡ Perf
        </a>
    </div>
</body>
</html>

